<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>第 12 节面向对象和原型——永不过时的话题</h1>
  <p><span class="fw-op  "><span>「</span></span>对象<span class=" fw-cl "><span>」</span></span>——这个概念在编程中非常重要<span class=" fw-cl "><span>，</span></span>任何语言和领域的开发者都应该具有面向对象思维<span class=" fw-cl "><span>，</span></span>能够有效运用对象<span class=" fw-cl "><span>。</span></span>良好的面向对象系统设计将是应用强健性<span class=" fw-cl "><span>、</span></span>可维护性和可扩展性的关键<span class=" fw-cl "><span>；</span></span>反之<span class=" fw-cl "><span>，</span></span>如果面向对象环节有失误<span class=" fw-cl "><span>，</span></span>那么将是项目的灾难<span class=" fw-cl "><span>。</span></span></p>
<p>说到 JavaScript 面向对象<span class=" fw-cl "><span>，</span></span>它实质是基于原型的对象系统<span class=" fw-cl "><span>，</span></span>而不是基于类的<span class=" fw-cl "><span>。</span></span>这是由设计之初所决定的<span class=" fw-cl "><span>，</span></span>是基因层面的<span class=" fw-cl "><span>。</span></span>随着 ES Next 标准的进化和新特性的添加<span class=" fw-cl "><span>，</span></span>使得 JavaScript 面向对象更加贴近其他传统面向对象型语言<span class=" fw-cl "><span>。</span></span>有幸目睹语言的发展和变迁<span class=" fw-cl "><span>，</span></span>伴随着某个语言的成长<span class=" fw-cl "><span>，</span></span>我认为是开发者之幸<span class=" fw-cl "><span>。</span></span></p>
<p>这一讲就让我们深入对象和原型<span class=" fw-cl "><span>，</span></span>理解 JavaScript 在这个方向上的能力<span class=" fw-cl "><span>。</span></span>请注意<span class=" fw-cl "><span>，</span></span><strong style="">我们不再过多赘述基础<span class=" fw-cl "><span>，</span></span>而是面向进阶<span class=" fw-cl "><span>，</span></span>需要读者具有一定的知识准备<span class=" fw-cl "><span>。</span></span></strong></p>
<p>相关知识点如下<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-b45b71f9c643aa14b786e8bd3867e72c.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:26.170212765957444% 0" data-src="https://pic3.zhimg.com/v2-b45b71f9c643aa14b786e8bd3867e72c.png">加载中...</span></figure>
<h3>实现 new 没有那么容易</h3>
<p>说起 JavaScript 当中的 new 关键字<span class=" fw-cl "><span>，</span></span>有一段很有趣的历史<span class=" fw-cl "><span>。</span></span>其实 JavaScript 创造者 Brendan Eich 实现 new 是为了获得更高的流行度<span class=" fw-cl "><span>，</span></span>它是强行学习 Java 的一个残留产出<span class=" fw-cl "><span>，</span></span>他想让 JavaScript 成为 Java 的小弟<span class=" fw-cl "><span>。</span></span>很多人认为这个设计掩盖了 JavaScript 中真正的原型继承<span class=" fw-cl "><span>，</span></span>只是表面上看<span class=" fw-cl "><span>，</span></span>更像是基于类的继承<span class=" fw-cl "><span>。</span></span></p>
<p>这样的误会使得很多传统 Java 开发者并不能很好理解 JavaScript<span class=" fw-cl "><span>。</span></span>实际上<span class=" fw-cl "><span>，</span></span>我们前端工程师应该明白<span class=" fw-cl "><span>，</span></span>new 关键字到底做了什么事情<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">step1<span class=" fw-cl "><span>：</span></span>首先创建一个空对象<span class=" fw-cl "><span>，</span></span>这个对象将会作为执行 new 构造函数() 之后<span class=" fw-cl "><span>，</span></span>返回的对象实例</li>
  <li style="">step2<span class=" fw-cl "><span>：</span></span>将上面创建的空对象的原型<span class="fw-op  "><span>（</span></span><code>__proto__</code><span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>指向构造函数的 prototype 属性</li>
  <li style="">step3<span class=" fw-cl "><span>：</span></span>将这个空对象赋值给构造函数内部的 this<span class=" fw-cl "><span>，</span></span>并执行构造函数逻辑</li>
  <li style="">step4<span class=" fw-cl "><span>：</span></span>根据构造函数执行逻辑<span class=" fw-cl "><span>，</span></span>返回第一步创建的对象或者构造函数的显式返回值</li>
</ul>
<p>因为 new 是 JavaScript 的关键字<span class=" fw-cl "><span>，</span></span>我们不能直接覆盖<span class=" fw-cl "><span>，</span></span>实现一个 newFunc 来进行模拟<span class=" fw-cl "><span>，</span></span>预计使用方式<span class=" fw-cl "><span>：</span></span></p>
<p><code>function Person(name) {<br>
 &nbsp;this.name = name<br>
}<br>
<br>
const person = new newFunc(Person, 'lucas')<br>
<br>
console.log(person)<br>
<br>
//&nbsp;{name: "lucas"}</code></p>
<p>实现为<span class=" fw-cl "><span>：</span></span></p>
<p><code>function newFunc(...args) {<br>
 &nbsp;// 取出 args 数组第一个参数<span class=" fw-cl "><span>，</span></span>即目标构造函数<br>
 &nbsp;const constructor = args.shift()<br>
<br>
 &nbsp;// 创建一个空对象<span class=" fw-cl "><span>，</span></span>且这个空对象继承构造函数的 prototype 属性<br>
 &nbsp;// 即实现 obj.__proto__ === constructor.prototype<br>
 &nbsp;const obj = Object.create(constructor.prototype)<br>
<br>
 &nbsp;// 执行构造函数<span class=" fw-cl "><span>，</span></span>得到构造函数返回结果<br>
 &nbsp;// 注意这里我们使用 apply<span class=" fw-cl "><span>，</span></span>将构造函数内的 this 指向为 obj<br>
 &nbsp;const result = constructor.apply(obj, args)<br>
<br>
 &nbsp;// 如果造函数执行后<span class=" fw-cl "><span>，</span></span>返回结果是对象类型<span class=" fw-cl "><span>，</span></span>就直接返回<span class=" fw-cl "><span>，</span></span>否则返回 obj 对象<br>
 &nbsp;return (typeof result === 'object' &amp;&amp; result != null) ? result : obj<br>
}</code></p>
<p>上述代码并不复杂<span class=" fw-cl "><span>，</span></span>几个关键点<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">使用 Object.create 将 obj 的 <code>__proto__</code> 指向为构造函数的原型</li>
  <li style="">使用 apply 方法<span class=" fw-cl "><span>，</span></span>将构造函数内的 this 指向为 obj</li>
  <li style="">在 newFunc 返回时<span class=" fw-cl "><span>，</span></span>使用三目运算符决定返回结果</li>
</ul>
<p>我们知道<span class=" fw-cl "><span>，</span></span>构造函数如果有显式返回值<span class=" fw-cl "><span>，</span></span>且返回值为对象类型<span class=" fw-cl "><span>，</span></span>那么构造函数返回结果不再是目标实例<span class=" fw-cl "><span>。</span></span>如下代码<span class=" fw-cl "><span>：</span></span></p>
<p><code>function Person(name) {<br>
 &nbsp;this.name = name<br>
 &nbsp;return {1: 1}<br>
}<br>
<br>
const person = new Person(Person, 'lucas')<br>
<br>
console.log(person)<br>
<br>
// {1: 1}</code></p>
<p>了解这些注意点<span class=" fw-cl "><span>，</span></span>对于理解 newFunc 的实现就不再困难<span class=" fw-cl "><span>。</span></span></p>
<h3>如何优雅地实现继承</h3>
<p>实现继承式是面向对象的一个重点概念<span class=" fw-cl "><span>。</span></span>我们前面提到过 JavaScript 的面向对象系统是基于原型的<span class=" fw-cl "><span>，</span></span>它的继承不同于其他大多数语言<span class=" fw-cl "><span>。</span></span></p>
<p>社区上对于 JavaScript 继承讲解的资料不在少数<span class=" fw-cl "><span>，</span></span>这里我不再赘述每一种继承方式的实现过程<span class=" fw-cl "><span>，</span></span>还需要开发者事先进行了解<span class=" fw-cl "><span>。</span></span></p>
<h4>ES5 相对可用的继承方案</h4>
<p>我们仅总结以下 JavaScript 中实现继承的关键点<span class=" fw-cl "><span>。</span></span></p>
<p>如果想使 Child 继承 Parent<span class=" fw-cl "><span>，</span></span>那么</p>
<ul>
  <li style="">原型链实现继承最关键的要点是<span class=" fw-cl "><span>：</span></span></li>
</ul>
<p><code>Child.prototype = new Parent()</code></p>
<p>这样的实现<span class=" fw-cl "><span>，</span></span>不同的 Child 实例的 <code>__proto__</code> 会引用同一 Parent 的实例<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">构造函数实现继承的要点是<span class=" fw-cl "><span>：</span></span></li>
</ul>
<p><code>function Child (args) {<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;Parent.call(this, args)<br>
}</code></p>
<p>这样的实现问题也比较大<span class=" fw-cl "><span>，</span></span>其实只是实现了实例属性继承<span class=" fw-cl "><span>，</span></span>Parent 原型的方法在 Child 实例中并不可用<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">组合继承的实现才基本可用<span class=" fw-cl "><span>，</span></span>其要点是<span class=" fw-cl "><span>：</span></span></li>
</ul>
<p><code>function Child (args1, args2) {<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;this.args2 = args2<br>
 &nbsp;&nbsp;&nbsp;Parent.call(this, args1)<br>
}<br>
Child.prototype = new Parent()<br>
Child.prototype.constrcutor = Child</code></p>
<p>它的问题在于 Child 实例会存在 Parent 的实例属性<span class=" fw-cl "><span>。</span></span>因为我们在 Child 构造函数中执行了 Parent 构造函数<span class=" fw-cl "><span>。</span></span>同时<span class=" fw-cl "><span>，</span></span><code>Child.__proto__</code> 也会存在同样的 Parent 的实例属性<span class=" fw-cl "><span>，</span></span>且所有 Child 实例的 <code>__proto__</code> 指向同一内存地址<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">同时上述实现也都没有对静态属性的继承</li>
</ul>
<p>还有一些其他不完美的继承方式<span class=" fw-cl "><span>，</span></span>我们这里不再过多介绍<span class=" fw-cl "><span>。</span></span></p>
<p>一个比较完整的实现为<span class=" fw-cl "><span>：</span></span></p>
<p><code>function inherit(Child, Parent) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;// 继承原型上的属性 <br>
 &nbsp;&nbsp;&nbsp;Child.prototype = Object.create(Parent.prototype)<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;// 修复 constructor<br>
 &nbsp;&nbsp;&nbsp;Child.prototype.constructor = Child<br>
<br>
 &nbsp;&nbsp;&nbsp;// 存储超类<br>
 &nbsp;&nbsp;&nbsp;Child.super = Parent<br>
<br>
 &nbsp;&nbsp;&nbsp;// 静态属性继承<br>
 &nbsp;&nbsp;&nbsp;if (Object.setPrototypeOf) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setPrototypeOf es6<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.setPrototypeOf(Child, Parent)<br>
 &nbsp;&nbsp;&nbsp;} else if (Child.__proto__) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// __proto__ es6 引入<span class=" fw-cl "><span>，</span></span>但是部分浏览器早已支持<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Child.__proto__ = Parent<br>
 &nbsp;&nbsp;&nbsp;} else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 兼容 IE10 等陈旧浏览器<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 将 Parent 上的静态属性和方法拷贝一份到 Child 上<span class=" fw-cl "><span>，</span></span>不会覆盖 Child 上的方法<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (var k in Parent) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Parent.hasOwnProperty(k) &amp;&amp; !(k in Child)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Child[k] = Parent[k]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
}</code></p>
<p>上面静态属性继承存在一个问题<span class=" fw-cl "><span>：</span></span>在陈旧浏览器中<span class=" fw-cl "><span>，</span></span>属性和方法的继承我们是静态拷贝的<span class=" fw-cl "><span>，</span></span>继承完后续父类的改动不会自动同步到子类<span class=" fw-cl "><span>。</span></span>这是不同于正常面向对象思想的<span class=" fw-cl "><span>。</span></span>但是这种组合式继承<span class=" fw-cl "><span>，</span></span>已经相对完美<span class=" fw-cl "><span>、</span></span>优雅<span class=" fw-cl "><span>。</span></span></p>
<h4>继承 Date</h4>
<p>值得一提的一个小细节是<span class=" fw-cl "><span>：</span></span>这种继承方式无法实现对 Date 对象的继承<span class=" fw-cl "><span>。</span></span>我们来进行测试<span class=" fw-cl "><span>：</span></span></p>
<p><code>function DateConstructor() {<br>
 &nbsp;&nbsp;&nbsp;Date.apply(this, arguments)<br>
 &nbsp;&nbsp;&nbsp;this.foo = 'bar'<br>
}<br>
<br>
inherit(DateConstructor, Date)<br>
<br>
DateConstructor.prototype.getMyTime = function() {<br>
 &nbsp;&nbsp;&nbsp;return this.getTime()<br>
};<br>
<br>
<br>
let date = new DateConstructor()<br>
<br>
console.log(date.getMyTime())</code></p>
<p>将会得到报错<span class=" fw-cl "><span>：</span></span>Uncaught TypeError: this is not a Date object.</p>
<p>究其原因<span class=" fw-cl "><span>，</span></span>是因为<span class=" fw-cl "><span>：</span></span> <strong style="">JavaScript 的日期对象只能通过 JavaScript Date 作为构造函数来实例化得到<span class=" fw-cl "><span>。</span></span></strong></p>
<p>因此 v8 引擎实现代码中就一定有所限制<span class=" fw-cl "><span>，</span></span>如果发现调用 getTime() 方法的对象不是 Date 构造函数构造出来的实例<span class=" fw-cl "><span>，</span></span>则抛出错误<span class=" fw-cl "><span>。</span></span></p>
<p>那么如何实现对 Date 的继承呢<span class=" fw-cl "><span>？</span></span></p>
<p><code>function DateConstructor() {<br>
 &nbsp;&nbsp;&nbsp;var dateObj = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))()<br>
<br>
 &nbsp;&nbsp;&nbsp;Object.setPrototypeOf(dateObj, DateConstructor.prototype)<br>
<br>
 &nbsp;&nbsp;&nbsp;dateObj.foo = 'bar'<br>
<br>
 &nbsp;&nbsp;&nbsp;return dateObj<br>
}<br>
<br>
Object.setPrototypeOf(DateConstructor.prototype, Date.prototype)<br>
<br>
DateConstructor.prototype.getMyTime = function getTime() {<br>
 &nbsp;&nbsp;&nbsp;return this.getTime()<br>
}<br>
<br>
let date = new DateConstructor()<br>
<br>
console.log(date.getMyTime())</code></p>
<p>我们来分析一下代码<span class=" fw-cl "><span>：</span></span>调用构造函数 DateConstructor 返回的对象 dateObj 有<span class=" fw-cl "><span>：</span></span></p>
<p><code>dateObj.__proto__ === DateConstructor.prototype</code></p>
<p>而我们通过<span class=" fw-cl "><span>：</span></span></p>
<p><code>Object.setPrototypeOf(DateConstructor.prototype, Date.prototype)</code></p>
<p>实现了<span class=" fw-cl "><span>：</span></span></p>
<p><code>DateConstructor.prototype.__proto__ === Date.prototype</code></p>
<p>因此连起来就是<span class=" fw-cl "><span>：</span></span></p>
<p><code>date.__proto__.__proto__ === Date.prototype</code></p>
<p>继续分析<span class=" fw-cl "><span>，</span></span>DateConstructor 构造函数里<span class=" fw-cl "><span>，</span></span>返回的 dateObj 是一个真正的 Date 对象<span class=" fw-cl "><span>，</span></span>因为<span class=" fw-cl "><span>：</span></span></p>
<p><code>var dateObj = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))()var dateObj = new(Function.prototype.bind.apply(Date, [Date].concat(Array.prototype.slice.call(arguments))))()</code></p>
<p>它终归还是由 Date 构造函数实例化出来<span class=" fw-cl "><span>，</span></span>因此它有权调用 Date 原型上的方法<span class=" fw-cl "><span>，</span></span>而不会被引擎所限制<span class=" fw-cl "><span>。</span></span></p>
<p>整个实现过程通过更改原型关系<span class=" fw-cl "><span>，</span></span>在构造函数里调用原生构造函数 Date<span class=" fw-cl "><span>，</span></span>并返回其实例的方法<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>欺骗了<span class=" fw-cl "><span>」</span></span>浏览器<span class=" fw-cl "><span>。</span></span>当然这样的做法比较取巧<span class=" fw-cl "><span>，</span></span>其副作用是更改了原型关系<span class=" fw-cl "><span>，</span></span>这样也会干扰浏览器某些优化操作<span class=" fw-cl "><span>。</span></span></p>
<p>那么有没有更加<span class="fw-op  "><span>「</span></span>体面<span class=" fw-cl "><span>」</span></span>的方式呢<span class=" fw-cl "><span>？</span></span></p>
<p>其实随着 ES6 class 的推出<span class=" fw-cl "><span>，</span></span>我们完全可以直接使用 extends 关键字了<span class=" fw-cl "><span>：</span></span></p>
<p><code>class DateConstructor extends Date {<br>
 &nbsp;&nbsp;&nbsp;constructor() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super()<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.foo ='bar'<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;getMyTime() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.getTime()<br>
 &nbsp;&nbsp;&nbsp;}<br>
}<br>
<br>
let date = new DateConstructor()</code></p>
<p>上面的方法可以完美执行<span class=" fw-cl "><span>：</span></span></p>
<p><code>date.getMyTime()<br>
// 1558921640586</code></p>
<p>直接在支持 ES6 class 的浏览器中完全没有问题<span class=" fw-cl "><span>。</span></span>可是我们项目大部分都是使用 Babel 进行编译<span class=" fw-cl "><span>。</span></span>按照上一讲 Babel 编译 class 的方法<span class=" fw-cl "><span>，</span></span>运行其产出后<span class=" fw-cl "><span>，</span></span>仍然会得到报错<span class=" fw-cl "><span>：</span></span>Uncaught TypeError: this is not a Date object.<span class=" fw-cl "><span>，</span></span>因此我们得知<span class=" fw-cl "><span>：</span></span>Babel 并没有对继承 Date 进行特殊处理<span class=" fw-cl "><span>，</span></span>无法做到兼容<span class=" fw-cl "><span>。</span></span></p>
<h4>ES6 实现继承剖析</h4>
<p>在 ES6 时代<span class=" fw-cl "><span>，</span></span>我们可以使用 class extends 进行继承<span class=" fw-cl "><span>。</span></span>但是我们都知道 ES6 的 class 其实也就是 ES5 原型的语法糖<span class=" fw-cl "><span>。</span></span>我们通过研究 Babel 编译结果<span class=" fw-cl "><span>，</span></span>来深入了解一下<span class=" fw-cl "><span>。</span></span></p>
<p>首先<span class=" fw-cl "><span>，</span></span>我们定义一个父类<span class=" fw-cl "><span>：</span></span></p>
<p><code>class Person {<br>
 &nbsp;&nbsp;&nbsp;constructor(){<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.type = 'person'<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>这个类包含了一个实例属性<span class=" fw-cl "><span>。</span></span></p>
<p>然后<span class=" fw-cl "><span>，</span></span>实现一个 Student 类<span class=" fw-cl "><span>，</span></span>这个<span class="fw-op  "><span>「</span></span>学生<span class=" fw-cl "><span>」</span></span>类继承<span class="fw-op  "><span>「</span></span>人<span class=" fw-cl "><span>」</span></span>类<span class=" fw-cl "><span>：</span></span></p>
<p><code>class Student extends Person {<br>
 &nbsp;&nbsp;&nbsp;constructor(){<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super()<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>从简出发<span class=" fw-cl "><span>，</span></span>我们定义的 Person 类只包含了 type 为 person 的这一个属性<span class=" fw-cl "><span>，</span></span>不含有方法<span class=" fw-cl "><span>。</span></span>我们 Student 类也继承了同样的属性<span class=" fw-cl "><span>。</span></span></p>
<p>如下<span class=" fw-cl "><span>：</span></span></p>
<p><code>var student1 = new Student()<br>
student1.type // "person"</code></p>
<p>我们进一步可以验证原型链上的关系<span class=" fw-cl "><span>：</span></span></p>
<p><code>student1 instanceof Student // true<br>
student1 instanceof Person // true<br>
student1.hasOwnProperty('type') // true</code></p>
<p>那么<span class=" fw-cl "><span>，</span></span>经过 Babel 编译<span class=" fw-cl "><span>，</span></span>我们的代码是什么样呢<span class=" fw-cl "><span>？</span></span></p>
<p>一步一步来看<span class=" fw-cl "><span>：</span></span></p>
<p><code>class Person {<br>
 &nbsp;&nbsp;&nbsp;constructor(){<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.type = 'person'<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>被编译为<span class=" fw-cl "><span>：</span></span></p>
<p><code>var Person = function Person() {<br>
 &nbsp;&nbsp;&nbsp;_classCallCheck(this, Person);<br>
 &nbsp;&nbsp;&nbsp;this.type = 'person';<br>
};</code></p>
<p>我们看到其实还是构造函数那一套<span class=" fw-cl "><span>。</span></span></p>
<p><code>class Student extends Person {<br>
 &nbsp;&nbsp;&nbsp;constructor(){<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super()<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>编译结果<span class=" fw-cl "><span>：</span></span></p>
<p><code>// 实现定义 Student 构造函数<span class=" fw-cl "><span>，</span></span>它是一个自执行函数<span class=" fw-cl "><span>，</span></span>接受父类构造函数为参数<br>
var Student = (function(_Person) {<br>
 &nbsp;&nbsp;&nbsp;// 实现对父类原型链属性的继承<br>
 &nbsp;&nbsp;&nbsp;_inherits(Student, _Person);<br>
<br>
 &nbsp;&nbsp;&nbsp;// 将会返回这个函数作为完整的 Student 构造函数<br>
 &nbsp;&nbsp;&nbsp;function Student() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 使用检测<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_classCallCheck(this, Student); &nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// _get 的返回值可以先理解为父类构造函数 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_get(Object.getPrototypeOf(Student.prototype), 'constructor', this).call(this);<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;return Student;<br>
})(Person);<br>
<br>
// _x 为 Student.prototype.__proto__<br>
// _x2 为'constructor'<br>
// _x3 为 this<br>
var _get = function get(_x, _x2, _x3) {<br>
 &nbsp;&nbsp;&nbsp;var _again = true;<br>
 &nbsp;&nbsp;&nbsp;_function: while (_again) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var object = _x,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;property = _x2,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;receiver = _x3;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_again = false;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Student.prototype.__proto__ 为 null 的处理<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (object === null) object = Function.prototype;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 以下是为了完整复制父类原型链上的属性<span class=" fw-cl "><span>，</span></span>包括属性特性的描述符<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var desc = Object.getOwnPropertyDescriptor(object, property);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (desc === undefined) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var parent = Object.getPrototypeOf(object);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (parent === null) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return undefined;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_x = parent;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_x2 = property;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_x3 = receiver;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_again = true;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;desc = parent = undefined;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue _function;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if ('value' in desc) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return desc.value;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var getter = desc.get;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (getter === undefined) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return undefined;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getter.call(receiver);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
};<br>
<br>
function _inherits(subClass, superClass) {<br>
 &nbsp;&nbsp;&nbsp;// superClass 需要为函数类型<span class=" fw-cl "><span>，</span></span>否则会报错<br>
 &nbsp;&nbsp;&nbsp;if (typeof superClass !== 'function' &amp;&amp; superClass !== null) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;// Object.create 第二个参数是为了修复子类的 constructor<br>
 &nbsp;&nbsp;&nbsp;subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor: {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: subClass,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enumerable: false,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writable: true,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configurable: true<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;});<br>
 &nbsp;&nbsp;&nbsp;// Object.setPrototypeOf 是否存在做了一个判断<span class=" fw-cl "><span>，</span></span>否则使用 __proto__<br>
 &nbsp;&nbsp;&nbsp;if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;<br>
}</code></p>
<p>我们进行拆解<span class=" fw-cl "><span>：</span></span></p>
<p><code>var Student = (function(_Person) {<br>
 &nbsp;&nbsp;&nbsp;_inherits(Student, _Person);<br>
<br>
 &nbsp;&nbsp;&nbsp;function Student() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_classCallCheck(this, Student); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_get(Object.getPrototypeOf(Student.prototype), 'constructor', this).call(this);<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;return Student;<br>
})(Person);</code></p>
<p>这是一个自执行函数<span class=" fw-cl "><span>，</span></span>它接受一个参数 Person<span class="fw-op  "><span>（</span></span>就是它要继承的父类<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>返回一个构造函数 Student<span class=" fw-cl "><span>。</span></span></p>
<p>上面 <code>_inherits</code> 方法的本质其实就是让 Student 子类继承 Person 父类原型链上的方法<span class=" fw-cl "><span>。</span></span>它的实现原理可以归结为一句话<span class=" fw-cl "><span>：</span></span></p>
<p><code>Student.prototype = Object.create(Person.prototype);<br>
Object.setPrototypeOf(Student, Person)</code></p>
<p>是不是这就非常熟悉了<span class=" fw-cl "><span>。</span></span>注意<span class=" fw-cl "><span>，</span></span>Object.create 接收了第二个参数<span class=" fw-cl "><span>，</span></span>这顺带实现了对 Student 的 constructor 修复<span class=" fw-cl "><span>。</span></span></p>
<p>以上通过 <code>_inherits</code> 实现了对父类原型链上属性的继承<span class=" fw-cl "><span>，</span></span>那么对于父类的实例属性<span class="fw-op  "><span>（</span></span>就是 constructor 定义的属性<span class=" fw-cl "><span>）</span></span>的继承<span class=" fw-cl "><span>，</span></span>也可以归结为一句话<span class=" fw-cl "><span>：</span></span></p>
<p><code>Person.call(this);</code></p>
<p>我们看到 Babel 将 class extends 编译成了 ES5 组合模式的继承<span class=" fw-cl "><span>，</span></span>这才是 JavaScript 面向对象的实质<span class=" fw-cl "><span>。</span></span></p>
<h3>jQuery 中的对象思想</h3>
<p>可能会有读者有这样的问题<span class=" fw-cl "><span>：</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>所有的面试官都那么注重面向对象<span class=" fw-cl "><span>，</span></span>可是我在工作中很少涉及到啊<span class=" fw-cl "><span>？</span></span>面向对象到底有什么用<span class=" fw-cl fw--collapsed"><span>？</span></span><span class=" fw-cl "><span>」</span></span></p>
<p>回答这个问题我想说<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>如果你没有开发大型复杂项目的经验<span class=" fw-cl "><span>，</span></span>不具备封装抽象的思想<span class=" fw-cl "><span>，</span></span>也许确实用不到面向对象<span class=" fw-cl "><span>，</span></span>也很难解释为什么要有面向对象的设计和考察<span class=" fw-cl fw--collapsed"><span>。</span></span><span class=" fw-cl "><span>」</span></span>这一讲<span class=" fw-cl "><span>，</span></span>我从 jQuery 源码架构设计入手<span class=" fw-cl "><span>，</span></span>来分析一下基本的原型和原型链知识如何在 jQuery 源码中发挥作用的<span class=" fw-cl "><span>。</span></span></p>
<blockquote><br></blockquote>
<p><span class="fw-op  "><span>「</span></span>什么<span class=" fw-cl "><span>，</span></span>这都哪一年了你还在说 jQuery<span class=" fw-cl fw--collapsed"><span>？</span></span><span class=" fw-cl "><span>」</span></span></p>
<p>其实优秀的思想是永远不过时的<span class=" fw-cl "><span>，</span></span>研究清楚 <code>$</code> 到底是个什么<span class=" fw-cl "><span>，</span></span>你会受益匪浅<span class=" fw-cl "><span>。</span></span>顺带我自己的一个知乎回答<span class=" fw-cl "><span>：</span></span><a href="https://www.zhihu.com/question/324179465/answer/694045746" title="jQuery 为什么还在发布新版本？">jQuery 为什么还在发布新版本<span class=" fw-cl fw--collapsed"><span>？</span></span></a><span class=" fw-cl "><span>。</span></span></p>
<p>从一个问题开始<span class=" fw-cl "><span>：</span></span></p>
<p><code>const pNodes = $('p')<br>
// 我们得到一个数组<br>
const divNodes= $('div')<br>
// 我们得到一个数组</code></p>
<p>但是我们又可以<span class=" fw-cl "><span>：</span></span></p>
<p><code>const pNodes = $('p')<br>
pNodes.addClass('className')</code></p>
<p>数组上可是没有 addClass 方法的吧<span class=" fw-cl "><span>？</span></span></p>
<p>这个问题先放一边<span class=" fw-cl "><span>。</span></span>我们想一想 <code>$</code> 是什么<span class=" fw-cl "><span>？</span></span>你的第一反应可能是一个函数<span class=" fw-cl "><span>，</span></span>因此我们可以这么调用执行<span class=" fw-cl "><span>：</span></span></p>
<p><code>$('p')</code></p>
<p>但是你一定又见过这样的使用<span class=" fw-cl "><span>：</span></span></p>
<p><code>$.ajax()</code></p>
<p>那么 <code>$</code> 又是一个对象<span class=" fw-cl "><span>，</span></span>它有 <code>ajax</code> 的静态方法<span class=" fw-cl "><span>。</span></span></p>
<p>类似<span class=" fw-cl "><span>：</span></span></p>
<p><code>// 构造函数<br>
function $() {<br>
<br>
}<br>
<br>
$.ajax = function () {<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
}</code></p>
<p>实际上<span class=" fw-cl "><span>，</span></span>我们翻看 jQuery 源码架构会发现<span class="fw-op  "><span>（</span></span>具体内容有删减和改动<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>：</span></span></p>
<p><code>var jQuery = (function(){<br>
 &nbsp;&nbsp;&nbsp;var $<br>
<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
<br>
 &nbsp;&nbsp;&nbsp;$ = function(selector, context) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return function (selector, context) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var dom = []<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dom.__proto__ = $.fn<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return dom<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;$.fn = {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addClass: function() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;$.ajax = function() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;return $<br>
})()<br>
<br>
window.jQuery = jQuery<br>
window.$ === undefined &amp;&amp; (window.$ = jQuery)</code></p>
<p>我们顺着源码分析<span class=" fw-cl "><span>，</span></span>当调用 <code>$('p')</code> 时<span class=" fw-cl "><span>，</span></span>最终返回的是 dom<span class=" fw-cl "><span>，</span></span>而 <code>dom.__proto__</code> 指向了 <code>$.fn</code><span class=" fw-cl "><span>，</span></span><code>$.fn</code> 是包含了多种方法的对象集合<span class=" fw-cl "><span>。</span></span>因此返回的结果<span class="fw-op  "><span>（</span></span>dom<span class=" fw-cl "><span>）</span></span>可以在其原型链上找到 addClass 这样的方法<span class=" fw-cl "><span>。</span></span>同理<span class=" fw-cl "><span>，</span></span><code>$('span')</code> 也不例外<span class=" fw-cl "><span>，</span></span>任何实例都不例外<span class=" fw-cl "><span>。</span></span></p>
<p><code>$('span').__proto__ === $.fn</code></p>
<p>同时 ajax 方法直接挂载在构造函数 <code>$</code> 上<span class=" fw-cl "><span>，</span></span>它是一个静态属性方法<span class=" fw-cl "><span>。</span></span></p>
<p>请读者仔细体会整个 jQuery 的架构<span class=" fw-cl "><span>，</span></span>其实翻译成 ES class 就很好理解了<span class="fw-op  "><span>（</span></span>不完全对等<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>：</span></span></p>
<p><code>class $ {<br>
 &nbsp;static ajax() {<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;}<br>
<br>
 &nbsp;constructor(selector, context) {<br>
 &nbsp;&nbsp;&nbsp;this.selector = selector<br>
 &nbsp;&nbsp;&nbsp;this.context = context<br>
<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;}<br>
<br>
 &nbsp;addClass() {<br>
 &nbsp;&nbsp;&nbsp;// &nbsp;...<br>
 &nbsp;}<br>
}</code></p>
<p>这个应用虽然并不复杂<span class=" fw-cl "><span>，</span></span>但是还是很微妙地表现出来了面向对象的精妙设计<span class=" fw-cl "><span>。</span></span></p>
<h3>类继承和原型继承的区别</h3>
<p>我们了解了 JavaScript 中的原型继承<span class=" fw-cl "><span>，</span></span>那么它和传统面向对象语言的类继承有什么不同呢<span class=" fw-cl "><span>？</span></span>这就涉及到编程语言范畴了<span class=" fw-cl "><span>，</span></span>传统的面向对象语言的类继承<span class=" fw-cl "><span>，</span></span>会引发一些问题<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">紧耦合问题</li>
  <li style="">脆弱基类问题</li>
  <li style="">层级僵化问题</li>
  <li style="">必然重复性问题</li>
  <li style="">大猩猩—香蕉问题</li>
</ul>
<p>这些内容属于纯理论<span class=" fw-cl "><span>，</span></span>多说无益<span class=" fw-cl "><span>。</span></span>但我借用 Eric Elliott 的著名文章<span class=" fw-cl "><span>：</span></span><a href="https://www.zcfy.cc/article/master-the-javascript-interview-what-s-the-difference-between-class-amp-prototypal-inheritance-2185.html" title="Difference between class prototypal inheritance">Difference between class prototypal inheritance</a><span class=" fw-cl "><span>，</span></span>展开一点<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-4a3a08d0dc550d2dfbee8d2788cba5c6.jpg" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:28.359374999999996% 0" data-src="https://pic1.zhimg.com/v2-4a3a08d0dc550d2dfbee8d2788cba5c6.jpg">加载中...</span></figure>
<p>从上图<span class=" fw-cl "><span>，</span></span>我们看出一些问题<span class="fw-op  "><span>（</span></span>单一继承<span class=" fw-cl "><span>、</span></span>紧耦合以及层级分类问题<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>对于类 8<span class=" fw-cl "><span>，</span></span>只想继承五边形的属性<span class=" fw-cl "><span>，</span></span>却得到了继承链上其他并不需要的属性<span class=" fw-cl "><span>，</span></span>比如五角星<span class=" fw-cl "><span>，</span></span>正方形属性<span class=" fw-cl "><span>。</span></span>这就是大猩猩/香蕉问题<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>我只想要一个香蕉<span class=" fw-cl "><span>，</span></span>但是你给我了整个森林<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span></p>
<p>对于类 9<span class=" fw-cl "><span>，</span></span>对比其父类<span class=" fw-cl "><span>，</span></span>我只需要把五角星属性修改成四角形<span class=" fw-cl "><span>，</span></span>但是五角星继承自基类 1<span class=" fw-cl "><span>，</span></span>如果要去修改<span class=" fw-cl "><span>，</span></span>那就影响整个继承树<span class="fw-op  "><span>（</span></span>脆弱基类/层级僵化问题<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>；</span></span>好吧<span class=" fw-cl "><span>，</span></span>我不去修改<span class=" fw-cl "><span>，</span></span>那就需要给类 9 新建一个基类<span class="fw-op  "><span>（</span></span>必然重复性问题<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>&nbsp;</p>
<p>那么基于原型的继承可以怎么解决上述问题呢<span class=" fw-cl "><span>？</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-d127c4d4287fda3b42f39be9e6c509d4.gif" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:16.62420382165605% 0" data-src="https://pic3.zhimg.com/v2-d127c4d4287fda3b42f39be9e6c509d4.gif">加载中...</span></figure>
<p>采用原型继承<span class=" fw-cl "><span>，</span></span>其实本质是对象组合<span class=" fw-cl "><span>，</span></span>可以避免复杂纵深的层级关系<span class=" fw-cl "><span>。</span></span>当类 1 需要四角星特性的时候<span class=" fw-cl "><span>，</span></span>只需要组合新特性即可<span class=" fw-cl "><span>，</span></span>不会影响到其他实例<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">上述图示出自<span class=" fw-cl "><span>：</span></span></strong><a href="https://mp.weixin.qq.com/s/CqXmu4n6aZsqB-jJ0O0t-g?" title="类继承和原型继承的区别"><strong style="">类继承和原型继承的区别</strong></a></p>
<p>了解了这些<span class=" fw-cl "><span>，</span></span>你还会吐槽 JavaScript 吗<span class=" fw-cl "><span>？</span></span>请爱上我们的 JavaScript 吧<span class=" fw-cl "><span>！</span></span></p>
<h3>面向对象在实战场景中的应用</h3>
<p>最后<span class=" fw-cl "><span>，</span></span>让我们分析一个真实场景案例<span class=" fw-cl "><span>。</span></span></p>
<p>在产品当中<span class=" fw-cl "><span>，</span></span>一个页面可能存在多处<span class="fw-op  "><span>「</span></span>收藏<span class=" fw-cl "><span>」</span></span>组件<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-980c915198aa991dda0b8d1750defdf3.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:72.16981132075472% 0" data-src="https://pic3.zhimg.com/v2-980c915198aa991dda0b8d1750defdf3.png">加载中...</span></figure>
<figure class="central"><img data-src="https://pic2.zhimg.com/v2-603b0169f5377a3f70b82a6ccd983287.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:68.38006230529595% 0" data-src="https://pic2.zhimg.com/v2-603b0169f5377a3f70b82a6ccd983287.png">加载中...</span></figure>
<p>点击按钮<span class=" fw-cl "><span>，</span></span>对页面进行收藏<span class=" fw-cl "><span>，</span></span>成功收藏之后<span class=" fw-cl "><span>，</span></span>按钮的状态会变为<span class="fw-op  "><span>「</span></span>已收藏<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>再点击不会有响应<span class=" fw-cl "><span>。</span></span></p>
<p>这样就出现页面中多处<span class="fw-op  "><span>「</span></span>收藏<span class=" fw-cl "><span>」</span></span>组件之间通信问题<span class=" fw-cl "><span>，</span></span>点击页面顶部收藏按钮成功收藏之后<span class=" fw-cl "><span>，</span></span>页面底部的收藏按钮状态也需要变化<span class=" fw-cl "><span>，</span></span>进行同步<span class=" fw-cl "><span>。</span></span></p>
<p>其实实现这个功能很简单<span class=" fw-cl "><span>，</span></span>但是历史代码实现方式如果落后<span class=" fw-cl "><span>，</span></span>耦合严重就很麻烦了<span class=" fw-cl "><span>。</span></span>良好的设计和肆意而为的实现差别是巨大的<span class=" fw-cl "><span>。</span></span></p>
<p>以 ES6 class 实现为例<span class=" fw-cl "><span>，</span></span>不借助任何框架<span class=" fw-cl "><span>，</span></span>我们实现这样的对象关系<span class=" fw-cl "><span>：</span></span>所有 UI 组件<span class="fw-op  "><span>（</span></span>包括收藏组件<span class=" fw-cl "><span>）</span></span>都会继承 UIBase class<span class=" fw-cl "><span>：</span></span></p>
<p><code>class Widget extends UIBase {<br>
 &nbsp;&nbsp;&nbsp;constructor() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>而 UIBase 本身会产生一个全局唯一的 id<span class=" fw-cl "><span>，</span></span>这样通过继承<span class=" fw-cl "><span>，</span></span>使得所有组件都有一个唯一的 id 标识<span class=" fw-cl "><span>。</span></span>同时<span class=" fw-cl "><span>，</span></span>UIBase 又继承 EventEmitter 这个 pub/sub 模式组件<span class=" fw-cl "><span>：</span></span></p>
<p><code>class UIBase extends EventEmitter{<br>
 &nbsp;&nbsp;&nbsp;constructor() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.guid = guid();<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>因此<span class=" fw-cl "><span>，</span></span>所有的组件也同样拥有了 pub/sub 模式<span class=" fw-cl "><span>，</span></span>即事件发布订阅功能<span class=" fw-cl "><span>。</span></span>这就相对完美的解决了组件之间的通信问题<span class=" fw-cl "><span>，</span></span>达到了<span class="fw-op  "><span>「</span></span>高内聚<span class=" fw-cl "><span>、</span></span>低耦合<span class=" fw-cl "><span>」</span></span>的效果<span class=" fw-cl "><span>。</span></span></p>
<p>具体来说<span class=" fw-cl "><span>，</span></span>我们的任何组件<span class=" fw-cl "><span>，</span></span>当然包括收藏按钮在发起收藏行为时<span class=" fw-cl "><span>：</span></span></p>
<p><code>widget.emit('favorAction')</code></p>
<p>同时<span class=" fw-cl "><span>，</span></span>其他的收藏组件<span class=" fw-cl "><span>：</span></span></p>
<p><code>widget.on('favorAction', function() {<br>
 &nbsp;&nbsp;&nbsp;// toggle status<br>
})</code></p>
<p>具体的实现结构如图<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-afbe220b5b4fb5a4fdef16496adb5fe7.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:44.099378881987576% 0" data-src="https://pic3.zhimg.com/v2-afbe220b5b4fb5a4fdef16496adb5fe7.png">加载中...</span></figure>
<p>这样的组件行为在一些先进的 MVVM<span class=" fw-cl "><span>、</span></span>MVC 等框架中可以良好的实现<span class=" fw-cl "><span>，</span></span>比如 React 框架中<span class=" fw-cl "><span>，</span></span>可以借助 Redux 实现组件间的通信<span class=" fw-cl "><span>。</span></span>Redux 实质就是一个事件发布订阅系统<span class=" fw-cl "><span>，</span></span>而 connect 就是将组件的行为具备<span class="fw-op  "><span>「</span></span>发布和订阅<span class=" fw-cl "><span>」</span></span>的能力<span class=" fw-cl "><span>。</span></span>在上述简单的架构中<span class=" fw-cl "><span>，</span></span>我们通过面向对象继承<span class=" fw-cl "><span>，</span></span>自动具备了这样的能力<span class=" fw-cl "><span>。</span></span></p>
<p>同样的设计思想也可以在 NodeJS 源码中找到线索<span class=" fw-cl "><span>，</span></span>想想 NodeJS 中的 EventEmitter 类即可<span class=" fw-cl "><span>。</span></span></p>
<h3>总结</h3>
<p>面向对象是一个永远说不完的话题<span class=" fw-cl "><span>，</span></span>更是一个永远不会过时的话题<span class=" fw-cl "><span>，</span></span>具备良好的面向对象架构能力<span class=" fw-cl "><span>，</span></span>对于开发者来说至关重要<span class=" fw-cl "><span>。</span></span>同时由于 JavaScript 面向对象的特殊性<span class=" fw-cl "><span>，</span></span>使它区别于其他语言<span class=" fw-cl "><span>，</span></span>而<span class="fw-op  "><span>「</span></span>与众不同<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>我们在了解 JavaScript 原型<span class=" fw-cl "><span>、</span></span>原型链知识的前提下<span class=" fw-cl "><span>，</span></span>对比其他语言的思想<span class=" fw-cl "><span>，</span></span>就变得非常重要和有意义了<span class=" fw-cl "><span>。</span></span></p><p><span style="display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);">备案号:YXX12lZRGvxfPoe3kdsgdE9</span></p>
</body>
</html>