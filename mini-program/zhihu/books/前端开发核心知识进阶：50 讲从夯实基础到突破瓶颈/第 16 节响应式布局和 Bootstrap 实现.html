<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>第 16 节响应式布局和 Bootstrap 实现</h1>
  <p>响应式这个概念曾经非常流行<span class=" fw-cl "><span>，</span></span>但从发展来看<span class=" fw-cl "><span>，</span></span>似乎<span class="fw-op  "><span>「</span></span>响应式<span class=" fw-cl "><span>」</span></span>布局不再是一个必不可少的话题<span class=" fw-cl "><span>。</span></span>究其原因我认为主要有以下几点<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">公司研发人力越来越充足<span class=" fw-cl "><span>，</span></span>PC 端<span class=" fw-cl "><span>、</span></span>移动端可以实现两套布局<span class=" fw-cl "><span>，</span></span>分项目维护</li>
  <li style="">响应式布局适配越来越简单</li>
</ul>
<p>但是我们仍然不能对这个概念<span class="fw-op  "><span>「</span></span>掉以轻心<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>因为响应式布局仍然有其存在的价值<span class=" fw-cl "><span>：</span></span>移动端碎片化的现象将会无限期存在<span class=" fw-cl "><span>；</span></span>前端也必然进入物联网<span class=" fw-cl "><span>，</span></span>任何设备界面的响应布局将会成为关键挑战<span class=" fw-cl "><span>。</span></span>除此之外<span class=" fw-cl "><span>，</span></span>响应式布局也体现了 CSS 的灵活和发展<span class=" fw-cl "><span>。</span></span></p>
<p>本讲我们就来深入这个话题<span class=" fw-cl "><span>，</span></span>相关知识点如下<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-862f7b2cb15523423c7d0ac24c041c24.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:35.26315789473684% 0" data-src="https://pic4.zhimg.com/v2-862f7b2cb15523423c7d0ac24c041c24.png">加载中...</span></figure>
<h3>上帝视角——响应式布局适配方案</h3>
<p>我们首先来梳理一下响应式布局的几种典型方案<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">传统 float 浮动布局</li>
  <li style="">相对单位布局</li>
  <li style="">媒体查询</li>
  <li style="">基于相对单位 rem 的 flexible 布局</li>
  <li style="">flex 布局</li>
  <li style="">grid 布局</li>
  <li style="">借助 JavaScript</li>
</ul>
<p>其中<span class="fw-op  "><span>「</span></span>传统 float 浮动布局<span class=" fw-cl "><span>」</span></span>已经在<span class="fw-op  "><span>「</span></span>第 3-1 课<span class=" fw-cl "><span>：</span></span>前端面试离不开的<span class="fw-op  "><span>「</span></span>面子工程<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>」</span></span>中有所体现<span class="fw-op  "><span>（</span></span>多栏自适应<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>这种实现方式比较传统<span class=" fw-cl "><span>，</span></span>且能力较弱<span class=" fw-cl "><span>。</span></span></p>
<p>相对单位布局比较容易理解<span class=" fw-cl "><span>，</span></span>梳理 CSS 中的相对单位有<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">em</li>
  <li style="">rem</li>
  <li style="">vh<span class=" fw-cl "><span>、</span></span>vw<span class=" fw-cl "><span>、</span></span>vmin<span class=" fw-cl "><span>、</span></span>vmax&nbsp;</li>
  <li style="">%</li>
  <li style="">calc()&nbsp;</li>
</ul>
<p>重点是理解这些相对单位的使用规范<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>到底是相对于谁<span class=" fw-cl "><span>」</span></span><span class="fw-op  fw--collapsed"><span>（</span></span>注意<span class=" fw-cl "><span>，</span></span>这也是一个很重要的面试考点<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>比如<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">em 相对于当前元素或当前元素继承来的字体的宽度<span class=" fw-cl "><span>，</span></span>但是每个字母或汉字的宽度有可能是不一样的<span class=" fw-cl "><span>，</span></span>那么一般来说<span class=" fw-cl "><span>，</span></span>就是一个大写字母 M 的宽度<span class="fw-op  "><span>（</span></span>事实上<span class=" fw-cl "><span>，</span></span>规范中有一个 x-height 概念<span class=" fw-cl "><span>，</span></span>建议取 X 的高度<span class=" fw-cl "><span>，</span></span>但并没有推荐绝对的计算执行标准<span class=" fw-cl "><span>，</span></span>还需要看浏览器的实现<span class=" fw-cl "><span>，</span></span>也有的地方采用 O 的高度<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>；</span></span>一个非常容易出错的点在于<span class=" fw-cl "><span>：</span></span>很多同学会认为 em 相对于父元素的字体大小<span class=" fw-cl "><span>，</span></span>但是实际上取决于应用在什么 CSS 属性上<span class=" fw-cl "><span>。</span></span>对于 font-size 来说<span class=" fw-cl "><span>，</span></span>em 相对于父元素的字体大小<span class=" fw-cl "><span>；</span></span>line-height 中<span class=" fw-cl "><span>，</span></span>em 却相对于自身字体的大小<span class=" fw-cl "><span>。</span></span></li>
  <li style="">rem 相对于根节点<span class="fw-op  "><span>（</span></span>html<span class=" fw-cl "><span>）</span></span>的字体大小<span class=" fw-cl "><span>，</span></span>根节点一个大写字母 M 的宽度<span class="fw-op  "><span>（</span></span>同上<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>这两个单位在响应式布局中非常重要<span class=" fw-cl "><span>，</span></span>我们后续在真实线上适配案例中就能发现<span class=" fw-cl "><span>，</span></span>以 rem 为核心<span class=" fw-cl "><span>，</span></span>诞生了淘宝的 flexible 响应式布局的方案<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">vw 相对于视口宽度<span class=" fw-cl "><span>，</span></span>100vw 就相当于一个视口宽度</li>
  <li style="">vh 同理<span class=" fw-cl "><span>，</span></span>1vh 表示视口高度的 1/100<span class=" fw-cl "><span>，</span></span>100vh 就是一个视口高度</li>
  <li style="">vmin 相对于视口的宽度或高度中较小的那个<span class=" fw-cl "><span>，</span></span>也就是 1vw 和 1vh 取最小<span class="fw-op  "><span>（</span></span>Math.min(1vw, 1vh)<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>；</span></span>vmax 相对于视口的宽度或高度中较大的那个<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>（</span></span>Math.max(1vw, 1vh)<span class=" fw-cl "><span>）</span></span></li>
  <li style="">% 的相对对象我们专门挑出来在后续的环节中介绍</li>
  <li style="">calc 也是一个响应式布局神器<span class=" fw-cl "><span>，</span></span>它使得 CSS 有了运算的能力<span class=" fw-cl "><span>：</span></span></li>
</ul>
<p><code>width: calc(100vw - 80px)</code></p>
<p>除了相对单位以外<span class=" fw-cl "><span>，</span></span>媒体查询<span class="fw-op  "><span>（</span></span>Media Query<span class=" fw-cl "><span>）</span></span>以及 flex<span class=" fw-cl "><span>、</span></span>grid 布局也都比较好理解<span class=" fw-cl "><span>。</span></span>相关内容都容易找到<span class=" fw-cl "><span>，</span></span>这里插播一下借助 JavaScript 实现响应式布局的案例<span class=" fw-cl "><span>，</span></span>结合上一讲<span class="fw-op  "><span>「</span></span>进击的 HTML 和 CSS<span class=" fw-cl "><span>」</span></span>中的 CSS 变量<span class=" fw-cl "><span>，</span></span>往往也能简化很多问题<span class=" fw-cl "><span>：</span></span></p>
<p><code>p {<br>
 &nbsp;&nbsp;&nbsp;height: var(--test-height);<br>
}<br>
<br>
function changePHeight (height)<br>
 &nbsp;&nbsp;&nbsp;document.documentElement.style.setProperty('--test-height', `${height}px);<br>
}</code></p>
<p>其实总结下来<span class=" fw-cl "><span>，</span></span>这也是一道非常常见的面试题<span class=" fw-cl "><span>：</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>你如何实现自适应<span class=" fw-cl "><span>？</span></span>如何做到响应式<span class=" fw-cl fw--collapsed"><span>？</span></span><span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>想必大家已经有所了解了<span class=" fw-cl "><span>。</span></span></p>
<p>事实上<span class=" fw-cl "><span>，</span></span>所有的响应式布局手段都不是单一的<span class=" fw-cl "><span>，</span></span>上述方法搭配使用<span class=" fw-cl "><span>，</span></span>效果更明显<span class=" fw-cl "><span>，</span></span>也更加简单可行<span class=" fw-cl "><span>。</span></span></p>
<p>下面我们通过分析线上案例<span class="fw-op  "><span>（</span></span>淘宝 + 网易<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>来了解真实环境下的解决方案<span class=" fw-cl "><span>。</span></span></p>
<h3>真实线上适配案例分析</h3>
<p>在进入分析前<span class=" fw-cl "><span>，</span></span>我们先罗列一下其他关于响应式布局的概念<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">屏幕分辨率</li>
  <li style="">像素</li>
  <li style="">PPI<span class="fw-op  "><span>（</span></span>Pixel Per Inch<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>：</span></span>每英寸包括的像素数</li>
  <li style="">DPI<span class="fw-op  "><span>（</span></span>Dot Per Inch<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>：</span></span>即每英寸包括的点数</li>
  <li style="">设备独立像素</li>
  <li style="">设备像素比<span class="fw-op  "><span>（</span></span>dpr<span class=" fw-cl "><span>）</span></span></li>
  <li style="">Meta Viewport</li>
</ul>
<p>不同设备的物理像素尺寸等信息可以参考<span class=" fw-cl "><span>：</span></span><a href="https://material.io/tools/devices/" title="Device Metrics">Device Metrics</a><span class=" fw-cl "><span>。</span></span></p>
<p>这些内容都可以在社区上了解到<span class=" fw-cl "><span>，</span></span>这里重点分析移动端页面的处理方案<span class=" fw-cl "><span>。</span></span></p>
<p>首先<span class=" fw-cl "><span>，</span></span>淘宝通过设置<span class=" fw-cl "><span>：</span></span></p>
<p><code><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"></code></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-833b347fa23900ccdec0dc40e3a9b361.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:48.427419354838705% 0" data-src="https://pic3.zhimg.com/v2-833b347fa23900ccdec0dc40e3a9b361.png">加载中...</span></figure>
<p>禁用了用户缩放功能<span class=" fw-cl "><span>，</span></span>使页面宽度和设备宽度对齐<span class=" fw-cl "><span>，</span></span>一般这种操作也是移动端的响应式适配的标配<span class=" fw-cl "><span>。</span></span></p>
<p>我们观察在页面根节点 HTML 元素上<span class=" fw-cl "><span>，</span></span>显式设置了 font-size<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-1c1f0d3ce615510d542ebb04b317536a.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:18.911290322580644% 0" data-src="https://pic4.zhimg.com/v2-1c1f0d3ce615510d542ebb04b317536a.png">加载中...</span></figure>
<p>并且进行试验<span class=" fw-cl "><span>，</span></span>当改变浏览器大小时<span class=" fw-cl "><span>，</span></span>html 的 font-size 会动态变化<span class=" fw-cl "><span>。</span></span>这样不难理解<span class=" fw-cl "><span>，</span></span> 采用 rem 作为相对单位的长宽数值<span class=" fw-cl "><span>，</span></span>都会随着 resize 事件进行变化<span class="fw-op  "><span>（</span></span>因为 html 的 font-size 动态变化<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>我们在其页面当中<span class=" fw-cl "><span>，</span></span>不难找到这样的代码<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-07b8b681b35daad2b86c7f926fe77a76.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:46.08870967741935% 0" data-src="https://pic4.zhimg.com/v2-07b8b681b35daad2b86c7f926fe77a76.png">加载中...</span></figure>
<p>我将其复制并美化出来<span class=" fw-cl "><span>，</span></span>得到<span class=" fw-cl "><span>：</span></span></p>
<p><code>!function(e, t) {<br>
 &nbsp;&nbsp;&nbsp;var n = t.documentElement,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = e.devicePixelRatio || 1;<br>
<br>
 &nbsp;&nbsp;&nbsp;function i() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var e = n.clientWidth / 3.75;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n.style.fontSize = e + "px"<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;if (function e() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.body ? t.body.style.fontSize = "16px" : t.addEventListener("DOMContentLoaded", e)<br>
 &nbsp;&nbsp;&nbsp;}(), i(), e.addEventListener("resize", i), e.addEventListener("pageshow", function(e) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.persisted &amp;&amp; i()<br>
 &nbsp;&nbsp;&nbsp;}), 2 &lt;= d) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var o = t.createElement("body"),<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = t.createElement("div");<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.style.border = ".5px solid transparent", o.appendChild(a), n.appendChild(o), 1 === a.offsetHeight &amp;&amp; n.classList.add("hairlines"), n.removeChild(o)<br>
 &nbsp;&nbsp;&nbsp;}<br>
}(window, document)</code></p>
<p>核心逻辑不难理解<span class=" fw-cl "><span>，</span></span>这是一个 IIFE<span class=" fw-cl "><span>，</span></span>在 DOMContentLoaded<span class=" fw-cl "><span>、</span></span>resize<span class=" fw-cl "><span>、</span></span>pageshow 事件触发时<span class=" fw-cl "><span>，</span></span>进行对 html 的 font-size 值设定<span class=" fw-cl "><span>，</span></span>计算方式<span class=" fw-cl "><span>：</span></span></p>
<p><code>font-size = document.documentElement.clientWidth / 3.75</code></p>
<p>为什么这么计算呢<span class=" fw-cl "><span>？</span></span>我可以肯定的是<span class=" fw-cl "><span>：</span></span>淘宝的工程师是按照设计 375px 的视觉稿完成的<span class=" fw-cl "><span>。</span></span>在 375px 视觉稿下<span class=" fw-cl "><span>，</span></span>html 的 font-size 为 100<span class=" fw-cl "><span>，</span></span>那么如果宽度是 75px 的元素<span class=" fw-cl "><span>，</span></span>就可以设置为 0.75rem<span class="fw-op  "><span>（</span></span>100 <em>0.75 = 75px<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>；</span></span>当设备宽度为 414px<span class="fw-op  "><span>（</span></span>iPhone8 plus<span class=" fw-cl "><span>）</span></span>时<span class=" fw-cl "><span>，</span></span>我们想让上述元素的宽度等比例自适应到 82.8px<span class="fw-op  "><span>（</span></span>75</em> 414 / 375<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>那么在 CSS 样式为 0.74rem 不变的前提下<span class=" fw-cl "><span>，</span></span>想计算得到 82.8px<span class=" fw-cl "><span>，</span></span>只需 HTML font-size 变为<span class=" fw-cl "><span>：</span></span>110.4px 即可<span class="fw-op  "><span>（</span></span>110.4 * 0.75 = 82.8<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>那么反向过来<span class=" fw-cl "><span>，</span></span>这个 110.4 的计算公式就是<span class=" fw-cl "><span>：</span></span></p>
<p><code>document.documentElement.clientWidth / 3.75</code></p>
<p>当然淘宝实现响应式布局除了依靠 rem 以外<span class=" fw-cl "><span>，</span></span>还大量运用了 flex 布局<span class=" fw-cl "><span>，</span></span>比如页面中最复杂的布局区块<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-0d8f1f40710d9bb48a7a434c9a007d86.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:16.169354838709676% 0" data-src="https://pic3.zhimg.com/v2-0d8f1f40710d9bb48a7a434c9a007d86.png">加载中...</span></figure>
<p>实现较为简单<span class=" fw-cl "><span>。</span></span></p>
<p>整套解决方案淘宝开源出来<span class=" fw-cl "><span>，</span></span>叫做 flexible 布局<span class=" fw-cl "><span>。</span></span>其实读到这里<span class=" fw-cl "><span>，</span></span>你已经理解了这个解决方案的核心原理<span class=" fw-cl "><span>。</span></span></p>
<p>我们再来看看网易的做法<span class=" fw-cl "><span>，</span></span>大体类似<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-8ea8e0526c90d8d9fd6ea13c034de099.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:22.903225806451612% 0" data-src="https://pic3.zhimg.com/v2-8ea8e0526c90d8d9fd6ea13c034de099.png">加载中...</span></figure>
<p>同样采用了 rem 布局<span class=" fw-cl "><span>，</span></span>但区别是网易并没有 JavaScript 介入计算 html 的 font-size<span class=" fw-cl "><span>，</span></span>而是通过媒体查询和 calc 手段<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>枚举<span class=" fw-cl "><span>」</span></span>了不同设备下不同的 HTML font-size 值<span class=" fw-cl "><span>。</span></span></p>
<p>在其页面中<span class=" fw-cl "><span>，</span></span>较为复杂的头部 slider 组件中<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic2.zhimg.com/v2-136a2364b67e98ad991ea406ba2e8177.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:27.983870967741936% 0" data-src="https://pic2.zhimg.com/v2-136a2364b67e98ad991ea406ba2e8177.png">加载中...</span></figure>
<p>slider 宽度明显是 JavaScript 获取设备宽度后动态赋值的<span class="fw-op  "><span>（</span></span>图中为 414px<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>而高度采用了 rem 布局<span class=" fw-cl "><span>：</span></span> 3.7 rem = 55.3px(calc(13.33333333vw) * 3.7)</p>
<p>总结一下<span class=" fw-cl "><span>，</span></span>响应式布局并没有那么困难<span class=" fw-cl "><span>，</span></span>我们需要掌握最基本的处理手段<span class=" fw-cl "><span>，</span></span>在实际场景中综合运用多种套路即可实现最大限度的灵活<span class=" fw-cl "><span>。</span></span></p>
<h3>Bootstrap 栅格实现思路</h3>
<p>Bootrap 栅格化是一个非常<span class="fw-op  "><span>「</span></span>伟大<span class=" fw-cl "><span>」</span></span>的实现<span class=" fw-cl "><span>，</span></span>我们在使用 Bootrap 布局时<span class=" fw-cl "><span>，</span></span>可以通过添加类的方法<span class=" fw-cl "><span>，</span></span>轻松实现栅格化<span class=" fw-cl "><span>，</span></span>流式布局<span class=" fw-cl "><span>。</span></span></p>
<p>我们选取代表性的 BS4 官网范例<span class=" fw-cl "><span>，</span></span>可以<a href="http://v4.bootcss.com/examples/dashboard/#" title="在线参考">在线参考</a><span class=" fw-cl "><span>，</span></span>或者参看以下截图<span class=" fw-cl "><span>，</span></span>在宽屏幕下<span class=" fw-cl "><span>，</span></span>我们看到<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-693b12480702a76083e89f69511d608a.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:19.072580645161292% 0" data-src="https://pic1.zhimg.com/v2-693b12480702a76083e89f69511d608a.png">加载中...</span></figure>
<p>当屏幕宽度小于 576px 时候<span class=" fw-cl "><span>，</span></span>我们有<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-f687773f9c1cdd67d8f6c6ace7e03390.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:86.12244897959184% 0" data-src="https://pic4.zhimg.com/v2-f687773f9c1cdd67d8f6c6ace7e03390.png">加载中...</span></figure>
<p>对应代码<span class=" fw-cl "><span>：</span></span></p>
<p><code></code></p><div class="col-6 col-sm-3"><code><br>
 &nbsp;&nbsp;&nbsp;...<br>
</code></div><code><br>
<div class="col-6 col-sm-3"><br>
 &nbsp;&nbsp;&nbsp;...<br>
</div><br>
<div class="col-6 col-sm-3"><br>
 &nbsp;&nbsp;&nbsp;...<br>
</div><br>
<div class="col-6 col-sm-3"><br>
 &nbsp;&nbsp;&nbsp;...<br>
</div></code><p></p>
<p>.col-6 class 样式在源码里面可以简单归纳<span class="fw-op  "><span>（</span></span>不完全<span class=" fw-cl "><span>）</span></span>为<span class=" fw-cl "><span>：</span></span></p>
<p><code>.col-6 {<br>
 &nbsp;&nbsp;&nbsp;-webkit-box-flex: 0;<br>
 &nbsp;&nbsp;&nbsp;-webkit-flex: 0 0 50%;<br>
 &nbsp;&nbsp;&nbsp;-ms-flex: 0 0 50%;<br>
 &nbsp;&nbsp;&nbsp;flex: 0 0 50%;<br>
 &nbsp;&nbsp;&nbsp;max-width: 50%;<br>
}</code></p>
<p>.col-sm-3 class 在源码里面可以归纳为<span class=" fw-cl "><span>：</span></span></p>
<p><code>.col-sm-3 {<br>
 &nbsp;&nbsp;&nbsp;-webkit-box-flex: 0;<br>
 &nbsp;&nbsp;&nbsp;-webkit-flex: 0 0 25%;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-ms-flex: 0 0 25%;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flex: 0 0 25%;<br>
 &nbsp;&nbsp;&nbsp;max-width: 25%;<br>
}</code></p>
<p>我们看到<span class=" fw-cl "><span>，</span></span>代码里设置了两个 class<span class=" fw-cl "><span>：</span></span>col-6 col-sm-3 进行样式声明<span class=" fw-cl "><span>。</span></span></p>
<p>从上面样式代码里看到类似 <code>flex: 0 0 25%</code> 的声明<span class=" fw-cl "><span>，</span></span>为了理解它<span class=" fw-cl "><span>，</span></span>我们从 flex 属性入手<span class=" fw-cl "><span>：</span></span>flex 属性是 flex-grow<span class=" fw-cl "><span>、</span></span>flex-shrink 和 flex-basis 的简写<span class="fw-op  "><span>（</span></span>类似 backgroud 是很多背景属性的简写一样<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>它的默认值为 0 1 auto<span class=" fw-cl "><span>，</span></span>后两个属性可选<span class=" fw-cl "><span>。</span></span>语法格式如下<span class=" fw-cl "><span>：</span></span></p>
<p><code>.item {<br>
 &nbsp;&nbsp;&nbsp;flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]<br>
}</code></p>
<ul>
  <li style="">flex-grow<span class=" fw-cl "><span>：</span></span>属性定义项目的放大比例<span class=" fw-cl "><span>，</span></span>默认为 0<span class=" fw-cl "><span>。</span></span>我们看到 Bootstrap 代码里这个值一直为 0<span class=" fw-cl "><span>，</span></span>即如果存在剩余空间<span class=" fw-cl "><span>，</span></span>也不放大<span class=" fw-cl "><span>。</span></span></li>
  <li style="">flex-shrink<span class=" fw-cl "><span>：</span></span>属性定义了项目的缩小比例<span class=" fw-cl "><span>，</span></span>默认为 1<span class=" fw-cl "><span>，</span></span>即如果空间不足<span class=" fw-cl "><span>，</span></span>该项目将缩小<span class=" fw-cl "><span>。</span></span></li>
  <li style="">flex-basis<span class=" fw-cl "><span>：</span></span>属性定义了在分配多余空间之前<span class=" fw-cl "><span>，</span></span>项目占据的主轴空间<span class="fw-op  "><span>（</span></span>main size<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>浏览器根据这个属性<span class=" fw-cl "><span>，</span></span>计算主轴是否有多余空间<span class=" fw-cl "><span>，</span></span>它可以设为跟 width 或 height 属性一样的值<span class="fw-op  "><span>（</span></span>比如 350px<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>则项目将占据固定空间<span class=" fw-cl "><span>。</span></span></p>
<p>Bootstrap 这里对 flex 设置为比例值<span class=" fw-cl "><span>，</span></span>这也是响应式自然而然实现的基础<span class=" fw-cl "><span>。</span></span></p>
<p>但是我们想<span class=" fw-cl "><span>，</span></span>很明显 col-6 col-sm-3 的样式属性是有冲突的<span class=" fw-cl "><span>，</span></span>那么他们是如何做到<span class="fw-op  "><span>「</span></span>和平共处<span class=" fw-cl "><span>」</span></span>交替发挥作用的呢<span class=" fw-cl "><span>？</span></span></p>
<p>事实上<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">在屏幕宽度大于 576px 时候<span class=" fw-cl "><span>，</span></span>会发现 .col-sm-3 并没有起作用<span class=" fw-cl "><span>，</span></span>这时候起作用的是 .col-6<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>我们在源码里发现 .col-sm-* 的样式声明全部在</p>
<p><code>&nbsp;@media (min-width: 576px) {...}</code></p>
<p>的媒体查询中<span class=" fw-cl "><span>，</span></span>这就保证了在 576px 宽度以上的屏幕<span class=" fw-cl "><span>，</span></span>只有在媒体查询之外的 .col-* 样式声明发挥了作用<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">在屏幕宽度小于 576px 时候<span class=" fw-cl "><span>，</span></span>命中媒体查询<span class=" fw-cl "><span>，</span></span>命中 .col-sm-3 的样式声明<span class=" fw-cl "><span>。</span></span>它的优先级一定大于 .col-6<span class="fw-op  "><span>（</span></span>媒体查询优先级高<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>这时候就保证了移动端的样式<span class="fw-op  "><span>「</span></span>占上风<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>再结合 col-6 col-sm-3 的样式声明<span class=" fw-cl "><span>，</span></span>我们可以简单总结一下<span class=" fw-cl "><span>：</span></span>Bootstrap 主要是通过百分比宽度<span class="fw-op  "><span>（</span></span>max-width: 50%; max-width: 25%;<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>以及 flex 属性<span class=" fw-cl "><span>，</span></span>再加上媒体查询<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>三管齐下<span class=" fw-cl "><span>」</span></span>实现了栅格化布局的主体<span class=" fw-cl "><span>。</span></span></p>
<p>当然整个过程实现还有很多其他细节<span class=" fw-cl "><span>，</span></span>我也一直认为 Bootstrap 的源码是管理大型样式项目的优秀典范<span class=" fw-cl "><span>，</span></span>有兴趣的读者可以参阅源码进行了解<span class=" fw-cl "><span>。</span></span></p>
<h3>横屏适配以及其他细节问题</h3>
<p>很多 H5 页面中<span class=" fw-cl "><span>，</span></span>我们要区分横屏和竖屏<span class=" fw-cl "><span>，</span></span>在不同屏幕下要显示不同的布局<span class=" fw-cl "><span>，</span></span>所以我们需要检测在不同的场景下给定不同的样式<span class=" fw-cl "><span>。</span></span>通常使用 JavaScript 检查<span class=" fw-cl "><span>：</span></span></p>
<p><code>window.addEventListener("resize", () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;if (window.orientation === 180 || window.orientation === 0) { <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('竖屏')<br>
 &nbsp;&nbsp;&nbsp;};<br>
 &nbsp;&nbsp;&nbsp;if (window.orientation === 90 || window.orientation === -90 ){ <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('横屏')<br>
 &nbsp;&nbsp;&nbsp;} &nbsp;<br>
})</code></p>
<p>我们同样可以使用纯 CSS 来实现不同场景下的布局<span class=" fw-cl "><span>：</span></span></p>
<p><code>@media screen and (orientation: portrait) {<br>
 &nbsp;/*竖屏样式代码*/<br>
} <br>
@media screen and (orientation: landscape) {<br>
 &nbsp;/*横屏样式代码.*/<br>
}</code></p>
<p>同时这里我们在总结一下其他常见的响应式布局话题<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">1px 问题</li>
  <li style="">适配 iPhoneX 齐刘海</li>
  <li style="">图片自适应</li>
</ul>
<p>这些问题都可以轻松找到解决思路<span class=" fw-cl "><span>，</span></span>我们不再详细给出<span class=" fw-cl "><span>。</span></span></p>
<h3>面试题<span class=" fw-cl "><span>：</span></span>% 相对于谁</h3>
<p>在之前的课程<span class="fw-op  "><span>《</span></span>前端面试必不可少的<span class="fw-op  "><span>「</span></span>面子工程<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>》</span></span>中我们讲解了实现水平垂直居中的几种方式<span class=" fw-cl "><span>。</span></span>其中 absolute + transform 方案<span class=" fw-cl "><span>：</span></span></p>
<p><code>.wp {<br>
 &nbsp;&nbsp;&nbsp;position: relative;<br>
}<br>
.box {<br>
 &nbsp;&nbsp;&nbsp;position: absolute;<br>
 &nbsp;&nbsp;&nbsp;top: 50%;<br>
 &nbsp;&nbsp;&nbsp;left: 50%;<br>
 &nbsp;&nbsp;&nbsp;transform: translate(-50%, -50%);<br>
}</code></p>
<p>我们用到了不止一处 % 单位<span class=" fw-cl "><span>。</span></span>事实上<span class=" fw-cl "><span>，</span></span>上述代码中的 % 还真代表着不一样的计算规则<span class=" fw-cl "><span>。</span></span>第一处 50% 是指 .wrap 相对定位元素宽度和高度的 50%<span class=" fw-cl "><span>，</span></span>而 transform 中的 50% 是指自身元素的宽高的一半<span class=" fw-cl "><span>。</span></span></p>
<p>那么在 CSS 中<span class=" fw-cl "><span>，</span></span>这个常见的 % 单位有着什么样的规则呢<span class=" fw-cl "><span>？</span></span>这也是一道很好的面试题目<span class=" fw-cl "><span>，</span></span>我们在这一部分进行梳理<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">position: absolute 中的 %</li>
</ul>
<p>对于设置绝对定位 position absolute 的元素<span class=" fw-cl "><span>，</span></span>我们可以使用 left right 表示其偏移量<span class=" fw-cl "><span>，</span></span>我们把这个元素的祖先元素中第一个存在定位属性的元素成为参照物元素<span class=" fw-cl "><span>，</span></span>其中的 % 是相对于参照物的<span class=" fw-cl "><span>，</span></span>left 相对于参照物的 width<span class=" fw-cl "><span>，</span></span>top 相对于这个参照物的 height<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">position: relative 中的 %</li>
</ul>
<p>对于设置相对定位 position relative 的元素<span class=" fw-cl "><span>，</span></span>% 的数值是相对与自身的<span class=" fw-cl "><span>，</span></span>left 相对于自己的 width<span class=" fw-cl "><span>，</span></span>top 相对于自己的 height<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">position: fixed 中的 %</li>
</ul>
<p>对于设置固定定位 position fixed 的元素<span class=" fw-cl "><span>，</span></span>% 的数值是相对于视口的<span class=" fw-cl "><span>，</span></span>left 相对于视口的 width<span class=" fw-cl "><span>，</span></span>top 相对于视口的 height<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">margin 和 padding 的 %</li>
</ul>
<p>margin 和 padding 当中的 % 非常特殊<span class=" fw-cl "><span>，</span></span>它是相对于父元素的宽度<span class=" fw-cl "><span>。</span></span>没错<span class=" fw-cl "><span>，</span></span>margin-top: 30%<span class=" fw-cl "><span>，</span></span>相当于父元素宽度的 30%</p>
<ul>
  <li style="">border-radius 的 %</li>
</ul>
<p>想想我们经常对一个正方形元素设置<span class=" fw-cl "><span>：</span></span></p>
<p><code>border-radius: 50%</code></p>
<p>得到一个圆形<span class=" fw-cl "><span>，</span></span>因此不难发现这里的 % 也是相对于自身宽高的<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">background-size 的 %</li>
</ul>
<p>background-size 的百分比和 border-radius 一样<span class=" fw-cl "><span>，</span></span>也是相对于自身的宽高<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">transform<span class=" fw-cl "><span>：</span></span> translate</li>
</ul>
<p>transform 的 translate 属性 % 是相对于自身的宽高<span class=" fw-cl "><span>，</span></span>这也是我们上述代码能够实现居中的原因<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">text-indent 的 %</li>
</ul>
<p>text-indent 这个属性可以设置首行缩进<span class=" fw-cl "><span>，</span></span>当使用 % 时<span class=" fw-cl "><span>，</span></span>它是相对于父元素的 width<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">font-size 的 %</li>
</ul>
<p>相对于父元素的字体大小<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">line-height 的 %</li>
</ul>
<p>line-height 设置行高时<span class=" fw-cl "><span>，</span></span>如果单位为 %<span class=" fw-cl "><span>，</span></span>则相对于该元素的 font-size 数值<span class=" fw-cl "><span>。</span></span></p>
<p>这些就是我们常见的使用 % 的情况<span class=" fw-cl "><span>，</span></span>还是很灵活多变的<span class=" fw-cl "><span>，</span></span>具体细节都可以在 CSS 规范中找到<span class=" fw-cl "><span>。</span></span>要求开发者的是了解常见的以及特殊的 % 场景<span class=" fw-cl "><span>。</span></span></p>
<h3>深入<span class=" fw-cl "><span>：</span></span>flex 布局和传统 float 布局性能对比</h3>
<p>最后这部分<span class=" fw-cl "><span>，</span></span>让我们来深入一个关于性能的话题<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>flex 布局对性能的影响主要体现在哪方面<span class=" fw-cl "><span>？</span></span></p>
<p>这个问题比较<span class="fw-op  "><span>「</span></span>偏门<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>很多读者在平时应该没有想过<span class=" fw-cl "><span>。</span></span>这里指出来的目的是开拓思路<span class=" fw-cl "><span>，</span></span>让我们更加合理地认识 CSS 布局<span class=" fw-cl "><span>。</span></span></p>
<p>我们先思考一下 <strong style="">flex 布局对性能到底有什么影响<span class=" fw-cl "><span>，</span></span>或者有多大影响<span class=" fw-cl "><span>。</span></span></strong></p>
<p><strong style="">首先性能问题一定是一个相对概念</strong><span class=" fw-cl "><span>，</span></span>flex 布局相比正常的 block layout<span class="fw-op  "><span>（</span></span>non-float<span class=" fw-cl "><span>）</span></span>性能开销一定更大<span class=" fw-cl "><span>。</span></span>事实上<span class=" fw-cl "><span>，</span></span>block layout 永远都是&nbsp;<strong style="">single-pass</strong><span class=" fw-cl "><span>，</span></span>算法进行布局<span class=" fw-cl "><span>，</span></span>而 flex 布局却总会激发&nbsp;<strong style="">multi-pass codepaths</strong> 算法布局<span class=" fw-cl "><span>。</span></span>比如常用的 flex-align: stretch 通常都是 2-pass<span class=" fw-cl "><span>，</span></span>这是无可争议且难以避免的短板<span class=" fw-cl "><span>，</span></span>天生基因决定<span class=" fw-cl "><span>。</span></span><span class="fw-op  fw--collapsed"><span>（</span></span>关于 single-pass 和 multi-pass codepaths<span class=" fw-cl "><span>，</span></span>图形学算法问题这里不再展开<span class=" fw-cl "><span>，</span></span>读者了解 single-pass 成本更低即可<span class=" fw-cl "><span>）</span></span></p>
<p>口说无凭<span class=" fw-cl "><span>，</span></span>我们来做一个对比<span class=" fw-cl "><span>，</span></span>display: table&nbsp;VS&nbsp;display: flex<span class=" fw-cl "><span>。</span></span></p>
<p>这里重复 1000 次这样的 DOM<span class=" fw-cl "><span>：</span></span></p>
<p><code></code></p><div class="wrap"><code><br>
 &nbsp;&nbsp;&nbsp;<div class="cell description">Item Description</div><br>
 &nbsp;&nbsp;&nbsp;<div class="cell add">Add</div><br>
 &nbsp;&nbsp;&nbsp;<div class="cell remove">Remove</div><br>
</code></div><p></p>
<p>分别使用 flex 和 table 布局<span class=" fw-cl "><span>，</span></span>并采用&nbsp;<a href="https://link.zhihu.com/?target=http%3A//www.w3.org/TR/navigation-timing/" title="Navigation Timing API">Navigation Timing API</a>&nbsp;进行布局速度测量<span class=" fw-cl "><span>。</span></span>代码如下<span class=" fw-cl "><span>：</span></span></p>
<p><code><script type="text/javascript"><br>
 &nbsp;&nbsp;&nbsp;;(function TimeThisMother() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.onload = function(){<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(function(){<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var t = performance.timing;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert("Speed of selection is: " + (t.loadEventEnd - t.responseEnd) + " milliseconds");<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, 0);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>
 &nbsp;&nbsp;&nbsp;})();<br>
</script></code></p>
<p>得到结果<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">flex 布局<span class=" fw-cl "><span>：</span></span>Speed of selection is: 248 milliseconds<span class=" fw-cl "><span>；</span></span></li>
  <li style="">table 布局<span class=" fw-cl "><span>：</span></span>Speed of selection is: 282 milliseconds<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>flex 布局要比 table 布局似乎更快<span class=" fw-cl "><span>。</span></span></p>
<p>曾经一个名叫 Chris Coyier 的开发者<span class=" fw-cl "><span>，</span></span>实现了这样一个 flex 布局生成器<span class=" fw-cl "><span>。</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-e5edca0b9e35617ecf2700eedf1b4dae.jpg" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:40.97222222222222% 0" data-src="https://pic4.zhimg.com/v2-e5edca0b9e35617ecf2700eedf1b4dae.jpg">加载中...</span></figure>
<p>注意右上角的滑动条<span class=" fw-cl "><span>，</span></span>越向右滑<span class=" fw-cl "><span>，</span></span>页面不同颜色区块越多<span class="fw-op  "><span>（</span></span>截图上滚动条已经很短了<span class=" fw-cl "><span>，</span></span>证明页面已经很长<span class=" fw-cl "><span>，</span></span>布局区块很多<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>在如此大规模全面使用 flex 布局下<span class=" fw-cl "><span>，</span></span>页面丝毫没有任何卡顿<span class=" fw-cl "><span>。</span></span></p>
<p>如上图<span class=" fw-cl "><span>，</span></span>打开 Chrome Dev Tools &gt; Timeline<span class=" fw-cl "><span>，</span></span>单击 record 按钮<span class=" fw-cl "><span>，</span></span>滑动滑块并停止<span class=" fw-cl "><span>。</span></span>我们得到瀑布流紫色部分<span class=" fw-cl "><span>，</span></span>显示性能效果良好<span class=" fw-cl "><span>。</span></span></p>
<p>当然这样的<span class="fw-op  "><span>「</span></span>模拟<span class=" fw-cl "><span>」</span></span>距离真实场景也许较远<span class=" fw-cl "><span>，</span></span>不排除如果页面中存在很多图片就会使得性能开销激增<span class=" fw-cl "><span>，</span></span>可能使用 flex 某些属性也会付出昂贵的代价<span class=" fw-cl "><span>。</span></span>但是一般场景使用<span class=" fw-cl "><span>，</span></span>我认为没有必要去担心 flex 布局性能问题<span class=" fw-cl "><span>，</span></span>至少它比别的方案靠谱<span class="fw-op  "><span>（</span></span>先不论兼容性<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">读者可以去 codepen 进行体验<span class=" fw-cl "><span>：</span></span></strong></p>
<p><a href="https://link.zhihu.com/?target=https%3A//codepen.io/chriscoyier/pen/LGmkn" title="Generate a Crapload of Flexbox​codepen.io<img data-src=" https:="" images.gitbook.cn="" 4107b7b0-90a1-11e9-8b34-c732c3ec276d"="" alt="图标" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:30% 0" data-src="https://images.gitbook.cn/4107b7b0-90a1-11e9-8b34-c732c3ec276d">加载中...</span>"&gt;Generate a Crapload of Flexbox​codepen.io</a></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-5de7a5b6440c83e4ecc938b27aaeae10.jpg" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:33.33333333333333% 0" data-src="https://pic3.zhimg.com/v2-5de7a5b6440c83e4ecc938b27aaeae10.jpg">加载中...</span></figure>
<p>最后<span class=" fw-cl "><span>，</span></span>需要格外提出的是<span class=" fw-cl "><span>：</span></span><strong style="">新版 flex 布局一般比旧版布局模型更快<span class=" fw-cl "><span>，</span></span>同样也比基于浮动的布局模型更快<span class=" fw-cl "><span>。</span></span></strong></p>
<p>这里来特殊对比一下 flex 布局和浮动布局在性能上的表现<span class=" fw-cl "><span>。</span></span></p>
<p>下图显示了在 1,300 个框上使用浮动的布局开销<span class=" fw-cl "><span>。</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-124bd75f2627da59ea3668316b8f3ef5.jpg" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:32.083333333333336% 0" data-src="https://pic1.zhimg.com/v2-124bd75f2627da59ea3668316b8f3ef5.jpg">加载中...</span></figure>
<p>我们更新此示例以使用 flex<span class=" fw-cl "><span>，</span></span>则出现不同的情况<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-f194bc8a6ddb8ce7299348fee34ee329.jpg" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:30.76388888888889% 0" data-src="https://pic3.zhimg.com/v2-f194bc8a6ddb8ce7299348fee34ee329.jpg">加载中...</span></figure>
<p>很明显<span class=" fw-cl "><span>，</span></span>对于相同数量的元素和相同的视觉外观<span class=" fw-cl "><span>，</span></span>flex 布局的时间要少得多<span class="fw-op  "><span>（</span></span>本例中分别为 3.5 毫秒和 14 毫秒<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>对比来源<span class=" fw-cl "><span>：</span></span><a href="https://link.zhihu.com/?target=http%3A//developers.google.com/" title="developers.google.com">developers.google.com</a><span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">最后<span class=" fw-cl "><span>，</span></span>布局性能的开销<span class=" fw-cl "><span>，</span></span>一般直接考虑如下因素<span class=" fw-cl "><span>：</span></span></strong></p>
<ul>
  <li style="">需要布局的元素数量</li>
  <li style="">布局的复杂性</li>
</ul>
<p>相对地<span class=" fw-cl "><span>，</span></span><strong style="">对于布局性能建议主要有<span class=" fw-cl "><span>：</span></span></strong></p>
<ul>
  <li style="">应尽可能避免触发布局<span class="fw-op  "><span>（</span></span>layout／reflow<span class=" fw-cl "><span>）</span></span></li>
  <li style="">避免强制同步布局和布局抖动</li>
</ul>
<p>这些面就更大了<span class=" fw-cl "><span>，</span></span>我们会在页面性能优化课程中继续这个话题<span class=" fw-cl "><span>。</span></span>这里通过结论<span class=" fw-cl "><span>，</span></span>想告诉大家的是<span class=" fw-cl "><span>：</span></span>不论什么样的布局<span class=" fw-cl "><span>，</span></span>在性能上一般很难成为瓶颈<span class=" fw-cl "><span>。</span></span>同时另一方面<span class=" fw-cl "><span>，</span></span>CSS 看似简单<span class=" fw-cl "><span>，</span></span>却也和性能息息相关<span class=" fw-cl "><span>。</span></span></p>
<h3>总结</h3>
<p>这一讲我们分析了实现响应式布局的常用手段<span class=" fw-cl "><span>，</span></span>并结合实际案例加以剖析<span class=" fw-cl "><span>；</span></span>同时讨论了布局方案对于页面性能的影响<span class=" fw-cl "><span>。</span></span>到此为止<span class=" fw-cl "><span>，</span></span>HTML 和 CSS 相关的内容终于告一段落了<span class=" fw-cl "><span>，</span></span>读者应该能有一个清晰的认识<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">HTML 和 CSS 很重要</li>
  <li style="">HTML 和 CSS 如果不花心思<span class=" fw-cl "><span>，</span></span>也不好学</li>
</ul>
<p>但是关于 HTML 和 CSS 我们更应该注重实战<span class=" fw-cl "><span>，</span></span>也许可以暂时不用<span class="fw-op  "><span>「</span></span>系统化<span class=" fw-cl "><span>」</span></span>地去了解<span class=" fw-cl "><span>，</span></span>但是遇见一个案例<span class=" fw-cl "><span>，</span></span>就去攻克一个案例<span class=" fw-cl "><span>，</span></span>慢慢地<span class=" fw-cl "><span>，</span></span>你也能成为 HTML 和 CSS 专家<span class=" fw-cl "><span>！</span></span></p>
<h3><br></h3><p><span style="display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);">备案号:YXX1yLrxJnLFjAgXwzFk9NJ</span></p>
</body>
</html>