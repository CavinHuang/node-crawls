<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>第 22 节同构应用中你所忽略的细节</h1>
  <p>不管是服务端渲染还是服务端渲染衍生出的同构应用<span class=" fw-cl "><span>，</span></span>现在来看已经并不新鲜了<span class=" fw-cl "><span>，</span></span>实现起来也并不困难<span class=" fw-cl "><span>。</span></span>可是有的开发者认为<span class=" fw-cl "><span>：</span></span>同构应用不就是调用一个 renderToString<span class="fw-op  "><span>（</span></span>React 中<span class=" fw-cl "><span>）</span></span>类似的 API 吗<span class=" fw-cl "><span>？</span></span></p>
<p>讲道理确实是这样的<span class=" fw-cl "><span>，</span></span>但是讲道理你也许并没有真正在实战中领会同构应用的精髓<span class=" fw-cl "><span>。</span></span></p>
<p>同构应用能够完成的本质条件是虚拟 DOM<span class=" fw-cl "><span>，</span></span>基于虚拟 DOM 我们可以生成真实的 DOM<span class=" fw-cl "><span>，</span></span>并由浏览器渲染<span class=" fw-cl "><span>；</span></span>也可以调用不同框架的不同 APIs<span class=" fw-cl "><span>，</span></span>将虚拟 DOM 生成字符串<span class=" fw-cl "><span>，</span></span>由服务端传输给客户端<span class=" fw-cl "><span>。</span></span></p>
<p>但是同构应用也不只是这么简单<span class=" fw-cl "><span>。</span></span>拿面试来说<span class=" fw-cl "><span>，</span></span>同构应用的考察点不是<span class="fw-op  "><span>「</span></span>纸上谈兵<span class=" fw-cl "><span>」</span></span>的理论<span class=" fw-cl "><span>，</span></span>而是实际实施时的细节<span class=" fw-cl "><span>。</span></span>这一讲我们就来聊一聊<span class="fw-op  "><span>「</span></span>同构应用中往往被忽略的细节<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>需要读者提前了解服务端渲染和同构应用的概念<span class=" fw-cl "><span>。</span></span></p>
<p>相关知识点如下<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic2.zhimg.com/v2-25910174b3cb3d895c86405207c91401.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:58.13449023861171% 0" data-src="https://pic2.zhimg.com/v2-25910174b3cb3d895c86405207c91401.png">加载中...</span></figure>
<h3>打包环境区分</h3>
<p>第一个细节<span class=" fw-cl "><span>：</span></span>我们知道同构应用实现了客户端代码和服务端代码的基本统一<span class=" fw-cl "><span>，</span></span>我们只需要编写一种组件<span class=" fw-cl "><span>，</span></span>就能生成适用于服务端和客户端的组件案例<span class=" fw-cl "><span>。</span></span>可是你是否知道<span class=" fw-cl "><span>，</span></span>服务端代码和客户端代码大多数情况下还是需要单独处理<span class=" fw-cl "><span>？</span></span>比如<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">路由代码差别<span class=" fw-cl "><span>：</span></span>服务端需要根据请求路径<span class=" fw-cl "><span>，</span></span>匹配页面组件<span class=" fw-cl "><span>；</span></span>客户端需要通过浏览器中的地址<span class=" fw-cl "><span>，</span></span>匹配页面组件<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>客户端代码<span class=" fw-cl "><span>：</span></span></p>
<p><code>const App = () =&gt; {<br>
 &nbsp;return (<br>
 &nbsp;&nbsp;&nbsp;<provider store="{store}"><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<browserrouter><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</browserrouter></provider></code></p><div><code><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<route path="/" component="{Home}"><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<route path="/product" component="{Product}"><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</route></route></code></div><code><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;)<br>
}<br>
ReactDom.render(<app>, document.querySelector('#root'))</app></code><p></p>
<p>BrowserRouter 组件根据 window.location 以及 history API 实现页面切换<span class=" fw-cl "><span>，</span></span>而服务端肯定是无法获取 window.location 的<span class=" fw-cl "><span>，</span></span>服务端代码如下<span class=" fw-cl "><span>：</span></span></p>
<p><code>const App = () =&gt; {<br>
 &nbsp;return <br>
 &nbsp;&nbsp;&nbsp;<provider store="{store}"><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<staticrouter location="{req.path}" context="{context}"><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</staticrouter></provider></code></p><div><code><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<route path="/" component="{Home}"><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</route></code></div><code><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;<br>
}<br>
Return ReactDom.renderToString(<app>)</app></code><p></p>
<p>需要使用 StaticRouter 组件<span class=" fw-cl "><span>，</span></span>并将请求地址和上下文信息作为 location 和 context 这两个 props 传入 StaticRouter 中<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style=""><br></li>
</ul>
<p>打包差别<span class=" fw-cl "><span>：</span></span>服务端运行的代码如果需要依赖 Node 核心模块或者第三方模块<span class=" fw-cl "><span>，</span></span>就不再需要把这些模块代码打包到最终代码中了<span class=" fw-cl "><span>。</span></span>因为环境已经安装这些依赖<span class=" fw-cl "><span>，</span></span>可以直接引用<span class=" fw-cl "><span>。</span></span>这样一来<span class=" fw-cl "><span>，</span></span>就需要我们在 webpack 中配置<span class=" fw-cl "><span>：</span></span>target<span class=" fw-cl "><span>：</span></span>node<span class=" fw-cl "><span>，</span></span>并借助 webpack-node-externals 插件<span class=" fw-cl "><span>，</span></span>解决第三方依赖打包的问题<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style=""><br></li>
</ul>
<p>对于图片等静态资源<span class=" fw-cl "><span>，</span></span>url-loader 会在服务端代码和客户端代码打包过程中分别被引用<span class=" fw-cl "><span>，</span></span>因此会在资源目录中生成了重复的文件<span class=" fw-cl "><span>。</span></span>当然后打包出来的因为重名<span class=" fw-cl "><span>，</span></span>会覆盖前一次打包出来的结果<span class=" fw-cl "><span>，</span></span>并不影响使用<span class=" fw-cl "><span>，</span></span>但是整个构建过程并不优雅<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style=""><br></li>
</ul>
<p>由于路由在服务端和客户端的差别<span class=" fw-cl "><span>，</span></span>因此 webpack 配置文件的 entry 会不相同<span class=" fw-cl "><span>：</span></span></p>
<p><code>{<br>
 &nbsp;&nbsp;&nbsp;entry: './src/client/index.js',<br>
}<br>
<br>
{<br>
 &nbsp;&nbsp;&nbsp;entry: './src/server/index.js',<br>
}</code></p>
<h3>注水和脱水</h3>
<p>什么叫做注水和脱水呢<span class=" fw-cl "><span>？</span></span>这个和同构应用中数据的获取有关<span class=" fw-cl "><span>：</span></span>在服务器端渲染时<span class=" fw-cl "><span>，</span></span>首先服务端请求接口拿到数据<span class=" fw-cl "><span>，</span></span>并处理准备好数据状态<span class="fw-op  "><span>（</span></span>如果使用 Redux<span class=" fw-cl "><span>，</span></span>就是进行 store 的更新<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>为了减少客户端的请求<span class=" fw-cl "><span>，</span></span>我们需要保留住这个状态<span class=" fw-cl "><span>。</span></span>一般做法是在服务器端返回 HTML 字符串的时候<span class=" fw-cl "><span>，</span></span>将数据 JSON.stringify 一并返回<span class=" fw-cl "><span>，</span></span>这个过程<span class=" fw-cl "><span>，</span></span>叫做脱水<span class="fw-op  "><span>（</span></span>dehydrate<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>；</span></span>在客户端<span class=" fw-cl "><span>，</span></span>就不再需要进行数据的请求了<span class=" fw-cl "><span>，</span></span>可以直接使用服务端下发下来的数据<span class=" fw-cl "><span>，</span></span>这个过程叫注水<span class="fw-op  "><span>（</span></span>hydrate<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>用代码来表示<span class=" fw-cl "><span>：</span></span></p>
<p>服务端<span class=" fw-cl "><span>：</span></span></p>
<p><code>ctx.body = `<br>
 &nbsp;<br>
 &nbsp;<br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<meta charset="UTF-8"><br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<script><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.context = {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialState: ${JSON.stringify(store.getState())}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</script><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p><div id="app"><code><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></div><code><br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;<br>
`</code><p></p>
<p>客户端<span class=" fw-cl "><span>：</span></span></p>
<p><code>export const getClientStore = () =&gt; {<br>
 &nbsp;const defaultState = JSON.parse(window.context.state)<br>
 &nbsp;return createStore(reducer, defaultState, applyMiddleware(thunk))<br>
}</code></p>
<p>这一系列过程非常典型<span class=" fw-cl "><span>，</span></span>但是也会有几个细节值得探讨<span class=" fw-cl "><span>：</span></span><strong style="">在服务端渲染时<span class=" fw-cl "><span>，</span></span>服务端如何能够请求所有的 APIs<span class=" fw-cl "><span>，</span></span>保障数据全部已经请求呢<span class=" fw-cl "><span>？</span></span></strong></p>
<p>一般有两种方法<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">react-router 的解决方案是配置路由 route-config<span class=" fw-cl "><span>，</span></span>结合 matchRoutes<span class=" fw-cl "><span>，</span></span>找到页面上相关组件所需的请求接口的方法并执行请求<span class=" fw-cl "><span>。</span></span>这就要求开发者通过路由配置信息<span class=" fw-cl "><span>，</span></span>显式地告知服务端请求内容<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>我们首先配置路由<span class=" fw-cl "><span>：</span></span></p>
<p><code>const routes = [<br>
 &nbsp;{<br>
 &nbsp;&nbsp;&nbsp;path: "/",<br>
 &nbsp;&nbsp;&nbsp;component: Root,<br>
 &nbsp;&nbsp;&nbsp;loadData: () =&gt; getSomeData()<br>
 &nbsp;}<br>
 &nbsp;// etc.<br>
]<br>
<br>
import { routes } from "./routes"<br>
<br>
function App() {<br>
 &nbsp;return (<br>
 &nbsp;&nbsp;&nbsp;<switch><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{routes.map(route =&gt; (<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<route {...route}=""><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))}<br>
 &nbsp;&nbsp;&nbsp;</route></switch><br>
 &nbsp;)<br>
}</code></p>
<p>在服务端代码中<span class=" fw-cl "><span>：</span></span></p>
<p><code>import { matchPath } from "react-router-dom"<br>
<br>
const promises = []<br>
routes.some(route =&gt; {<br>
 &nbsp;const match = matchPath(req.path, route)<br>
 &nbsp;if (match) promises.push(route.loadData(match))<br>
 &nbsp;return match<br>
})<br>
<br>
Promise.all(promises).then(data =&gt; {<br>
 &nbsp;putTheDataSomewhereTheClientCanFindIt(data)<br>
})</code></p>
<ul>
  <li style="">另外一种思路类似 Next.js<span class=" fw-cl "><span>，</span></span>我们需要在 React 组件上定义静态方法<span class=" fw-cl "><span>。</span></span> 比如定义静态 loadData 方法<span class=" fw-cl "><span>，</span></span>在服务端渲染时<span class=" fw-cl "><span>，</span></span>我们可以遍历所有组件的 loadData<span class=" fw-cl "><span>，</span></span>获取需要请求的接口<span class=" fw-cl "><span>。</span></span>这样的方式借鉴了早期 React-apollo 的解决方案<span class=" fw-cl "><span>，</span></span>我个人很喜欢这种设计<span class=" fw-cl "><span>。</span></span>这里贴出我为 Facebook 团队 react-apollo 开源项目贡献的改动代码<span class=" fw-cl "><span>，</span></span>其目的就是遍历组件<span class=" fw-cl "><span>，</span></span>获取请求接口<span class=" fw-cl "><span>：</span></span></li>
</ul>
<p><code>function getPromisesFromTree({<br>
 &nbsp;rootElement,<br>
 &nbsp;rootContext = {},<br>
}: PromiseTreeArgument): PromiseTreeResult[] {<br>
 &nbsp;const promises: PromiseTreeResult[] = [];<br>
<br>
 &nbsp;walkTree(rootElement, rootContext, (_, instance, context, childContext) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;if (instance &amp;&amp; hasFetchDataFunction(instance)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const promise = instance.fetchData();<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isPromise<object>(promise)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promises.push({ promise, context: childContext || context, instance });<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;});<br>
<br>
 &nbsp;return promises;<br>
}<br>
<br>
// Recurse a React Element tree, running visitor on each element.<br>
// If visitor returns `false`, don't call the element's render function<br>
// or recurse into its child elements.<br>
export function walkTree(<br>
 &nbsp;element: React.ReactNode,<br>
 &nbsp;context: Context,<br>
 &nbsp;visitor: (<br>
 &nbsp;&nbsp;&nbsp;element: React.ReactNode,<br>
 &nbsp;&nbsp;&nbsp;instance: React.Component<any> | null,<br>
 &nbsp;&nbsp;&nbsp;context: Context,<br>
 &nbsp;&nbsp;&nbsp;childContext?: Context,<br>
 &nbsp;) =&gt; boolean | void,<br>
) {<br>
 &nbsp;if (Array.isArray(element)) {<br>
 &nbsp;&nbsp;&nbsp;element.forEach(item =&gt; walkTree(item, context, visitor));<br>
 &nbsp;&nbsp;&nbsp;return;<br>
 &nbsp;}<br>
<br>
 &nbsp;if (!element) {<br>
 &nbsp;&nbsp;&nbsp;return;<br>
 &nbsp;}<br>
<br>
 &nbsp;// A stateless functional component or a class<br>
 &nbsp;if (isReactElement(element)) {<br>
 &nbsp;&nbsp;&nbsp;if (typeof element.type === 'function') {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const Comp = element.type;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const props = Object.assign({}, Comp.defaultProps, getProps(element));<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let childContext = context;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let child;<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Are we are a react class?<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isComponentClass(Comp)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const instance = new Comp(props, context);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// In case the user doesn't pass these to super in the constructor.<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note: `Component.props` are now readonly in `@types/react`, so<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// we're using `defineProperty` as a workaround (for now).<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.defineProperty(instance, 'props', {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: instance.props || props,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.context = instance.context || context;<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set the instance state to null (not undefined) if not set, to match React behaviour<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.state = instance.state || null;<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Override setState to just change the state, not queue up an update<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (we can't do the default React thing as we aren't mounted<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "properly", however we don't need to re-render as we only support<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setState in componentWillMount, which happens *before* render).<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.setState = newState =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof newState === 'function') {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// React's TS type definitions don't contain context as a third parameter for<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setState's updater function.<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Remove this cast to `any` when that is fixed.<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newState = (newState as any)(instance.state, instance.props, instance.context);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.state = Object.assign({}, instance.state, newState);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Comp.getDerivedStateFromProps) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const result = Comp.getDerivedStateFromProps(instance.props, instance.state);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result !== null) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.state = Object.assign({}, instance.state, result);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (instance.UNSAFE_componentWillMount) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.UNSAFE_componentWillMount();<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (instance.componentWillMount) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.componentWillMount();<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (providesChildContext(instance)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childContext = Object.assign({}, context, instance.getChildContext());<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (visitor(element, instance, context, childContext) === false) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child = instance.render();<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Just a stateless functional<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (visitor(element, null, context) === false) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child = Comp(props, context);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (child) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Array.isArray(child)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.forEach(item =&gt; walkTree(item, childContext, visitor));<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;walkTree(child, childContext, visitor);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;} else if ((element.type as any)._context || (element.type as any).Consumer) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A React context provider or consumer<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (visitor(element, null, context) === false) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let child;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((element.type as any)._context) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A provider - sets the context value before rendering children<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((element.type as any)._context as any)._currentValue = element.props.value;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child = element.props.children;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A consumer<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child = element.props.children((element.type as any)._currentValue);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (child) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Array.isArray(child)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.forEach(item =&gt; walkTree(item, context, visitor));<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;walkTree(child, context, visitor);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;} else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A basic string or dom element, just get children<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (visitor(element, null, context) === false) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (element.props &amp;&amp; element.props.children) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React.Children.forEach(element.props.children, (child: any) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (child) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;walkTree(child, context, visitor);<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;} else if (typeof element === 'string' || typeof element === 'number') {<br>
 &nbsp;&nbsp;&nbsp;// Just visit these, they are leaves so we don't keep traversing.<br>
 &nbsp;&nbsp;&nbsp;visitor(element, null, context);<br>
 &nbsp;}<br>
}<p></p>
<p>注水和脱水<span class=" fw-cl "><span>，</span></span>是同构应用最为核心和关键的细节点<span class=" fw-cl "><span>。</span></span></p>
<h3>请求认证处理</h3>
<p>上面讲到服务端预先请求数据<span class=" fw-cl "><span>，</span></span>那么思考这样的场景<span class=" fw-cl "><span>：</span></span>某个请求依赖 cookie 表明的用户信息<span class=" fw-cl "><span>，</span></span>比如请求<span class="fw-op  "><span>「</span></span>我的学习计划列表<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>这种情况下服务端请求是不同于客户端的<span class=" fw-cl "><span>，</span></span>不会有浏览器添加 cookie 以及不含有其他相关的 header 信息<span class=" fw-cl "><span>。</span></span>这个请求在服务端发送时<span class=" fw-cl "><span>，</span></span>一定不会拿到预期的结果<span class=" fw-cl "><span>。</span></span></p>
<p>为了解决这个问题<span class=" fw-cl "><span>，</span></span>我们来看看 React-apollo 的解决方法<span class=" fw-cl "><span>：</span></span></p>
<p><code>import { ApolloProvider } from 'react-apollo'<br>
import { ApolloClient } from 'apollo-client'<br>
import { createHttpLink } from 'apollo-link-http'<br>
import Express from 'express'<br>
import { StaticRouter } from 'react-router'<br>
import { InMemoryCache } from "apollo-cache-inmemory"<br>
<br>
import Layout from './routes/Layout'<br>
<br>
// Note you don't have to use any particular http server, but<br>
// we're using Express in this example<br>
const app = new Express();<br>
app.use((req, res) =&gt; {<br>
<br>
 &nbsp;const client = new ApolloClient({<br>
 &nbsp;&nbsp;&nbsp;ssrMode: true,<br>
 &nbsp;&nbsp;&nbsp;// Remember that this is the interface the SSR server will use to connect to the<br>
 &nbsp;&nbsp;&nbsp;// API server, so we need to ensure it isn't firewalled, etc<br>
 &nbsp;&nbsp;&nbsp;link: createHttpLink({<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uri: 'http://localhost:3010',<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;credentials: 'same-origin',<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers: {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cookie: req.header('Cookie'),<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
 &nbsp;&nbsp;&nbsp;}),<br>
 &nbsp;&nbsp;&nbsp;cache: new InMemoryCache(),<br>
 &nbsp;});<br>
<br>
 &nbsp;const context = {}<br>
<br>
 &nbsp;// The client-side App will instead use <browserrouter><br>
 &nbsp;const App = (<br>
 &nbsp;&nbsp;&nbsp;<apolloprovider client="{client}"><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<staticrouter location="{req.url}" context="{context}"><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<layout><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</layout></staticrouter><br>
 &nbsp;&nbsp;&nbsp;</apolloprovider><br>
 &nbsp;);<br>
<br>
 &nbsp;// rendering code (see below)<br>
})</browserrouter></code></p>
<p>这个做法也非常简单<span class=" fw-cl "><span>，</span></span>原理是<span class=" fw-cl "><span>：</span></span>服务端请求时需要保留客户端页面请求的信息<span class=" fw-cl "><span>，</span></span>并在 API 请求时携带并透传这个信息<span class=" fw-cl "><span>。</span></span>上述代码中<span class=" fw-cl "><span>，</span></span>createHttpLink 方法调用时<span class=" fw-cl "><span>：</span></span></p>
<p><code>headers: {<br>
 &nbsp;&nbsp;&nbsp;cookie: req.header('Cookie'),<br>
},</code></p>
<p>这个配置项就是关键<span class=" fw-cl "><span>，</span></span>它使得服务端的请求完整地还原了客户端信息<span class=" fw-cl "><span>，</span></span>因此验证类接口也不再会有问题<span class=" fw-cl "><span>。</span></span></p>
<p>事实上<span class=" fw-cl "><span>，</span></span>很多早期 React 完成服务端渲染的轮子都借鉴了 React-apollo 众多优秀思想<span class=" fw-cl "><span>，</span></span>对这个话题感兴趣的读者可以抽空去了解 React-apollo<span class=" fw-cl "><span>。</span></span></p>
<h3>样式问题处理</h3>
<p>同构应用的样式处理容易被开发者所忽视<span class=" fw-cl "><span>，</span></span>而一旦忽略<span class=" fw-cl "><span>，</span></span>就会掉到坑里<span class=" fw-cl "><span>。</span></span>比如<span class=" fw-cl "><span>，</span></span>正常的服务端渲染只是返回了 HTML 字符串<span class=" fw-cl "><span>，</span></span>样式需要浏览器加载完 CSS 后才会加上<span class=" fw-cl "><span>，</span></span>这个样式添加的过程就会造成页面的闪动<span class=" fw-cl "><span>。</span></span></p>
<p>再比如<span class=" fw-cl "><span>，</span></span>我们不能再使用 style-loader 了<span class=" fw-cl "><span>，</span></span>因为这个 webpack loader 会在编译时将样式模块载入到 HTML header 中<span class=" fw-cl "><span>。</span></span>但是在服务端渲染环境下<span class=" fw-cl "><span>，</span></span>没有 window 对象<span class=" fw-cl "><span>，</span></span>style-loader 进而会报错<span class=" fw-cl "><span>。</span></span>一般我们换用 isomorphic-style-loader 来实现<span class=" fw-cl "><span>：</span></span></p>
<p><code>{<br>
 &nbsp;&nbsp;&nbsp;test: /\.css$/,<br>
 &nbsp;&nbsp;&nbsp;use: [<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'isomorphic-style-loader',<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'css-loader',<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'postcss-loader'<br>
 &nbsp;&nbsp;&nbsp;],<br>
}</code></p>
<p>同时 isomorphic-style-loader 也会解决页面样式闪动的问题<span class=" fw-cl "><span>。</span></span>它的原理也不难理解<span class=" fw-cl "><span>：</span></span>在服务器端输出 html 字符串的同时<span class=" fw-cl "><span>，</span></span>也将样式插入到 html 字符串当中<span class=" fw-cl "><span>，</span></span>将结果一同传送到客户端<span class=" fw-cl "><span>。</span></span></p>
<p>isomorphic-style-loader 的原理是什么呢<span class=" fw-cl "><span>？</span></span></p>
<p>我们知道对于 webpack 来说<span class=" fw-cl "><span>，</span></span>所有的资源都是模块<span class=" fw-cl "><span>，</span></span>webpack loader 在编译过程中可以将导入的 CSS 文件转换成对象<span class=" fw-cl "><span>，</span></span>拿到样式信息<span class=" fw-cl "><span>。</span></span>因此 isomorphic-style-loader 可以获取页面中所有组件样式<span class=" fw-cl "><span>。</span></span>为了实现的更加通用化<span class=" fw-cl "><span>，</span></span>isomorphic-style-loader 利用 context API<span class=" fw-cl "><span>，</span></span>在渲染页面组件时获取所有 React 组件的样式信息<span class=" fw-cl "><span>，</span></span>最终插入到 HTML 字符串中<span class=" fw-cl "><span>。</span></span></p>
<p>在服务端渲染时<span class=" fw-cl "><span>，</span></span>我们需要加入这样的逻辑<span class=" fw-cl "><span>：</span></span></p>
<p><code>import express from 'express'<br>
import React from 'react'<br>
import ReactDOM from 'react-dom'<br>
import StyleContext from 'isomorphic-style-loader/StyleContext'<br>
import App from './App.js'<br>
<br>
const server = express()<br>
const port = process.env.PORT || 3000<br>
<br>
// Server-side rendering of the React app<br>
server.get('*', (req, res, next) =&gt; {<br>
<br>
 &nbsp;const css = new Set() // CSS for all rendered React components<br>
<br>
 &nbsp;const insertCss = (...styles) =&gt; styles.forEach(style =&gt; css.add(style._getCss()))<br>
<br>
 &nbsp;const body = ReactDOM.renderToString(<br>
 &nbsp;&nbsp;&nbsp;<stylecontext.provider value="{{" insertcss="" }}=""><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<app><br>
 &nbsp;&nbsp;&nbsp;</app></stylecontext.provider><br>
 &nbsp;)<br>
 &nbsp;const html = `<br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<script src="client.js" defer=""></script><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<style>${[...css].join('')}</style><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p><div id="root"><code>${body}</code></div><code><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;`<br>
 &nbsp;res.status(200).send(html)<br>
})<br>
<br>
server.listen(port, () =&gt; {<br>
 &nbsp;console.log(`Node.js app is running at http://localhost:${port}/`)<br>
})</code><p></p>
<p>我们定义了 css Set 类型来存储页面所有的样式<span class=" fw-cl "><span>，</span></span>并定义了 insertCss 方法<span class=" fw-cl "><span>，</span></span>该方法通过 context 传给每个 React 组件<span class=" fw-cl "><span>，</span></span>这样每个组件就可以调用 insertCss 方法<span class=" fw-cl "><span>。</span></span>该方法调用时<span class=" fw-cl "><span>，</span></span>会将组件样式加入到 css Set 当中<span class=" fw-cl "><span>。</span></span></p>
<p>最后我们用 [...css].join('') 就可以获取页面的所有样式字符串<span class=" fw-cl "><span>。</span></span></p>
<p>强调一下<span class=" fw-cl "><span>，</span></span>isomorphic-style-loader 的源码目前已经更新<span class=" fw-cl "><span>，</span></span>采用了最新的 React hooks API<span class=" fw-cl "><span>，</span></span>我推荐给 React 开发者阅读<span class=" fw-cl "><span>，</span></span>相信一定收获很多<span class=" fw-cl "><span>！</span></span></p>
<h3>meta tags 渲染</h3>
<p>React 应用中<span class=" fw-cl "><span>，</span></span>骨架往往类似<span class=" fw-cl "><span>：</span></span></p>
<p><code>const App = () =&gt; {<br>
 &nbsp;return (<br>
 &nbsp;&nbsp;&nbsp;</code></p><div><code><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<component1><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<component2><br>
 &nbsp;&nbsp;&nbsp;</component2></component1></code></div><code><br>
 &nbsp;)<br>
}<br>
ReactDom.render(<app>, document.querySelector('#root'))</app></code><p></p>
<p>App 组件嵌入到 document.querySelector('#root') 节点当中<span class=" fw-cl "><span>，</span></span>一般是不包含 head 标签的<span class=" fw-cl "><span>。</span></span>但是单页应用在切换路由时<span class=" fw-cl "><span>，</span></span>可能也会需要动态修改 head 标签信息<span class=" fw-cl "><span>，</span></span>比如 title 内容<span class=" fw-cl "><span>。</span></span>也就是说<span class=" fw-cl "><span>：</span></span>在单页面应用切换页面<span class=" fw-cl "><span>，</span></span>不会经过服务端渲染<span class=" fw-cl "><span>，</span></span>但是我们仍然需要更改 document 的 title 内容<span class=" fw-cl "><span>。</span></span></p>
<p>那么服务端如何渲染 meta tags head 标签就是一个常被忽略但是至关重要的话题<span class=" fw-cl "><span>，</span></span>我们往往使用 React-helmet 库来解决问题<span class=" fw-cl "><span>。</span></span></p>
<p>Home 组件<span class=" fw-cl "><span>：</span></span></p>
<p><code>import Helmet from "react-helmet";<br>
<br>
</code></p><div><code><br>
 &nbsp;&nbsp;&nbsp;<helmet><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<title>Home page</title><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<meta name="description" content="Home page description"><br>
 &nbsp;&nbsp;&nbsp;</helmet><br>
 &nbsp;&nbsp;&nbsp;<h1>Home component</h1></code><p></p>
<p>Users 组件<span class=" fw-cl "><span>：</span></span></p>
<p><code><helmet><br>
 &nbsp;&nbsp;&nbsp;<title>Users page</title><br>
 &nbsp;&nbsp;&nbsp;<meta name="description" content="Users page description"><br>
</helmet></code></p>
<p>React-helmet 这个库会在 Home 组件和 Users 组件渲染时<span class=" fw-cl "><span>，</span></span>检测到 Helmet<span class=" fw-cl "><span>，</span></span>并自动执行副作用逻辑<span class=" fw-cl "><span>。</span></span></p>
<h3>404 处理</h3>
<p>当服务端渲染时<span class=" fw-cl "><span>，</span></span>我们还需要留心对 404 的情况进行处理<span class=" fw-cl "><span>，</span></span>有 layout.js 文件如下<span class=" fw-cl "><span>：</span></span></p>
<p><code><switch><br>
 &nbsp;&nbsp;&nbsp;<route path="/" exact="" component="{Home}"><br>
 &nbsp;&nbsp;&nbsp;<route path="/users" exact="" component="{Users}"><br>
</route></route></switch></code></p>
<p>当访问<span class=" fw-cl "><span>：</span></span><code>/home</code> 时<span class=" fw-cl "><span>，</span></span>会得到一个空白页面<span class=" fw-cl "><span>，</span></span>浏览器也没有得到 404 的状态码<span class=" fw-cl "><span>。</span></span>为了处理这种情况<span class=" fw-cl "><span>，</span></span>我们加入<span class=" fw-cl "><span>：</span></span></p>
<p><code><switch><br>
 &nbsp;&nbsp;&nbsp;<route path="/" exact="" component="{Home}"><br>
 &nbsp;&nbsp;&nbsp;<route path="/users" exact="" component="{Users}"><br>
 &nbsp;&nbsp;&nbsp;<route component="{NotFound}"><br>
</route></route></route></switch></code></p>
<p>并创建 NotFound.js 文件<span class=" fw-cl "><span>：</span></span></p>
<p><code>import React from 'react'<br>
<br>
export default function NotFound({ staticContext }) {<br>
 &nbsp;&nbsp;&nbsp;if (staticContext) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staticContext.notFound = true<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return (<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p><div><code>Not found</code></div><code><br>
 &nbsp;&nbsp;&nbsp;)<br>
}</code><p></p>
<p>注意<span class=" fw-cl "><span>，</span></span>在访问一个不存在的地址时<span class=" fw-cl "><span>，</span></span>我们要返回 404 状态码<span class=" fw-cl "><span>。</span></span>一般 React router 类库已经帮我们进行了较好的封装<span class=" fw-cl "><span>，</span></span>Static Router 会注入一个 context prop<span class=" fw-cl "><span>，</span></span>并将 context.notFound 赋值为 true<span class=" fw-cl "><span>，</span></span>在 server/index.js 加入<span class=" fw-cl "><span>：</span></span></p>
<p><code>const context = {}<br>
const html = renderer(data, req.path, context);<br>
if (context.notFound) {<br>
 &nbsp;&nbsp;&nbsp;res.status(404)<br>
}<br>
res.send(html)</code></p>
<p>即可<span class=" fw-cl "><span>。</span></span>这一系列处理过程没有什么难点<span class=" fw-cl "><span>，</span></span>但是这种处理意识<span class=" fw-cl "><span>，</span></span>还是需要具备的<span class=" fw-cl "><span>。</span></span></p>
<h3>安全问题</h3>
<p>安全问题非常关键<span class=" fw-cl "><span>，</span></span>尤其是涉及到服务端渲染<span class=" fw-cl "><span>，</span></span>开发者要格外小心<span class=" fw-cl "><span>。</span></span>这里提出一个点<span class=" fw-cl "><span>：</span></span>我们前面提到了注水和脱水过程<span class=" fw-cl "><span>，</span></span>其中的代码<span class=" fw-cl "><span>：</span></span></p>
<p><code>ctx.body = `<br>
 &nbsp;<br>
 &nbsp;<br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<meta charset="UTF-8"><br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<script><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.context = {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialState: ${JSON.stringify(store.getState())}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</script><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></p><div id="app"><code><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></div><code><br>
 &nbsp;&nbsp;&nbsp;<br>
 &nbsp;<br>
`</code><p></p>
<p>非常容易遭受 XSS 攻击<span class=" fw-cl "><span>，</span></span>JSON.stringify 可能会造成 script 注入<span class=" fw-cl "><span>。</span></span>因此<span class=" fw-cl "><span>，</span></span>我们需要严格清洗 JSON 字符串中的 HTML 标签和其他危险的字符<span class=" fw-cl "><span>。</span></span>我习惯使用 serialize-javascript 库进行处理<span class=" fw-cl "><span>，</span></span>这也是同构应用中最容易被忽视的细节<span class=" fw-cl "><span>。</span></span></p>
<p>这里给大家留一个思考题<span class=" fw-cl "><span>，</span></span>React dangerouslySetInnerHTML API 也有类似风险<span class=" fw-cl "><span>，</span></span>React 是怎么处理这个安全隐患的呢<span class=" fw-cl "><span>？</span></span></p>
<h3>性能优化</h3>
<p>我们将数据请求移到了服务端<span class=" fw-cl "><span>，</span></span>但是依然要格外重视性能优化<span class=" fw-cl "><span>。</span></span>目前针对于此<span class=" fw-cl "><span>，</span></span>业界普遍做法包括以下几点<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">使用缓存<span class=" fw-cl "><span>：</span></span>服务端优化一个最重要的手段就是缓存<span class=" fw-cl "><span>，</span></span>不同于传统服务端缓存措施<span class=" fw-cl "><span>，</span></span>我们甚至可以实现组件级缓存<span class=" fw-cl "><span>，</span></span>业界 walmartlabs 在这方面的实践非常多<span class=" fw-cl "><span>，</span></span>且收获了较大的性能提升<span class=" fw-cl "><span>。</span></span>感兴趣的读者可以找到相关技术信息<span class=" fw-cl "><span>。</span></span></li>
  <li style="">采用 HSF 代替 HTTP<span class=" fw-cl "><span>，</span></span>HSF 是 High-Speed Service Framework 的缩写<span class=" fw-cl "><span>，</span></span>译为分布式的远程服务调用框架<span class=" fw-cl "><span>，</span></span>对外提供服务上<span class=" fw-cl "><span>，</span></span>HSF 性能远超过 HTTP<span class=" fw-cl "><span>。</span></span></li>
  <li style="">对于服务端压力过大的场景<span class=" fw-cl "><span>，</span></span>动态切换为客户端渲染<span class=" fw-cl "><span>。</span></span></li>
  <li style="">NodeJS 升级<span class=" fw-cl "><span>。</span></span></li>
  <li style="">React 升级<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>如图所示<span class=" fw-cl "><span>，</span></span>React 16 在服务端渲染上的性能对比提升<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-93ef7dcef817c7a36e1a22b84a874905.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:30.843749999999996% 0" data-src="https://pic3.zhimg.com/v2-93ef7dcef817c7a36e1a22b84a874905.png">加载中...</span></figure>
<blockquote><br></blockquote>
<p>备注<span class=" fw-cl "><span>：</span></span>图片来自 <a href="https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67" title="hacker noon">hacker noon</a></p>
<h3>总结</h3>
<p>本讲没有<span class="fw-op  "><span>「</span></span>手把手<span class=" fw-cl "><span>」</span></span>教你实现服务端渲染的同构应用<span class=" fw-cl "><span>，</span></span>因为这些知识并不困难<span class=" fw-cl "><span>，</span></span>社区上资料也很多<span class=" fw-cl "><span>。</span></span>我们从更高的角度出发<span class=" fw-cl "><span>，</span></span>剖析同构应用中那些关键的细节点和疑难问题的解决方案<span class=" fw-cl "><span>，</span></span>这些经验来源于真刀真枪的线上案例<span class=" fw-cl "><span>，</span></span>如果读者没有开发过同构应用<span class=" fw-cl "><span>，</span></span>也能从中全方位地了解关键信息<span class=" fw-cl "><span>，</span></span>一旦掌握了这些细节<span class=" fw-cl "><span>，</span></span>同构应用的实现就会更稳<span class=" fw-cl "><span>、</span></span>更可靠<span class=" fw-cl "><span>。</span></span></p>
<p>同构应用其实远比理论复杂<span class=" fw-cl "><span>，</span></span>绝对不是几个 APIs 和几台服务器就能完成的<span class=" fw-cl "><span>，</span></span>希望大家多思考<span class=" fw-cl "><span>、</span></span>多动手<span class=" fw-cl "><span>，</span></span>一定会更有体会<span class=" fw-cl "><span>。</span></span></p>
<p>另外<span class=" fw-cl "><span>，</span></span>同构应用各种细节也不止于此<span class=" fw-cl "><span>，</span></span>坑也不止于此<span class=" fw-cl "><span>，</span></span>欢迎大家和我讨论<span class=" fw-cl "><span>。</span></span></p>
<h3>分享交流</h3>
<p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论<span class=" fw-cl "><span>，</span></span>或者直接向作者 LucasHC 提问<span class="fw-op  "><span>（</span></span>作者看到后抽空回复<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span><strong style="">你的分享不仅帮助他人<span class=" fw-cl "><span>，</span></span>更会提升自己<span class=" fw-cl "><span>。</span></span></strong></p>
<p>你也可以说说自己最想了解的主题<span class=" fw-cl "><span>，</span></span>课程内容会根据部分读者的意见和建议迭代和完善<span class=" fw-cl "><span>。</span></span></p>
<p>此外<span class=" fw-cl "><span>，</span></span>我们为本课程付费读者创建了<span class="fw-op  "><span>《</span></span>前端开发核心知识进阶<span class=" fw-cl "><span>》</span></span>微信交流群<span class=" fw-cl "><span>，</span></span>以方便更有针对性地讨论课程相关问题<span class="fw-op  "><span>（</span></span>入群请到第 1-2 课末尾添加 GitChat 小助手伽利略的微信<span class=" fw-cl "><span>，</span></span>并注明<span class="fw-op  "><span>「</span></span>前端核心<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>谢谢~<span class=" fw-cl "><span>）</span></span></p><p><span style="display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);">备案号:YXX1p6PmGY5tXLQyEwI5olY</span></p></div><div class="ReleaseTime-text-qmY7m">编辑于 2020-05-22 14:04 · 禁止转载</div><div id="webNextSection" class="NextSection-root-eXc5Z NextSection-nextSectionRoot-n1tWE"><div class="NextSection-tip-kkFPi"><span>点击查看下一节</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" size="16"><path fill-rule="evenodd" d="M12.071 20.485L5 13.415 6.414 12l5.657 5.657L17.728 12l1.414 1.414-7.07 7.071zm0-7L5 6.415 6.414 5l5.657 5.657L17.728 5l1.414 1.414-7.07 7.071z"></path></svg></div><div class="NextSection-title-3m2Wv">从框架和类库，我们该学到什么</div></div><div id="bottomToolBar" class="BottomAction-pc-b9za1"><div class="ToolBar-root-t9xdb ToolBar-fixedRoot-nGA5J"><div class="ToolBar-wrapper-eckjm"><style data-emotion-css="6sb417">.css-6sb417{overflow:hidden;position:relative;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:36px;border-radius:18px;}</style><div class="css-6sb417" style="background-color:rgba(0, 102, 255, 0.08)"><style data-emotion-css="1q2f8kt">.css-1q2f8kt{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.css-1q2f8kt:active{opacity:0.5 !important;}</style><style data-emotion-css="12r0ul1">.css-12r0ul1{box-sizing:border-box;margin:0;min-width:0;background-color:transparent;overflow:hidden;height:36px;font-weight:600;font-size:12px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.css-12r0ul1:active{opacity:0.5 !important;}</style><div style="width:95px;opacity:1" class="css-12r0ul1"><style data-emotion-css="v0jgcu">.css-v0jgcu{position:absolute;top:0;left:0;}</style><style data-emotion-css="cy329x">.css-cy329x{box-sizing:border-box;margin:0;min-width:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;overflow:hidden;width:100%;height:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;position:absolute;top:0;left:0;}</style><div style="color:#0066FF;width:95px" class="css-cy329x"><style data-emotion-css="o5uqvq">.css-o5uqvq{margin-left:5px;}</style><style data-emotion-css="18biwo">.css-18biwo{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><span class="css-18biwo">​<style data-emotion-css="d519u3 animation-d2btug">.css-d519u3{fill:currentColor;-webkit-animation:animation-d2btug 1s steps(12) infinite;animation:animation-d2btug 1s steps(12) infinite;}@-webkit-keyframes animation-d2btug{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}@keyframes animation-d2btug{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}</style><svg viewBox="0 0 35 35" width="15" height="15" class="css-d519u3"><g fill-rule="evenodd"><path d="M17.5 9c-.825 0-1.5-.675-1.5-1.5v-6c0-.825.675-1.5 1.5-1.5S19 .675 19 1.5v6c0 .825-.675 1.5-1.5 1.5" opacity=".65"></path><path d="M21.75 10.139a1.504 1.504 0 0 1-.549-2.05l3-5.195a1.504 1.504 0 0 1 2.049-.55c.715.413.962 1.335.549 2.05l-3 5.196a1.504 1.504 0 0 1-2.049.549" opacity=".75"></path><path d="M24.861 13.25a1.504 1.504 0 0 1 .55-2.049l5.195-3a1.504 1.504 0 0 1 2.05.549 1.504 1.504 0 0 1-.55 2.049l-5.196 3a1.504 1.504 0 0 1-2.049-.549" opacity=".85"></path><path d="M26 17.5c0-.825.675-1.5 1.5-1.5h6c.825 0 1.5.675 1.5 1.5s-.675 1.5-1.5 1.5h-6c-.825 0-1.5-.675-1.5-1.5" opacity=".9"></path><path d="M24.861 21.75a1.504 1.504 0 0 1 2.05-.549l5.195 3c.715.412.962 1.334.55 2.049a1.504 1.504 0 0 1-2.05.549l-5.196-3a1.504 1.504 0 0 1-.549-2.049" opacity=".2"></path><path d="M21.75 24.861a1.504 1.504 0 0 1 2.049.55l3 5.195a1.504 1.504 0 0 1-.549 2.05 1.504 1.504 0 0 1-2.049-.55l-3-5.196a1.504 1.504 0 0 1 .549-2.049" opacity=".25"></path><path d="M17.5 26c.825 0 1.5.675 1.5 1.5v6c0 .825-.675 1.5-1.5 1.5s-1.5-.675-1.5-1.5v-6c0-.825.675-1.5 1.5-1.5" opacity=".3"></path><path d="M13.25 24.861c.714.413.961 1.335.549 2.05l-3 5.195a1.504 1.504 0 0 1-2.049.55 1.504 1.504 0 0 1-.549-2.05l3-5.196a1.504 1.504 0 0 1 2.049-.549" opacity=".35"></path><path d="M10.139 21.75a1.504 1.504 0 0 1-.55 2.049l-5.195 3a1.504 1.504 0 0 1-2.05-.549 1.504 1.504 0 0 1 .55-2.049l5.196-3a1.504 1.504 0 0 1 2.049.549" opacity=".4"></path><path d="M9 17.5c0 .825-.675 1.5-1.5 1.5h-6C.675 19 0 18.325 0 17.5S.675 16 1.5 16h6c.825 0 1.5.675 1.5 1.5" opacity=".45"></path><path d="M10.139 13.25a1.504 1.504 0 0 1-2.05.549l-5.195-3a1.504 1.504 0 0 1-.55-2.049 1.504 1.504 0 0 1 2.05-.549l5.196 3c.714.412.961 1.335.549 2.049" opacity=".5"></path><path d="M13.25 10.139a1.504 1.504 0 0 1-2.049-.55l-3-5.195a1.504 1.504 0 0 1 .549-2.05 1.504 1.504 0 0 1 2.049.55l3 5.196a1.504 1.504 0 0 1-.549 2.049" opacity=".55"></path></g></svg></span></div></div><style data-emotion-css="3nc1uv">.css-3nc1uv{background:#175199;height:18px;width:1px;opacity:0.2;}</style><div class="css-3nc1uv"></div><div style="width:44px;opacity:1" class="css-12r0ul1"><div style="color:#0066FF;width:44px" class="css-cy329x"><style data-emotion-css="1cfk3tj">.css-1cfk3tj{width:14px;height:14px;margin-right:6px;}</style><span style="display:inline-flex;align-items:center">​<svg width="24" height="24" viewBox="0 0 24 24" data-new-api="OpposeFill24" data-old-api="OpposeFill24" style="margin-right:0" class="ZDI ZDI--OpposeFill24 css-1cfk3tj" fill="currentColor"><path d="M13.792 20.319c-.781 1.406-2.803 1.406-3.584 0L2.418 6.296c-.76-1.367.228-3.046 1.791-3.046h15.582c1.563 0 2.55 1.68 1.791 3.046l-7.79 14.023z" fill-rule="evenodd" clip-rule="evenodd"></path></svg></span><style data-emotion-css="ke5ir5">.css-ke5ir5{box-sizing:border-box;margin:0;min-width:0;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="css-ke5ir5"></div></div></div></div><div class="ToolbarButton-root-7QcPF"><div class="ToolbarButton-iconWrap-s7rbk"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 25 25" fill="currentColor" class="ToolbarButton-icon-nRSYF"><path d="M11.75 5h9a.75.75 0 1 1 0 1.5h-9a.75.75 0 1 1 0-1.5zm0 4.5h9a.75.75 0 1 1 0 1.5h-9a.75.75 0 1 1 0-1.5zm0 4.5h9a.75.75 0 1 1 0 1.5h-9a.75.75 0 1 1 0-1.5zm0 4.5h9a.75.75 0 1 1 0 1.5h-9a.75.75 0 1 1 0-1.5zm-3.009-6.409a.467.467 0 0 1 0 .818l-4.585 2.543A.779.779 0 0 1 3 14.77v-4.542a.779.779 0 0 1 1.156-.68l4.585 2.542z"></path></svg></div><div class="ToolbarButton-subtitle-2wKZ3"><span>目录</span></div></div><div class="ToolbarButton-root-7QcPF"><div class="ToolbarButton-iconWrap-s7rbk"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 25 25" fill="currentColor" class="ToolbarButton-icon-nRSYF ToolbarButton-comment-fzEmc"><path fill="none" d="M19.533 16.288a2.49 2.49 0 0 1 .031-1.416c.381-1.188.568-2.162.568-2.931a7.69 7.69 0 1 0-7.691 7.69c.77 0 1.743-.186 2.932-.567.459-.147.95-.158 1.415-.031l2.534.69a.735.735 0 0 0 .902-.902l-.69-2.533z"></path></svg></div><div class="ToolbarButton-subtitle-2wKZ3"><span> 评论</span></div></div><div class="ToolbarButton-root-7QcPF"><div class="ToolbarButton-iconWrap-s7rbk"><svg width="25" height="25" viewBox="0 0 25 25" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="ToolbarButton-icon-nRSYF ToolbarButton-share-jNH34"><path clip-rule="evenodd" d="M10 4.25A.25.25 0 009.75 4H5.5A1.5 1.5 0 004 5.5v13A1.5 1.5 0 005.5 20h13a1.5 1.5 0 001.5-1.5v-4.25a.25.25 0 00-.25-.25h-1a.25.25 0 00-.25.25V18a.5.5 0 01-.5.5H6a.5.5 0 01-.5-.5V6a.5.5 0 01.5-.5h3.75a.25.25 0 00.25-.25v-1zM20 5.5A1.5 1.5 0 0018.5 4h-5.25a.25.25 0 00-.25.25v1c0 .138.112.25.25.25h4.188l-7.198 7.198a.25.25 0 000 .354l.707.707a.25.25 0 00.354 0l7.199-7.2v4.191c0 .138.112.25.25.25h1a.25.25 0 00.25-.25V5.5z"></path></svg></div><div class="ToolbarButton-subtitle-2wKZ3"><span>分享</span></div></div></div></div></div><div class="Directory-root-qqPG5 Directory-pc-r64pV"><div class="Directory-shadow-oic6H" style="display:none;opacity:0"></div><div class="Directory-directory-7uwE7" style="opacity:0;transition:transform 0.3s;transform:translateX(-100%)"><div class="Directory-header-n9Ykz"><div class="Directory-headerContent-6M8GX"><div class="Image-module-imageWrapper-fVufG Directory-artwork-a5vV3" src="https://pic1.zhimg.com/v2-928c5e9d7027db41982aa8353002150d.png?source=f65c3faf" theme="light" ua="[object Object]"><div style="width:60px;padding-top:133.33333333333331%"></div><img class="Image-module-image-uorig" width="60" height="80" src="https://pic1.zhimg.com/50/v2-928c5e9d7027db41982aa8353002150d_200x0.png" srcset="https://pic1.zhimg.com/50/v2-928c5e9d7027db41982aa8353002150d_200x0.png 2x, https://pic1.zhimg.com/50/v2-928c5e9d7027db41982aa8353002150d_200x0.png 3x"></div><div><div class="Directory-title-bZgWt">前端开发核心知识进阶：50 讲从夯实基础到突破瓶颈</div><div>Lucas HC</div></div></div><svg width="24" height="24" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" fill="currentColor" size="24"><path stroke="#D3D3D3" stroke-width="4" d="M20 14l10.026 10.008-9.992 9.89" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></svg></div><div class="Directory-content-9QeZD"></div></div></div>
    <script nonce="RCPkuAllkBS9uzhvwraMO">window.zhihuNativeApp&&window.zhihuNativeApp.sendToNative&&window.zhihuNativeApp.sendToNative(JSON.stringify({module: 'market',action: 'FCPEnd',params: {}}))</script>
    <textarea id="resolved" hidden="">{"name":"manuscript","status":200,"titleHTML":{},"metaHTML":{},"webPageReadyScript":"\u003cscript nonce=\"RCPkuAllkBS9uzhvwraMO\"&gt;window.zhihuNativeApp&amp;&amp;window.zhihuNativeApp.sendToNative&amp;&amp;window.zhihuNativeApp.sendToNative(JSON.stringify({module: 'market',action: 'FCPEnd',params: {}}))\u003c/script&gt;","viteScript":"","appContext":{"request":{"ip":"27.38.69.251","xRealIp":"27.38.69.251","headers":{"host":"www.zhihu.com","x-udid":"AMBXA2viIRaPTiayW2XDwwutZFH9WpsgzQE="},"url":"/market/paid_column/1167078439772721152/section/1169971710572367872","href":"https://www.zhihu.com/market/paid_column/1167078439772721152/section/1169971710572367872","path":"/market/paid_column/1167078439772721152/section/1169971710572367872","params":{"0":"section","productType":"paid_column","productId":"1167078439772721152","manuscriptId":"1169971710572367872"},"query":{}},"deviceID":"","ua":{"Mobile":false,"Android":false,"Chrome":false,"iOS":false,"Wechat":false,"WorkWechat":false,"WechatMiniprogram":false,"Weibo":false,"QQ":false,"Zhihu":false,"ZhihuHybrid":false,"iPad":false,"UC":false,"QQBrowser":false,"BankABC":false,"BankABCNew":false,"AliPay":false},"theme":"light","isOffice":false,"xAppZa":"","xAppVersion":"","xApiVersion":"","xNetworkType":"","xUDId":"AMBXA2viIRaPTiayW2XDwwutZFH9WpsgzQE=","xZst81":"","authId":"3e3ca09c9310955765cf24d9860888a6","zaeEnvType":"","commentCloseFlag":"0","globalSlienceMode":"","supportsWebp":false,"apiBaseDict":{"api-default":"https://api.zhihu.com","api-v4":"https://www.zhihu.com/api/v4","api-walletpay":"https://walletpay.zhihu.com"},"safeAreaInset":{},"vipPrivilegesUrl":"https://www.zhihu.com/xen/market/vip-privileges","nonce":"RCPkuAllkBS9uzhvwraMO","ssrStage":"render","__connectedAutoFetch":{"manuscript":{"pending":false,"data":{"manuscriptData":{"recommend_title":"","index":{"relative":22,"serial_number_txt":"第 22 节"},"chapter_index":{"serial_number_txt":"第 0 章","show_chapter_name":false},"is_curriculum":false,"time_info":{"created_at":1571722992,"updated_at":1590127470},"paid_column":{"id":"1167078439772721152","sku_id":"1167078439994777600","title":"前端开发核心知识进阶：50 讲从夯实基础到突破瓶颈","authors":[{"bio":"知乎「前端开发」话题优秀回答者，《React 状态管理与同构实战》作者。","is_section_authors":false,"name":"Lucas HC","headline":"Carpe diem","avatar_url":"https://picx.zhimg.com/6c3e4f09100f35d70c4f7ab86b0a68c1.jpg?source=f65c3faf","url":"https://www.zhihu.com/people/f04b762a72416dbaf4b9656055d723c6","member_hash":"f04b762a72416dbaf4b9656055d723c6","url_token":"lucas-hc","user_type":"people","is_following":false,"badge":[{"type":"best_answerer"}]}],"update_finished":true,"artwork":"https://pic1.zhimg.com/v2-928c5e9d7027db41982aa8353002150d.png?source=f65c3faf","tab_artwork":"https://pic1.zhimg.com/v2-39fa776732e5fc8636f771d2d5599cfb.png?source=f65c3faf","section_count":51,"updated_section_count":51,"has_interested":true},"id":"1169971710572367872","title":"同构应用中你所忽略的细节","manuscript":"\u003cp&gt;不管是服务端渲染还是服务端渲染衍生出的同构应用\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;现在来看已经并不新鲜了\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;实现起来也并不困难\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;可是有的开发者认为\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;同构应用不就是调用一个 renderToString\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;（\u003c/span&gt;\u003c/span&gt;React 中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;）\u003c/span&gt;\u003c/span&gt;类似的 API 吗\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;？\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;讲道理确实是这样的\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;但是讲道理你也许并没有真正在实战中领会同构应用的精髓\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;同构应用能够完成的本质条件是虚拟 DOM\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;基于虚拟 DOM 我们可以生成真实的 DOM\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并由浏览器渲染\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;；\u003c/span&gt;\u003c/span&gt;也可以调用不同框架的不同 APIs\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;将虚拟 DOM 生成字符串\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;由服务端传输给客户端\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;但是同构应用也不只是这么简单\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;拿面试来说\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;同构应用的考察点不是\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;「\u003c/span&gt;\u003c/span&gt;纸上谈兵\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;」\u003c/span&gt;\u003c/span&gt;的理论\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;而是实际实施时的细节\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;这一讲我们就来聊一聊\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;「\u003c/span&gt;\u003c/span&gt;同构应用中往往被忽略的细节\u003cspan class=\" fw-cl fw--collapsed\"&gt;\u003cspan&gt;」\u003c/span&gt;\u003c/span&gt;\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;需要读者提前了解服务端渲染和同构应用的概念\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;相关知识点如下\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003cbr&gt;\u003c/p&gt;\n\u003cfigure class=\"central\"&gt;\u003cimg src=\"https://pic2.zhimg.com/v2-25910174b3cb3d895c86405207c91401.png\" alt=\"图片\" data-rawwidth=\"461\" data-rawheight=\"536\"&gt;\u003c/figure&gt;\n\u003ch3&gt;打包环境区分\u003c/h3&gt;\n\u003cp&gt;第一个细节\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;我们知道同构应用实现了客户端代码和服务端代码的基本统一\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们只需要编写一种组件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;就能生成适用于服务端和客户端的组件案例\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;可是你是否知道\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;服务端代码和客户端代码大多数情况下还是需要单独处理\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;？\u003c/span&gt;\u003c/span&gt;比如\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cul&gt;\n  \u003cli style=\"\"&gt;路由代码差别\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;服务端需要根据请求路径\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;匹配页面组件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;；\u003c/span&gt;\u003c/span&gt;客户端需要通过浏览器中的地址\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;匹配页面组件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/li&gt;\n\u003c/ul&gt;\n\u003cp&gt;客户端代码\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;const App = () =&gt; {\u003cbr&gt;\n &amp;nbsp;return (\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cProvider store={store}&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cBrowserRouter&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cdiv&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cRoute path='/' component={Home}&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cRoute path='/product' component={Product}&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/div&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/BrowserRouter&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/Provider&gt;\u003cbr&gt;\n &amp;nbsp;)\u003cbr&gt;\n}\u003cbr&gt;\nReactDom.render(\u003cApp/&gt;, document.querySelector('#root'))\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;BrowserRouter 组件根据 window.location 以及 history API 实现页面切换\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;而服务端肯定是无法获取 window.location 的\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;服务端代码如下\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;const App = () =&gt; {\u003cbr&gt;\n &amp;nbsp;return \u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cProvider store={store}&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cStaticRouter location={req.path} context={context}&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cdiv&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cRoute path='/' component={Home}&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/div&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/StaticRouter&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/Provider&gt;\u003cbr&gt;\n}\u003cbr&gt;\nReturn ReactDom.renderToString(\u003cApp/&gt;)\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;需要使用 StaticRouter 组件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并将请求地址和上下文信息作为 location 和 context 这两个 props 传入 StaticRouter 中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cul&gt;\n  \u003cli style=\"\"&gt;\u003cbr&gt;\u003c/li&gt;\n\u003c/ul&gt;\n\u003cp&gt;打包差别\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;服务端运行的代码如果需要依赖 Node 核心模块或者第三方模块\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;就不再需要把这些模块代码打包到最终代码中了\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;因为环境已经安装这些依赖\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;可以直接引用\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;这样一来\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;就需要我们在 webpack 中配置\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;target\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;node\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并借助 webpack-node-externals 插件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;解决第三方依赖打包的问题\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cul&gt;\n  \u003cli style=\"\"&gt;\u003cbr&gt;\u003c/li&gt;\n\u003c/ul&gt;\n\u003cp&gt;对于图片等静态资源\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;url-loader 会在服务端代码和客户端代码打包过程中分别被引用\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;因此会在资源目录中生成了重复的文件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;当然后打包出来的因为重名\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;会覆盖前一次打包出来的结果\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并不影响使用\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;但是整个构建过程并不优雅\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cul&gt;\n  \u003cli style=\"\"&gt;\u003cbr&gt;\u003c/li&gt;\n\u003c/ul&gt;\n\u003cp&gt;由于路由在服务端和客户端的差别\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;因此 webpack 配置文件的 entry 会不相同\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;{\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;entry: './src/client/index.js',\u003cbr&gt;\n}\u003cbr&gt;\n\u003cbr&gt;\n{\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;entry: './src/server/index.js',\u003cbr&gt;\n}\u003c/code&gt;\u003c/p&gt;\n\u003ch3&gt;注水和脱水\u003c/h3&gt;\n\u003cp&gt;什么叫做注水和脱水呢\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;？\u003c/span&gt;\u003c/span&gt;这个和同构应用中数据的获取有关\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;在服务器端渲染时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;首先服务端请求接口拿到数据\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并处理准备好数据状态\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;（\u003c/span&gt;\u003c/span&gt;如果使用 Redux\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;就是进行 store 的更新\u003cspan class=\" fw-cl fw--collapsed\"&gt;\u003cspan&gt;）\u003c/span&gt;\u003c/span&gt;\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;为了减少客户端的请求\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们需要保留住这个状态\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;一般做法是在服务器端返回 HTML 字符串的时候\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;将数据 JSON.stringify 一并返回\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;这个过程\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;叫做脱水\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;（\u003c/span&gt;\u003c/span&gt;dehydrate\u003cspan class=\" fw-cl fw--collapsed\"&gt;\u003cspan&gt;）\u003c/span&gt;\u003c/span&gt;\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;；\u003c/span&gt;\u003c/span&gt;在客户端\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;就不再需要进行数据的请求了\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;可以直接使用服务端下发下来的数据\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;这个过程叫注水\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;（\u003c/span&gt;\u003c/span&gt;hydrate\u003cspan class=\" fw-cl fw--collapsed\"&gt;\u003cspan&gt;）\u003c/span&gt;\u003c/span&gt;\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;用代码来表示\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;服务端\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;ctx.body = `\u003cbr&gt;\n &amp;nbsp;\u003c!DOCTYPE html&gt;\u003cbr&gt;\n &amp;nbsp;\u003chtml lang=\"en\"&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003chead&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cmeta charset=\"UTF-8\"&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/head&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cbody&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cscript&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;window.context = {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initialState: ${JSON.stringify(store.getState())}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/script&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cdiv id=\"app\"&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// ...\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/div&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/body&gt;\u003cbr&gt;\n &amp;nbsp;\u003c/html&gt;\u003cbr&gt;\n`\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;客户端\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;export const getClientStore = () =&gt; {\u003cbr&gt;\n &amp;nbsp;const defaultState = JSON.parse(window.context.state)\u003cbr&gt;\n &amp;nbsp;return createStore(reducer, defaultState, applyMiddleware(thunk))\u003cbr&gt;\n}\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;这一系列过程非常典型\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;但是也会有几个细节值得探讨\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003cstrong style=\"\"&gt;在服务端渲染时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;服务端如何能够请求所有的 APIs\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;保障数据全部已经请求呢\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;？\u003c/span&gt;\u003c/span&gt;\u003c/strong&gt;\u003c/p&gt;\n\u003cp&gt;一般有两种方法\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cul&gt;\n  \u003cli style=\"\"&gt;react-router 的解决方案是配置路由 route-config\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;结合 matchRoutes\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;找到页面上相关组件所需的请求接口的方法并执行请求\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;这就要求开发者通过路由配置信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;显式地告知服务端请求内容\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/li&gt;\n\u003c/ul&gt;\n\u003cp&gt;我们首先配置路由\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;const routes = [\u003cbr&gt;\n &amp;nbsp;{\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;path: \"/\",\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;component: Root,\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;loadData: () =&gt; getSomeData()\u003cbr&gt;\n &amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;// etc.\u003cbr&gt;\n]\u003cbr&gt;\n\u003cbr&gt;\nimport { routes } from \"./routes\"\u003cbr&gt;\n\u003cbr&gt;\nfunction App() {\u003cbr&gt;\n &amp;nbsp;return (\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cSwitch&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{routes.map(route =&gt; (\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cRoute {...route} /&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;))}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/Switch&gt;\u003cbr&gt;\n &amp;nbsp;)\u003cbr&gt;\n}\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;在服务端代码中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;import { matchPath } from \"react-router-dom\"\u003cbr&gt;\n\u003cbr&gt;\nconst promises = []\u003cbr&gt;\nroutes.some(route =&gt; {\u003cbr&gt;\n &amp;nbsp;const match = matchPath(req.path, route)\u003cbr&gt;\n &amp;nbsp;if (match) promises.push(route.loadData(match))\u003cbr&gt;\n &amp;nbsp;return match\u003cbr&gt;\n})\u003cbr&gt;\n\u003cbr&gt;\nPromise.all(promises).then(data =&gt; {\u003cbr&gt;\n &amp;nbsp;putTheDataSomewhereTheClientCanFindIt(data)\u003cbr&gt;\n})\u003c/code&gt;\u003c/p&gt;\n\u003cul&gt;\n  \u003cli style=\"\"&gt;另外一种思路类似 Next.js\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们需要在 React 组件上定义静态方法\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt; 比如定义静态 loadData 方法\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;在服务端渲染时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们可以遍历所有组件的 loadData\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;获取需要请求的接口\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;这样的方式借鉴了早期 React-apollo 的解决方案\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我个人很喜欢这种设计\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;这里贴出我为 Facebook 团队 react-apollo 开源项目贡献的改动代码\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;其目的就是遍历组件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;获取请求接口\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/li&gt;\n\u003c/ul&gt;\n\u003cp&gt;\u003ccode&gt;function getPromisesFromTree({\u003cbr&gt;\n &amp;nbsp;rootElement,\u003cbr&gt;\n &amp;nbsp;rootContext = {},\u003cbr&gt;\n}: PromiseTreeArgument): PromiseTreeResult[] {\u003cbr&gt;\n &amp;nbsp;const promises: PromiseTreeResult[] = [];\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;walkTree(rootElement, rootContext, (_, instance, context, childContext) =&gt; {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;if (instance &amp;&amp; hasFetchDataFunction(instance)) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const promise = instance.fetchData();\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (isPromise\u003cObject&gt;(promise)) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;promises.push({ promise, context: childContext || context, instance });\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;});\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;return promises;\u003cbr&gt;\n}\u003cbr&gt;\n\u003cbr&gt;\n// Recurse a React Element tree, running visitor on each element.\u003cbr&gt;\n// If visitor returns `false`, don't call the element's render function\u003cbr&gt;\n// or recurse into its child elements.\u003cbr&gt;\nexport function walkTree(\u003cbr&gt;\n &amp;nbsp;element: React.ReactNode,\u003cbr&gt;\n &amp;nbsp;context: Context,\u003cbr&gt;\n &amp;nbsp;visitor: (\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;element: React.ReactNode,\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;instance: React.Component\u003cany&gt; | null,\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;context: Context,\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;childContext?: Context,\u003cbr&gt;\n &amp;nbsp;) =&gt; boolean | void,\u003cbr&gt;\n) {\u003cbr&gt;\n &amp;nbsp;if (Array.isArray(element)) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;element.forEach(item =&gt; walkTree(item, context, visitor));\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;return;\u003cbr&gt;\n &amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;if (!element) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;return;\u003cbr&gt;\n &amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;// A stateless functional component or a class\u003cbr&gt;\n &amp;nbsp;if (isReactElement(element)) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;if (typeof element.type === 'function') {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const Comp = element.type;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const props = Object.assign({}, Comp.defaultProps, getProps(element));\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;let childContext = context;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;let child;\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Are we are a react class?\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (isComponentClass(Comp)) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const instance = new Comp(props, context);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// In case the user doesn't pass these to super in the constructor.\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Note: `Component.props` are now readonly in `@types/react`, so\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// we're using `defineProperty` as a workaround (for now).\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object.defineProperty(instance, 'props', {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;value: instance.props || props,\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;instance.context = instance.context || context;\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Set the instance state to null (not undefined) if not set, to match React behaviour\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;instance.state = instance.state || null;\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Override setState to just change the state, not queue up an update\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// (we can't do the default React thing as we aren't mounted\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// \"properly\", however we don't need to re-render as we only support\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// setState in componentWillMount, which happens *before* render).\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;instance.setState = newState =&gt; {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (typeof newState === 'function') {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// React's TS type definitions don't contain context as a third parameter for\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// setState's updater function.\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Remove this cast to `any` when that is fixed.\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newState = (newState as any)(instance.state, instance.props, instance.context);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;instance.state = Object.assign({}, instance.state, newState);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (Comp.getDerivedStateFromProps) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const result = Comp.getDerivedStateFromProps(instance.props, instance.state);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (result !== null) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;instance.state = Object.assign({}, instance.state, result);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else if (instance.UNSAFE_componentWillMount) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;instance.UNSAFE_componentWillMount();\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else if (instance.componentWillMount) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;instance.componentWillMount();\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (providesChildContext(instance)) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;childContext = Object.assign({}, context, instance.getChildContext());\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (visitor(element, instance, context, childContext) === false) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;child = instance.render();\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Just a stateless functional\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (visitor(element, null, context) === false) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;child = Comp(props, context);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (child) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (Array.isArray(child)) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;child.forEach(item =&gt; walkTree(item, childContext, visitor));\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;walkTree(child, childContext, visitor);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;} else if ((element.type as any)._context || (element.type as any).Consumer) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// A React context provider or consumer\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (visitor(element, null, context) === false) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;let child;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((element.type as any)._context) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// A provider - sets the context value before rendering children\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;((element.type as any)._context as any)._currentValue = element.props.value;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;child = element.props.children;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// A consumer\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;child = element.props.children((element.type as any)._currentValue);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (child) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (Array.isArray(child)) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;child.forEach(item =&gt; walkTree(item, context, visitor));\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;walkTree(child, context, visitor);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;} else {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// A basic string or dom element, just get children\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (visitor(element, null, context) === false) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (element.props &amp;&amp; element.props.children) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;React.Children.forEach(element.props.children, (child: any) =&gt; {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (child) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;walkTree(child, context, visitor);\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;} else if (typeof element === 'string' || typeof element === 'number') {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;// Just visit these, they are leaves so we don't keep traversing.\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;visitor(element, null, context);\u003cbr&gt;\n &amp;nbsp;}\u003cbr&gt;\n}\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;注水和脱水\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;是同构应用最为核心和关键的细节点\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003ch3&gt;请求认证处理\u003c/h3&gt;\n\u003cp&gt;上面讲到服务端预先请求数据\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;那么思考这样的场景\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;某个请求依赖 cookie 表明的用户信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;比如请求\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;「\u003c/span&gt;\u003c/span&gt;我的学习计划列表\u003cspan class=\" fw-cl fw--collapsed\"&gt;\u003cspan&gt;」\u003c/span&gt;\u003c/span&gt;\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;这种情况下服务端请求是不同于客户端的\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;不会有浏览器添加 cookie 以及不含有其他相关的 header 信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;这个请求在服务端发送时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;一定不会拿到预期的结果\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;为了解决这个问题\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们来看看 React-apollo 的解决方法\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;import { ApolloProvider } from 'react-apollo'\u003cbr&gt;\nimport { ApolloClient } from 'apollo-client'\u003cbr&gt;\nimport { createHttpLink } from 'apollo-link-http'\u003cbr&gt;\nimport Express from 'express'\u003cbr&gt;\nimport { StaticRouter } from 'react-router'\u003cbr&gt;\nimport { InMemoryCache } from \"apollo-cache-inmemory\"\u003cbr&gt;\n\u003cbr&gt;\nimport Layout from './routes/Layout'\u003cbr&gt;\n\u003cbr&gt;\n// Note you don't have to use any particular http server, but\u003cbr&gt;\n// we're using Express in this example\u003cbr&gt;\nconst app = new Express();\u003cbr&gt;\napp.use((req, res) =&gt; {\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;const client = new ApolloClient({\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;ssrMode: true,\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;// Remember that this is the interface the SSR server will use to connect to the\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;// API server, so we need to ensure it isn't firewalled, etc\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;link: createHttpLink({\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;uri: 'http://localhost:3010',\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;credentials: 'same-origin',\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;headers: {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cookie: req.header('Cookie'),\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;}),\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;cache: new InMemoryCache(),\u003cbr&gt;\n &amp;nbsp;});\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;const context = {}\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;// The client-side App will instead use \u003cBrowserRouter&gt;\u003cbr&gt;\n &amp;nbsp;const App = (\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cApolloProvider client={client}&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cStaticRouter location={req.url} context={context}&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cLayout /&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/StaticRouter&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/ApolloProvider&gt;\u003cbr&gt;\n &amp;nbsp;);\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;// rendering code (see below)\u003cbr&gt;\n})\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;这个做法也非常简单\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;原理是\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;服务端请求时需要保留客户端页面请求的信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并在 API 请求时携带并透传这个信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;上述代码中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;createHttpLink 方法调用时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;headers: {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;cookie: req.header('Cookie'),\u003cbr&gt;\n},\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;这个配置项就是关键\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;它使得服务端的请求完整地还原了客户端信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;因此验证类接口也不再会有问题\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;事实上\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;很多早期 React 完成服务端渲染的轮子都借鉴了 React-apollo 众多优秀思想\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;对这个话题感兴趣的读者可以抽空去了解 React-apollo\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003ch3&gt;样式问题处理\u003c/h3&gt;\n\u003cp&gt;同构应用的样式处理容易被开发者所忽视\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;而一旦忽略\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;就会掉到坑里\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;比如\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;正常的服务端渲染只是返回了 HTML 字符串\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;样式需要浏览器加载完 CSS 后才会加上\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;这个样式添加的过程就会造成页面的闪动\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;再比如\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们不能再使用 style-loader 了\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;因为这个 webpack loader 会在编译时将样式模块载入到 HTML header 中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;但是在服务端渲染环境下\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;没有 window 对象\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;style-loader 进而会报错\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;一般我们换用 isomorphic-style-loader 来实现\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;{\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;test: /\\.css$/,\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;use: [\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'isomorphic-style-loader',\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'css-loader',\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'postcss-loader'\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;],\u003cbr&gt;\n}\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;同时 isomorphic-style-loader 也会解决页面样式闪动的问题\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;它的原理也不难理解\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;在服务器端输出 html 字符串的同时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;也将样式插入到 html 字符串当中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;将结果一同传送到客户端\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;isomorphic-style-loader 的原理是什么呢\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;？\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;我们知道对于 webpack 来说\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;所有的资源都是模块\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;webpack loader 在编译过程中可以将导入的 CSS 文件转换成对象\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;拿到样式信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;因此 isomorphic-style-loader 可以获取页面中所有组件样式\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;为了实现的更加通用化\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;isomorphic-style-loader 利用 context API\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;在渲染页面组件时获取所有 React 组件的样式信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;最终插入到 HTML 字符串中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;在服务端渲染时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们需要加入这样的逻辑\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;import express from 'express'\u003cbr&gt;\nimport React from 'react'\u003cbr&gt;\nimport ReactDOM from 'react-dom'\u003cbr&gt;\nimport StyleContext from 'isomorphic-style-loader/StyleContext'\u003cbr&gt;\nimport App from './App.js'\u003cbr&gt;\n\u003cbr&gt;\nconst server = express()\u003cbr&gt;\nconst port = process.env.PORT || 3000\u003cbr&gt;\n\u003cbr&gt;\n// Server-side rendering of the React app\u003cbr&gt;\nserver.get('*', (req, res, next) =&gt; {\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;const css = new Set() // CSS for all rendered React components\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;const insertCss = (...styles) =&gt; styles.forEach(style =&gt; css.add(style._getCss()))\u003cbr&gt;\n\u003cbr&gt;\n &amp;nbsp;const body = ReactDOM.renderToString(\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cStyleContext.Provider value={{ insertCss }}&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cApp /&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/StyleContext.Provider&gt;\u003cbr&gt;\n &amp;nbsp;)\u003cbr&gt;\n &amp;nbsp;const html = `\u003c!doctype html&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003chtml&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003chead&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cscript src=\"client.js\" defer&gt;\u003c/script&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cstyle&gt;${[...css].join('')}\u003c/style&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/head&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cbody&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cdiv id=\"root\"&gt;${body}\u003c/div&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/body&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/html&gt;`\u003cbr&gt;\n &amp;nbsp;res.status(200).send(html)\u003cbr&gt;\n})\u003cbr&gt;\n\u003cbr&gt;\nserver.listen(port, () =&gt; {\u003cbr&gt;\n &amp;nbsp;console.log(`Node.js app is running at http://localhost:${port}/`)\u003cbr&gt;\n})\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;我们定义了 css Set 类型来存储页面所有的样式\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并定义了 insertCss 方法\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;该方法通过 context 传给每个 React 组件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;这样每个组件就可以调用 insertCss 方法\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;该方法调用时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;会将组件样式加入到 css Set 当中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;最后我们用 [...css].join('') 就可以获取页面的所有样式字符串\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;强调一下\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;isomorphic-style-loader 的源码目前已经更新\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;采用了最新的 React hooks API\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我推荐给 React 开发者阅读\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;相信一定收获很多\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;！\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003ch3&gt;meta tags 渲染\u003c/h3&gt;\n\u003cp&gt;React 应用中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;骨架往往类似\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;const App = () =&gt; {\u003cbr&gt;\n &amp;nbsp;return (\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cdiv&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cComponent1 /&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cComponent2 /&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/div&gt;\u003cbr&gt;\n &amp;nbsp;)\u003cbr&gt;\n}\u003cbr&gt;\nReactDom.render(\u003cApp/&gt;, document.querySelector('#root'))\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;App 组件嵌入到 document.querySelector('#root') 节点当中\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;一般是不包含 head 标签的\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;但是单页应用在切换路由时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;可能也会需要动态修改 head 标签信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;比如 title 内容\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;也就是说\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;在单页面应用切换页面\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;不会经过服务端渲染\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;但是我们仍然需要更改 document 的 title 内容\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;那么服务端如何渲染 meta tags head 标签就是一个常被忽略但是至关重要的话题\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们往往使用 React-helmet 库来解决问题\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;Home 组件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;import Helmet from \"react-helmet\";\u003cbr&gt;\n\u003cbr&gt;\n\u003cdiv&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cHelmet&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003ctitle&gt;Home page\u003c/title&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cmeta name=\"description\" content=\"Home page description\" /&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/Helmet&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003ch1&gt;Home component\u003c/h1&gt;\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;Users 组件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;\u003cHelmet&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003ctitle&gt;Users page\u003c/title&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cmeta name=\"description\" content=\"Users page description\" /&gt;\u003cbr&gt;\n\u003c/Helmet&gt;\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;React-helmet 这个库会在 Home 组件和 Users 组件渲染时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;检测到 Helmet\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并自动执行副作用逻辑\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003ch3&gt;404 处理\u003c/h3&gt;\n\u003cp&gt;当服务端渲染时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们还需要留心对 404 的情况进行处理\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;有 layout.js 文件如下\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;\u003cSwitch&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cRoute path=\"/\" exact component={Home} /&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cRoute path=\"/users\" exact component={Users} /&gt;\u003cbr&gt;\n\u003c/Switch&gt;\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;当访问\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003ccode&gt;/home\u003c/code&gt; 时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;会得到一个空白页面\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;浏览器也没有得到 404 的状态码\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;为了处理这种情况\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们加入\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;\u003cSwitch&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cRoute path=\"/\" exact component={Home} /&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cRoute path=\"/users\" exact component={Users} /&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cRoute component={NotFound} /&gt;\u003cbr&gt;\n\u003c/Switch&gt;\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;并创建 NotFound.js 文件\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;import React from 'react'\u003cbr&gt;\n\u003cbr&gt;\nexport default function NotFound({ staticContext }) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;if (staticContext) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;staticContext.notFound = true\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;return (\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cdiv&gt;Not found\u003c/div&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;)\u003cbr&gt;\n}\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;注意\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;在访问一个不存在的地址时\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们要返回 404 状态码\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;一般 React router 类库已经帮我们进行了较好的封装\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;Static Router 会注入一个 context prop\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并将 context.notFound 赋值为 true\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;在 server/index.js 加入\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;const context = {}\u003cbr&gt;\nconst html = renderer(data, req.path, context);\u003cbr&gt;\nif (context.notFound) {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;res.status(404)\u003cbr&gt;\n}\u003cbr&gt;\nres.send(html)\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;即可\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;这一系列处理过程没有什么难点\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;但是这种处理意识\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;还是需要具备的\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003ch3&gt;安全问题\u003c/h3&gt;\n\u003cp&gt;安全问题非常关键\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;尤其是涉及到服务端渲染\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;开发者要格外小心\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;这里提出一个点\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;我们前面提到了注水和脱水过程\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;其中的代码\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003ccode&gt;ctx.body = `\u003cbr&gt;\n &amp;nbsp;\u003c!DOCTYPE html&gt;\u003cbr&gt;\n &amp;nbsp;\u003chtml lang=\"en\"&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003chead&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cmeta charset=\"UTF-8\"&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/head&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cbody&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cscript&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;window.context = {\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;initialState: ${JSON.stringify(store.getState())}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/script&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003cdiv id=\"app\"&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// ...\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/div&gt;\u003cbr&gt;\n &amp;nbsp;&amp;nbsp;&amp;nbsp;\u003c/body&gt;\u003cbr&gt;\n &amp;nbsp;\u003c/html&gt;\u003cbr&gt;\n`\u003c/code&gt;\u003c/p&gt;\n\u003cp&gt;非常容易遭受 XSS 攻击\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;JSON.stringify 可能会造成 script 注入\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;因此\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们需要严格清洗 JSON 字符串中的 HTML 标签和其他危险的字符\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;我习惯使用 serialize-javascript 库进行处理\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;这也是同构应用中最容易被忽视的细节\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;这里给大家留一个思考题\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;React dangerouslySetInnerHTML API 也有类似风险\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;React 是怎么处理这个安全隐患的呢\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;？\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003ch3&gt;性能优化\u003c/h3&gt;\n\u003cp&gt;我们将数据请求移到了服务端\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;但是依然要格外重视性能优化\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;目前针对于此\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;业界普遍做法包括以下几点\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cul&gt;\n  \u003cli style=\"\"&gt;使用缓存\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;服务端优化一个最重要的手段就是缓存\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;不同于传统服务端缓存措施\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们甚至可以实现组件级缓存\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;业界 walmartlabs 在这方面的实践非常多\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;且收获了较大的性能提升\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;感兴趣的读者可以找到相关技术信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/li&gt;\n  \u003cli style=\"\"&gt;采用 HSF 代替 HTTP\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;HSF 是 High-Speed Service Framework 的缩写\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;译为分布式的远程服务调用框架\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;对外提供服务上\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;HSF 性能远超过 HTTP\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/li&gt;\n  \u003cli style=\"\"&gt;对于服务端压力过大的场景\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;动态切换为客户端渲染\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/li&gt;\n  \u003cli style=\"\"&gt;NodeJS 升级\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/li&gt;\n  \u003cli style=\"\"&gt;React 升级\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/li&gt;\n\u003c/ul&gt;\n\u003cp&gt;如图所示\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;React 16 在服务端渲染上的性能对比提升\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;\u003cbr&gt;\u003c/p&gt;\n\u003cfigure class=\"central\"&gt;\u003cimg src=\"https://pic3.zhimg.com/v2-93ef7dcef817c7a36e1a22b84a874905.png\" alt=\"图片\" data-rawwidth=\"1600\" data-rawheight=\"987\"&gt;\u003c/figure&gt;\n\u003cblockquote&gt;\u003cbr&gt;\u003c/blockquote&gt;\n\u003cp&gt;备注\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;：\u003c/span&gt;\u003c/span&gt;图片来自 \u003ca href=\"https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67\" title=\"hacker noon\"&gt;hacker noon\u003c/a&gt;\u003c/p&gt;\n\u003ch3&gt;总结\u003c/h3&gt;\n\u003cp&gt;本讲没有\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;「\u003c/span&gt;\u003c/span&gt;手把手\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;」\u003c/span&gt;\u003c/span&gt;教你实现服务端渲染的同构应用\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;因为这些知识并不困难\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;社区上资料也很多\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;我们从更高的角度出发\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;剖析同构应用中那些关键的细节点和疑难问题的解决方案\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;这些经验来源于真刀真枪的线上案例\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;如果读者没有开发过同构应用\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;也能从中全方位地了解关键信息\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;一旦掌握了这些细节\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;同构应用的实现就会更稳\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;、\u003c/span&gt;\u003c/span&gt;更可靠\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;同构应用其实远比理论复杂\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;绝对不是几个 APIs 和几台服务器就能完成的\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;希望大家多思考\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;、\u003c/span&gt;\u003c/span&gt;多动手\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;一定会更有体会\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;另外\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;同构应用各种细节也不止于此\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;坑也不止于此\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;欢迎大家和我讨论\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003ch3&gt;分享交流\u003c/h3&gt;\n\u003cp&gt;阅读文章过程中有任何疑问可随时跟其他小伙伴讨论\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;或者直接向作者 LucasHC 提问\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;（\u003c/span&gt;\u003c/span&gt;作者看到后抽空回复\u003cspan class=\" fw-cl fw--collapsed\"&gt;\u003cspan&gt;）\u003c/span&gt;\u003c/span&gt;\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003cstrong style=\"\"&gt;你的分享不仅帮助他人\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;更会提升自己\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/strong&gt;\u003c/p&gt;\n\u003cp&gt;你也可以说说自己最想了解的主题\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;课程内容会根据部分读者的意见和建议迭代和完善\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;。\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\n\u003cp&gt;此外\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;我们为本课程付费读者创建了\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;《\u003c/span&gt;\u003c/span&gt;前端开发核心知识进阶\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;》\u003c/span&gt;\u003c/span&gt;微信交流群\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;以方便更有针对性地讨论课程相关问题\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;（\u003c/span&gt;\u003c/span&gt;入群请到第 1-2 课末尾添加 GitChat 小助手伽利略的微信\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;并注明\u003cspan class=\"fw-op  \"&gt;\u003cspan&gt;「\u003c/span&gt;\u003c/span&gt;前端核心\u003cspan class=\" fw-cl fw--collapsed\"&gt;\u003cspan&gt;」\u003c/span&gt;\u003c/span&gt;\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;，\u003c/span&gt;\u003c/span&gt;谢谢~\u003cspan class=\" fw-cl \"&gt;\u003cspan&gt;）\u003c/span&gt;\u003c/span&gt;\u003c/p&gt;\u003cp&gt;\u003cspan style=\"display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);\"&gt;备案号:YXX1p6PmGY5tXLQyEwI5olY\u003c/span&gt;\u003c/p&gt;","audio":null,"is_fold":false,"has_like":false,"has_oppose":false,"like_count":2,"comment_count":0,"share":{"title":"同构应用中你所忽略的细节","description":"同构应用中你所忽略的细节","artwork":"https://picx.zhimg.com/v2-25910174b3cb3d895c86405207c91401.png?source=f65c3faf","url":"https://www.zhihu.com/market/paid_column/1167078439772721152/section/1169971710572367872?is_share_data=true"},"next_section":{"id":"1169972844762206208","title":"从框架和类库，我们该学到什么","url":"https://www.zhihu.com/market/paid_column/1167078439772721152/section/1169972844762206208","is_end":false},"head_artwork":null,"learn_progress":{"progress":0,"is_finished":false},"section_type":"article","sku_right_type":"svip_free","truncate_text":"最低 0.3 元/天开通会员，查看完整内容","svip_right_card":{"day":"https://pic3.zhimg.com/v2-4ed2fd42766dbac1ba5cffa1d7a01638.png","night":"https://pic4.zhimg.com/v2-1b83a176355a5370778dc7c5c14b9c62.png"},"related_labels":[],"main_character":"","on_shelves":true,"section_on_shelves":true,"right":{"ownership":true,"purchased":false,"anonymous":false},"pTagList":[]},"moreInformationData":{"share_records":[{"section_id":1563866763892338700,"title":"有没有虐文催泪的那种?","url":"https://www.zhihu.com/market/paid_column/1480182785314394112/section/1563866763892338689?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"结婚第五年纪念日 ， 许嘉年说要给我一个盛大的婚礼 。\n\n他说他特别遗憾当年结婚时没有给我一场婚礼 ， 他说我一定是最美的新娘 。\n\n然后婚礼当天 ， 他收到一条短信 ， 匆匆忙忙地跑了 。\n\n我穿着","artwork":"","is_read":false},{"section_id":1368261744087957500,"title":"有哪些根据真实犯罪故事改编的电影？","url":"https://www.zhihu.com/market/paid_column/1365688702828765184/section/1368261744087957504?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"1\n\n2008 年 4 月 29 日 ， 香港新界北失踪人口调查组接到了一件看似很普通的报案 。\n\n失踪的是个 16 岁的少女 ， 前来报案的是她的母亲和 19 岁的姐姐 。 母女俩焦急地告诉警员 ，","artwork":"","is_read":false},{"section_id":1556645118949412900,"title":"有没有青梅竹马追妻火葬场的小说?","url":"https://www.zhihu.com/market/paid_column/1489624547859505152/section/1556645118949412864?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"穿书十年 ， 我用了七年攻略男二反派大魔头无果 。\n\n他的心中只有纯白如月光的女主 。\n\n于是我用了三年和他道别 ， 从此在心中彻底放下他 。\n\n可是他却好像再也不能放下了 。\n\n1.\n\n「 云荣受伤","artwork":"","is_read":false},{"section_id":1540708067771072500,"title":"在自己家公司上班是什么感觉？","url":"https://www.zhihu.com/market/paid_column/1533512394957021184/section/1540708067771072512?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"跟男朋友进了同一家公司实习 。\n\n同部门的学姐一直暗示他分手 ， 说我没钱没靠山 ， 会耽误他的前途 。\n\n我 ： ？\n\n公司都是我爸的 。\n\n明天我就让他继承皇位 。\n\n1\n\n男朋友第八次被学姐叫去","artwork":"","is_read":false},{"section_id":1578072225504264200,"title":"姐妹们见过最心狠手辣的女主是谁？（最近想看点刺激的）？","url":"https://www.zhihu.com/market/paid_column/1470907509230239744/section/1578072225504264192?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"1\n\n赵小婵出生的时候 ， 家里也是富过的 。\n\n她爹赵明义是个二世祖 ， 对于女儿的出生 ， 既不高兴 ， 也不难过 。\n\n闺女出生那天 ， 烈日当头 ， 外面的蝉鸣声吵得烦死个人 。\n\n赵明义也没","artwork":"","is_read":false},{"section_id":1396516846212792300,"title":"什么样的女人才是聪明女人？","url":"https://www.zhihu.com/market/paid_column/1386393729327116288/section/1396516846212792320?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"我和我老公在一起 ， 不是因为他有多优秀 ， 而是因为他对我好 。\n\n我以为我会一直被宠下去 。\n\n结果一个月前 ， 一个陌生人的微信加我 ， 给我发了张照片 。\n\n照片里的男人 ， 切着一个金黄色的","artwork":"","is_read":false},{"section_id":1553715330438140000,"title":"是什么样的鬼故事吓了你十几年？","url":"https://www.zhihu.com/market/paid_column/1487743293379670017/section/1553715330438139905?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"妹妹的尸体 ， 是在家里的抽屉里被发现的 。\n\n她整个身体被压缩成一个肉块 ， 塞在了抽屉里 。\n\n但她却留下了一个线索 ：\n\n小心家里多出来的那个妈妈 。\n\n01\n\n妹妹离家后的第三天 。\n\n家里的","artwork":"","is_read":false},{"section_id":1588190659995029500,"title":"有什么大快人心的复仇故事？","url":"https://www.zhihu.com/market/paid_column/1584194746330796032/section/1588190659995029504?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"我向上天许愿 ， 我想变成女生 ， 变成霸凌我的那个人的理想型女生 。\n\n让他爱上我 ， 为我痴狂 ， 为我疯魔 。\n\n这样 ， 我就能轻易毁掉他光明灿烂的人生了 。\n\n1\n\n小时候我很喜欢看 《 哆","artwork":"","is_read":false},{"section_id":1431756526964490200,"title":"国考和省考公务员薪资待遇真的有天壤之别吗？","url":"https://www.zhihu.com/market/paid_column/1424430624366698499/section/1431756526964490240?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"国考与省考有什么区别 ？ 怎么报名 、 什么时候报名 ？ 如何选择岗位才能提高上岸率 ？ 本文都将一一为你解答 。\n\n*一 、 个人背景介绍*\n\n上岸年龄 ： 32 岁 。\n\n上岸成绩 ： 行测 78","artwork":"","is_read":false},{"section_id":1571909212002889700,"title":"有哪些好看的女主爽文？","url":"https://www.zhihu.com/market/paid_column/1569379904310890497/section/1571909212002889728?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"幼弟受封世子的第二天 ， 夺了我的掌家权 ， 还把我许给了一个痴肥的傻子 。\n\n他说我本就是过继来的农家女 ， 从血到肉都下贱无比 ， 根本不配做他长姐 。 只有二房嫡女才是侯府真正的小姐 ， 他真正","artwork":"","is_read":false},{"section_id":1551216533984260000,"title":"有没有女主人间清醒的小说？","url":"https://www.zhihu.com/market/paid_column/1545060110682230784/section/1551216533984260096?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"陆子宸在酒吧泡妞 ， 叫我去付钱 。\n\n三年来 ， 我陆陆续续在他身上花了 1000 万 。\n\n他给我没买过一杯奶茶 。\n\n他觉得我是他的舔狗 ， 这辈子想让我怎样 ， 我就会怎样 。\n\n直到我听到脑","artwork":"","is_read":false},{"section_id":1583882091246370800,"title":"你有哪些绝妙的反击？","url":"https://www.zhihu.com/market/paid_column/1581708871797743616/section/1583882091246370816?marketing_token=null&amp;member_code=Q44ZYN&amp;is_share_data=true&amp;vp_share_title=0","description":"我是恶毒女配 ， 但我摆烂了 。\n\n因为只要我努力 ， 女主就能获得美颜加成 。\n\n嘿 ， 那我专心开摆 ， 女主面目可憎指日可待 。\n\n1\n\n我偶然发现 ：\n\n只要我熬夜苦干 ， 柳依依就光彩焕发 ","artwork":"","is_read":false}],"next_page_url":"/slytherin/task/member_recommand?page=0&amp;limit=12&amp;token=null&amp;section_id=0"},"annotationsData":{}},"error":null}},"self":{"type":"people","user_type":"people","id":"3e3ca09c9310955765cf24d9860888a6","url":"https://api.zhihu.com/people/3e3ca09c9310955765cf24d9860888a6","name":"会飞的鱼","url_token":"49952","headline":"混迹职场，希望一生如鱼得水！","avatar_url":"https://pic1.zhimg.com/v2-396f760fc224757bdaf0bf39178fdf7e_l.jpg?source=8c5c7284","gender":1,"actived":1670464665,"subscriptions":[{"id":"4","real_id":"4","appellation":"尊敬的盐选会员","name":"svip","real_name":"svip","has_checked_in":false,"title":"盐选会员","checked_in_days":0,"is_active":true,"rank":null,"alert":"盐选会员剩余 28 天到期","show_recharge_notic":true,"contract_id":null,"checked_in_url":"https://www.zhihu.com/remix/instabooks","expires_at":1676044799,"available_at":1673345684,"is_expired":false,"package_list":[]}],"is_new":false,"member_rights":[{"status":"active","alert":"盐选会员 2023.02.10 到期","expire_at":1676044799,"available_at":1673345684,"type":"svip","icon":{"day":"https://picx.zhimg.com/v2-034fefe15c83232cb448718998719d34.png?source=8c5c7284","night":"https://picx.zhimg.com/v2-c9686ff064ea3579730756ac6c289978.png?source=8c5c7284"},"real_type":"svip"}],"has_speaker_admin_permission":false,"is_following_mp_wechat":false,"is_bind_phone":true,"is_unicom_free":false,"from":"go","button_bubble":""},"readSetting":{},"isKocPage":false,"isShareAbConfig":false}}</textarea>

    
  

</any></object></code></p>
</body>
</html>