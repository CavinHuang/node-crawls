不管是服务端渲染还是服务端渲染衍生出的同构应用，现在来看已经并不新鲜了，实现起来也并不困难。可是有的开发者认为：同构应用不就是调用一个 renderToString（React 中）类似的 API 吗？

讲道理确实是这样的，但是讲道理你也许并没有真正在实战中领会同构应用的精髓。

同构应用能够完成的本质条件是虚拟 DOM，基于虚拟 DOM 我们可以生成真实的 DOM，并由浏览器渲染；也可以调用不同框架的不同 APIs，将虚拟 DOM 生成字符串，由服务端传输给客户端。

但是同构应用也不只是这么简单。拿面试来说，同构应用的考察点不是「纸上谈兵」的理论，而是实际实施时的细节。这一讲我们就来聊一聊「同构应用中往往被忽略的细节」，需要读者提前了解服务端渲染和同构应用的概念。

相关知识点如下：

  

加载中...

### 打包环境区分

第一个细节：我们知道同构应用实现了客户端代码和服务端代码的基本统一，我们只需要编写一种组件，就能生成适用于服务端和客户端的组件案例。可是你是否知道，服务端代码和客户端代码大多数情况下还是需要单独处理？比如：

- 路由代码差别：服务端需要根据请求路径，匹配页面组件；客户端需要通过浏览器中的地址，匹配页面组件。

客户端代码：

`const App = () => {  
 return (  
     
       
       `

`  
       
     
 )  
}  
ReactDom.render(, document.querySelector('#root'))`

BrowserRouter 组件根据 window.location 以及 history API 实现页面切换，而服务端肯定是无法获取 window.location 的，服务端代码如下：

`const App = () => {  
 return  
     
       
       `

`  
       
     
}  
Return ReactDom.renderToString()`

需要使用 StaticRouter 组件，并将请求地址和上下文信息作为 location 和 context 这两个 props 传入 StaticRouter 中。

-   

打包差别：服务端运行的代码如果需要依赖 Node 核心模块或者第三方模块，就不再需要把这些模块代码打包到最终代码中了。因为环境已经安装这些依赖，可以直接引用。这样一来，就需要我们在 webpack 中配置：target：node，并借助 webpack-node-externals 插件，解决第三方依赖打包的问题。

-   

对于图片等静态资源，url-loader 会在服务端代码和客户端代码打包过程中分别被引用，因此会在资源目录中生成了重复的文件。当然后打包出来的因为重名，会覆盖前一次打包出来的结果，并不影响使用，但是整个构建过程并不优雅。

-   

由于路由在服务端和客户端的差别，因此 webpack 配置文件的 entry 会不相同：

`{  
   entry: './src/client/index.js',  
}  
  
{  
   entry: './src/server/index.js',  
}`

### 注水和脱水

什么叫做注水和脱水呢？这个和同构应用中数据的获取有关：在服务器端渲染时，首先服务端请求接口拿到数据，并处理准备好数据状态（如果使用 Redux，就是进行 store 的更新），为了减少客户端的请求，我们需要保留住这个状态。一般做法是在服务器端返回 HTML 字符串的时候，将数据 JSON.stringify 一并返回，这个过程，叫做脱水（dehydrate）；在客户端，就不再需要进行数据的请求了，可以直接使用服务端下发下来的数据，这个过程叫注水（hydrate）。用代码来表示：

服务端：

``ctx.body = `  
   
   
     
       
     
     
       <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.context = {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialState: ${JSON.stringify(store.getState())}<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  
     ``

`  
         // ...  
     `

``  
     
   
` ``

客户端：

`export const getClientStore = () => {  
 const defaultState = JSON.parse(window.context.state)  
 return createStore(reducer, defaultState, applyMiddleware(thunk))  
}`

这一系列过程非常典型，但是也会有几个细节值得探讨：**在服务端渲染时，服务端如何能够请求所有的 APIs，保障数据全部已经请求呢？**

一般有两种方法：

- react-router 的解决方案是配置路由 route-config，结合 matchRoutes，找到页面上相关组件所需的请求接口的方法并执行请求。这就要求开发者通过路由配置信息，显式地告知服务端请求内容。

我们首先配置路由：

`const routes = [  
 {  
   path: "/",  
   component: Root,  
   loadData: () => getSomeData()  
 }  
 // etc.  
]  
  
import { routes } from "./routes"  
  
function App() {  
 return (  
     
     {routes.map(route => (  
         
     ))}  
     
 )  
}`

在服务端代码中：

`import { matchPath } from "react-router-dom"  
  
const promises = []  
routes.some(route => {  
 const match = matchPath(req.path, route)  
 if (match) promises.push(route.loadData(match))  
 return match  
})  
  
Promise.all(promises).then(data => {  
 putTheDataSomewhereTheClientCanFindIt(data)  
})`

- 另外一种思路类似 Next.js，我们需要在 React 组件上定义静态方法。 比如定义静态 loadData 方法，在服务端渲染时，我们可以遍历所有组件的 loadData，获取需要请求的接口。这样的方式借鉴了早期 React-apollo 的解决方案，我个人很喜欢这种设计。这里贴出我为 Facebook 团队 react-apollo 开源项目贡献的改动代码，其目的就是遍历组件，获取请求接口：

```function getPromisesFromTree({  
 rootElement,  
 rootContext = {},  
}: PromiseTreeArgument): PromiseTreeResult[] {  
 const promises: PromiseTreeResult[] = [];  
  
 walkTree(rootElement, rootContext, (_, instance, context, childContext) => {  
   if (instance && hasFetchDataFunction(instance)) {  
     const promise = instance.fetchData();  
     if (isPromise(promise)) {  
       promises.push({ promise, context: childContext || context, instance });  
       return false;  
     }  
   }  
 });  
  
 return promises;  
}  
  
// Recurse a React Element tree, running visitor on each element.  
// If visitor returns `false`, don't call the element's render function  
// or recurse into its child elements.  
export function walkTree(  
 element: React.ReactNode,  
 context: Context,  
 visitor: (  
   element: React.ReactNode,  
   instance: React.Component | null,  
   context: Context,  
   childContext?: Context,  
 ) => boolean | void,  
) {  
 if (Array.isArray(element)) {  
   element.forEach(item => walkTree(item, context, visitor));  
   return;  
 }  
  
 if (!element) {  
   return;  
 }  
  
 // A stateless functional component or a class  
 if (isReactElement(element)) {  
   if (typeof element.type === 'function') {  
     const Comp = element.type;  
     const props = Object.assign({}, Comp.defaultProps, getProps(element));  
     let childContext = context;  
     let child;  
  
     // Are we are a react class?  
     if (isComponentClass(Comp)) {  
       const instance = new Comp(props, context);  
       // In case the user doesn't pass these to super in the constructor.  
       // Note: `Component.props` are now readonly in `@types/react`, so  
       // we're using `defineProperty` as a workaround (for now).  
       Object.defineProperty(instance, 'props', {  
         value: instance.props || props,  
       });  
       instance.context = instance.context || context;  
  
       // Set the instance state to null (not undefined) if not set, to match React behaviour  
       instance.state = instance.state || null;  
  
       // Override setState to just change the state, not queue up an update  
       // (we can't do the default React thing as we aren't mounted  
       // "properly", however we don't need to re-render as we only support  
       // setState in componentWillMount, which happens *before* render).  
       instance.setState = newState => {  
         if (typeof newState === 'function') {  
           // React's TS type definitions don't contain context as a third parameter for  
           // setState's updater function.  
           // Remove this cast to `any` when that is fixed.  
           newState = (newState as any)(instance.state, instance.props, instance.context);  
         }  
         instance.state = Object.assign({}, instance.state, newState);  
       };  
  
       if (Comp.getDerivedStateFromProps) {  
         const result = Comp.getDerivedStateFromProps(instance.props, instance.state);  
         if (result !== null) {  
           instance.state = Object.assign({}, instance.state, result);  
         }  
       } else if (instance.UNSAFE_componentWillMount) {  
         instance.UNSAFE_componentWillMount();  
       } else if (instance.componentWillMount) {  
         instance.componentWillMount();  
       }  
  
       if (providesChildContext(instance)) {  
         childContext = Object.assign({}, context, instance.getChildContext());  
       }  
  
       if (visitor(element, instance, context, childContext) === false) {  
         return;  
       }  
  
       child = instance.render();  
     } else {  
       // Just a stateless functional  
       if (visitor(element, null, context) === false) {  
         return;  
       }  
  
       child = Comp(props, context);  
     }  
  
     if (child) {  
       if (Array.isArray(child)) {  
         child.forEach(item => walkTree(item, childContext, visitor));  
       } else {  
         walkTree(child, childContext, visitor);  
       }  
     }  
   } else if ((element.type as any)._context || (element.type as any).Consumer) {  
     // A React context provider or consumer  
     if (visitor(element, null, context) === false) {  
       return;  
     }  
  
     let child;  
     if ((element.type as any)._context) {  
       // A provider \- sets the context value before rendering children  
       ((element.type as any)._context as any)._currentValue = element.props.value;  
       child = element.props.children;  
     } else {  
       // A consumer  
       child = element.props.children((element.type as any)._currentValue);  
     }  
  
     if (child) {  
       if (Array.isArray(child)) {  
         child.forEach(item => walkTree(item, context, visitor));  
       } else {  
         walkTree(child, context, visitor);  
       }  
     }  
   } else {  
     // A basic string or dom element, just get children  
     if (visitor(element, null, context) === false) {  
       return;  
     }  
  
     if (element.props && element.props.children) {  
       React.Children.forEach(element.props.children, (child: any) => {  
         if (child) {  
           walkTree(child, context, visitor);  
         }  
       });  
     }  
   }  
 } else if (typeof element === 'string' || typeof element === 'number') {  
   // Just visit these, they are leaves so we don't keep traversing.  
   visitor(element, null, context);  
 }  
}

注水和脱水，是同构应用最为核心和关键的细节点。

### 请求认证处理

上面讲到服务端预先请求数据，那么思考这样的场景：某个请求依赖 cookie 表明的用户信息，比如请求「我的学习计划列表」。这种情况下服务端请求是不同于客户端的，不会有浏览器添加 cookie 以及不含有其他相关的 header 信息。这个请求在服务端发送时，一定不会拿到预期的结果。

为了解决这个问题，我们来看看 React-apollo 的解决方法：

`import { ApolloProvider } from 'react-apollo'  
import { ApolloClient } from 'apollo-client'  
import { createHttpLink } from 'apollo-link-http'  
import Express from 'express'  
import { StaticRouter } from 'react-router'  
import { InMemoryCache } from "apollo-cache-inmemory"  
  
import Layout from './routes/Layout'  
  
// Note you don't have to use any particular http server, but  
// we're using Express in this example  
const app = new Express();  
app.use((req, res) => {  
  
 const client = new ApolloClient({  
   ssrMode: true,  
   // Remember that this is the interface the SSR server will use to connect to the  
   // API server, so we need to ensure it isn't firewalled, etc  
   link: createHttpLink({  
     uri: 'http://localhost:3010',  
     credentials: 'same-origin',  
     headers: {  
       cookie: req.header('Cookie'),  
     },  
   }),  
   cache: new InMemoryCache(),  
 });  
  
 const context = {}  
  
 // The client-side App will instead use  
 const App = (  
     
       
         
       
     
 );  
  
 // rendering code (see below)  
})`

这个做法也非常简单，原理是：服务端请求时需要保留客户端页面请求的信息，并在 API 请求时携带并透传这个信息。上述代码中，createHttpLink 方法调用时：

`headers: {  
   cookie: req.header('Cookie'),  
},`

这个配置项就是关键，它使得服务端的请求完整地还原了客户端信息，因此验证类接口也不再会有问题。

事实上，很多早期 React 完成服务端渲染的轮子都借鉴了 React-apollo 众多优秀思想，对这个话题感兴趣的读者可以抽空去了解 React-apollo。

### 样式问题处理

同构应用的样式处理容易被开发者所忽视，而一旦忽略，就会掉到坑里。比如，正常的服务端渲染只是返回了 HTML 字符串，样式需要浏览器加载完 CSS 后才会加上，这个样式添加的过程就会造成页面的闪动。

再比如，我们不能再使用 style-loader 了，因为这个 webpack loader 会在编译时将样式模块载入到 HTML header 中。但是在服务端渲染环境下，没有 window 对象，style-loader 进而会报错。一般我们换用 isomorphic-style-loader 来实现：

`{  
   test: /\.css$/,  
   use: [  
       'isomorphic-style-loader',  
       'css-loader',  
       'postcss-loader'  
   ],  
}`

同时 isomorphic-style-loader 也会解决页面样式闪动的问题。它的原理也不难理解：在服务器端输出 html 字符串的同时，也将样式插入到 html 字符串当中，将结果一同传送到客户端。

isomorphic-style-loader 的原理是什么呢？

我们知道对于 webpack 来说，所有的资源都是模块，webpack loader 在编译过程中可以将导入的 CSS 文件转换成对象，拿到样式信息。因此 isomorphic-style-loader 可以获取页面中所有组件样式。为了实现的更加通用化，isomorphic-style-loader 利用 context API，在渲染页面组件时获取所有 React 组件的样式信息，最终插入到 HTML 字符串中。

在服务端渲染时，我们需要加入这样的逻辑：

``import express from 'express'  
import React from 'react'  
import ReactDOM from 'react-dom'  
import StyleContext from 'isomorphic-style-loader/StyleContext'  
import App from './App.js'  
  
const server = express()  
const port = process.env.PORT || 3000  
  
// Server-side rendering of the React app  
server.get('*', (req, res, next) => {  
  
 const css = new Set() // CSS for all rendered React components  
  
 const insertCss = (...styles) => styles.forEach(style => css.add(style._getCss()))  
  
 const body = ReactDOM.renderToString(  
     
       
     
 )  
 const html = `  
     
       
         
       <style>${[...css].join('')}</style>  
       
       
       ``

`${body}`

``  
       
   `  
 res.status(200).send(html)  
})  
  
server.listen(port, () => {  
 console.log(`Node.js app is running at http://localhost:${port}/`)  
})``

我们定义了 css Set 类型来存储页面所有的样式，并定义了 insertCss 方法，该方法通过 context 传给每个 React 组件，这样每个组件就可以调用 insertCss 方法。该方法调用时，会将组件样式加入到 css Set 当中。

最后我们用 [...css].join('') 就可以获取页面的所有样式字符串。

强调一下，isomorphic-style-loader 的源码目前已经更新，采用了最新的 React hooks API，我推荐给 React 开发者阅读，相信一定收获很多！

### meta tags 渲染

React 应用中，骨架往往类似：

`const App = () => {  
 return (  
   `

`  
 )  
}  
ReactDom.render(, document.querySelector('#root'))`

App 组件嵌入到 document.querySelector('#root') 节点当中，一般是不包含 head 标签的。但是单页应用在切换路由时，可能也会需要动态修改 head 标签信息，比如 title 内容。也就是说：在单页面应用切换页面，不会经过服务端渲染，但是我们仍然需要更改 document 的 title 内容。

那么服务端如何渲染 meta tags head 标签就是一个常被忽略但是至关重要的话题，我们往往使用 React-helmet 库来解决问题。

Home 组件：

`import Helmet from "react-helmet";  
  
`

`  
     
       Home page  
         
     
   

# Home component

`

Users 组件：

`  
   Users page  
     
`

React-helmet 这个库会在 Home 组件和 Users 组件渲染时，检测到 Helmet，并自动执行副作用逻辑。

### 404 处理

当服务端渲染时，我们还需要留心对 404 的情况进行处理，有 layout.js 文件如下：

当访问：`/home` 时，会得到一个空白页面，浏览器也没有得到 404 的状态码。为了处理这种情况，我们加入：

并创建 NotFound.js 文件：

`import React from 'react'  
  
export default function NotFound({ staticContext }) {  
   if (staticContext) {  
       staticContext.notFound = true  
   }  
   return (  
       `

`Not found`

`  
   )  
}`

注意，在访问一个不存在的地址时，我们要返回 404 状态码。一般 React router 类库已经帮我们进行了较好的封装，Static Router 会注入一个 context prop，并将 context.notFound 赋值为 true，在 server/index.js 加入：

`const context = {}  
const html = renderer(data, req.path, context);  
if (context.notFound) {  
   res.status(404)  
}  
res.send(html)`

即可。这一系列处理过程没有什么难点，但是这种处理意识，还是需要具备的。

### 安全问题

安全问题非常关键，尤其是涉及到服务端渲染，开发者要格外小心。这里提出一个点：我们前面提到了注水和脱水过程，其中的代码：

``ctx.body = `  
   
   
     
       
     
     
       <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.context = {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialState: ${JSON.stringify(store.getState())}<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  
     ``

`  
         // ...  
     `

``  
     
   
` ``

非常容易遭受 XSS 攻击，JSON.stringify 可能会造成 script 注入。因此，我们需要严格清洗 JSON 字符串中的 HTML 标签和其他危险的字符。我习惯使用 serialize-javascript 库进行处理，这也是同构应用中最容易被忽视的细节。

这里给大家留一个思考题，React dangerouslySetInnerHTML API 也有类似风险，React 是怎么处理这个安全隐患的呢？

### 性能优化

我们将数据请求移到了服务端，但是依然要格外重视性能优化。目前针对于此，业界普遍做法包括以下几点。
 \- 使用缓存：服务端优化一个最重要的手段就是缓存，不同于传统服务端缓存措施，我们甚至可以实现组件级缓存，业界 walmartlabs 在这方面的实践非常多，且收获了较大的性能提升。感兴趣的读者可以找到相关技术信息。 \- 采用 HSF 代替 HTTP，HSF 是 High-Speed Service Framework 的缩写，译为分布式的远程服务调用框架，对外提供服务上，HSF 性能远超过 HTTP。 \- 对于服务端压力过大的场景，动态切换为客户端渲染。 \- NodeJS 升级。 \- React 升级。

如图所示，React 16 在服务端渲染上的性能对比提升：

  

加载中...

>   

备注：图片来自 [hacker noon](https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67 "hacker noon")

### 总结

本讲没有「手把手」教你实现服务端渲染的同构应用，因为这些知识并不困难，社区上资料也很多。我们从更高的角度出发，剖析同构应用中那些关键的细节点和疑难问题的解决方案，这些经验来源于真刀真枪的线上案例，如果读者没有开发过同构应用，也能从中全方位地了解关键信息，一旦掌握了这些细节，同构应用的实现就会更稳、更可靠。

同构应用其实远比理论复杂，绝对不是几个 APIs 和几台服务器就能完成的，希望大家多思考、多动手，一定会更有体会。

另外，同构应用各种细节也不止于此，坑也不止于此，欢迎大家和我讨论。

### 分享交流

阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。**你的分享不仅帮助他人，更会提升自己。**

你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。

此外，我们为本课程付费读者创建了《前端开发核心知识进阶》微信交流群，以方便更有针对性地讨论课程相关问题（入群请到第 1-2 课末尾添加 GitChat 小助手伽利略的微信，并注明「前端核心」，谢谢~）

备案号:YXX1p6PmGY5tXLQyEwI5olY

编辑于 2020-05-22 14:04 · 禁止转载

点击查看下一节

从框架和类库，我们该学到什么

<style data-emotion-css="6sb417">.css-6sb417{overflow:hidden;position:relative;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:36px;border-radius:18px;}</style>

<style data-emotion-css="1q2f8kt">.css-1q2f8kt{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.css-1q2f8kt:active{opacity:0.5 !important;}</style><style data-emotion-css="12r0ul1">.css-12r0ul1{box-sizing:border-box;margin:0;min-width:0;background-color:transparent;overflow:hidden;height:36px;font-weight:600;font-size:12px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}.css-12r0ul1:active{opacity:0.5 !important;}</style>

<style data-emotion-css="v0jgcu">.css-v0jgcu{position:absolute;top:0;left:0;}</style><style data-emotion-css="cy329x">.css-cy329x{box-sizing:border-box;margin:0;min-width:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;overflow:hidden;width:100%;height:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;position:absolute;top:0;left:0;}</style>

<style data-emotion-css="o5uqvq">.css-o5uqvq{margin-left:5px;}</style><style data-emotion-css="18biwo">.css-18biwo{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style>​<style data-emotion-css="d519u3 animation-d2btug">.css-d519u3{fill:currentColor;-webkit-animation:animation-d2btug 1s steps(12) infinite;animation:animation-d2btug 1s steps(12) infinite;}@-webkit-keyframes animation-d2btug{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}@keyframes animation-d2btug{0%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);}100%{-webkit-transform:rotate(360deg);-ms-transform:rotate(360deg);transform:rotate(360deg);}}</style>

<style data-emotion-css="3nc1uv">.css-3nc1uv{background:#175199;height:18px;width:1px;opacity:0.2;}</style>

<style data-emotion-css="1cfk3tj">.css-1cfk3tj{width:14px;height:14px;margin-right:6px;}</style>​<style data-emotion-css="ke5ir5">.css-ke5ir5{box-sizing:border-box;margin:0;min-width:0;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style>

目录

评论

分享

![](https://pic1.zhimg.com/50/v2-928c5e9d7027db41982aa8353002150d_200x0.png)

前端开发核心知识进阶：50 讲从夯实基础到突破瓶颈

Lucas HC

window.zhihuNativeApp&&window.zhihuNativeApp.sendToNative&&window.zhihuNativeApp.sendToNative(JSON.stringify({module: 'market',action: 'FCPEnd',params: {}})) {"name":"manuscript","status":200,"titleHTML":{},"metaHTML":{},"webPageReadyScript":"\u003cscript nonce=\"RCPkuAllkBS9uzhvwraMO\">window.zhihuNativeApp&&window.zhihuNativeApp.sendToNative&&window.zhihuNativeApp.sendToNative(JSON.stringify({module: 'market',action: 'FCPEnd',params: {}}))\u003c/script>","viteScript":"","appContext":{"request":{"ip":"27.38.69.251","xRealIp":"27.38.69.251","headers":{"host":"www.zhihu.com","x-udid":"AMBXA2viIRaPTiayW2XDwwutZFH9WpsgzQE="},"url":"/market/paid_column/1167078439772721152/section/1169971710572367872","href":"https://www.zhihu.com/market/paid_column/1167078439772721152/section/1169971710572367872","path":"/market/paid_column/1167078439772721152/section/1169971710572367872","params":{"0":"section","productType":"paid_column","productId":"1167078439772721152","manuscriptId":"1169971710572367872"},"query":{}},"deviceID":"","ua":{"Mobile":false,"Android":false,"Chrome":false,"iOS":false,"Wechat":false,"WorkWechat":false,"WechatMiniprogram":false,"Weibo":false,"QQ":false,"Zhihu":false,"ZhihuHybrid":false,"iPad":false,"UC":false,"QQBrowser":false,"BankABC":false,"BankABCNew":false,"AliPay":false},"theme":"light","isOffice":false,"xAppZa":"","xAppVersion":"","xApiVersion":"","xNetworkType":"","xUDId":"AMBXA2viIRaPTiayW2XDwwutZFH9WpsgzQE=","xZst81":"","authId":"3e3ca09c9310955765cf24d9860888a6","zaeEnvType":"","commentCloseFlag":"0","globalSlienceMode":"","supportsWebp":false,"apiBaseDict":{"api-default":"https://api.zhihu.com","api-v4":"https://www.zhihu.com/api/v4","api-walletpay":"https://walletpay.zhihu.com"},"safeAreaInset":{},"vipPrivilegesUrl":"https://www.zhihu.com/xen/market/vip-privileges","nonce":"RCPkuAllkBS9uzhvwraMO","ssrStage":"render","__connectedAutoFetch":{"manuscript":{"pending":false,"data":{"manuscriptData":{"recommend_title":"","index":{"relative":22,"serial_number_txt":"第 22 节"},"chapter_index":{"serial_number_txt":"第 0 章","show_chapter_name":false},"is_curriculum":false,"time_info":{"created_at":1571722992,"updated_at":1590127470},"paid_column":{"id":"1167078439772721152","sku_id":"1167078439994777600","title":"前端开发核心知识进阶：50 讲从夯实基础到突破瓶颈","authors":[{"bio":"知乎「前端开发」话题优秀回答者，《React 状态管理与同构实战》作者。","is_section_authors":false,"name":"Lucas HC","headline":"Carpe diem","avatar_url":"https://picx.zhimg.com/6c3e4f09100f35d70c4f7ab86b0a68c1.jpg?source=f65c3faf","url":"https://www.zhihu.com/people/f04b762a72416dbaf4b9656055d723c6","member_hash":"f04b762a72416dbaf4b9656055d723c6","url_token":"lucas-hc","user_type":"people","is_following":false,"badge":[{"type":"best_answerer"}]}],"update_finished":true,"artwork":"https://pic1.zhimg.com/v2-928c5e9d7027db41982aa8353002150d.png?source=f65c3faf","tab_artwork":"https://pic1.zhimg.com/v2-39fa776732e5fc8636f771d2d5599cfb.png?source=f65c3faf","section_count":51,"updated_section_count":51,"has_interested":true},"id":"1169971710572367872","title":"同构应用中你所忽略的细节","manuscript":"\u003cp>不管是服务端渲染还是服务端渲染衍生出的同构应用\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>现在来看已经并不新鲜了\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>实现起来也并不困难\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>可是有的开发者认为\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>同构应用不就是调用一个 renderToString\u003cspan class=\"fw-op \">\u003cspan>（\u003c/span>\u003c/span>React 中\u003cspan class=\" fw-cl \">\u003cspan>）\u003c/span>\u003c/span>类似的 API 吗\u003cspan class=\" fw-cl \">\u003cspan>？\u003c/span>\u003c/span>\u003c/p>\n\u003cp>讲道理确实是这样的\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>但是讲道理你也许并没有真正在实战中领会同构应用的精髓\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>同构应用能够完成的本质条件是虚拟 DOM\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>基于虚拟 DOM 我们可以生成真实的 DOM\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并由浏览器渲染\u003cspan class=\" fw-cl \">\u003cspan>；\u003c/span>\u003c/span>也可以调用不同框架的不同 APIs\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>将虚拟 DOM 生成字符串\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>由服务端传输给客户端\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>但是同构应用也不只是这么简单\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>拿面试来说\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>同构应用的考察点不是\u003cspan class=\"fw-op \">\u003cspan>「\u003c/span>\u003c/span>纸上谈兵\u003cspan class=\" fw-cl \">\u003cspan>」\u003c/span>\u003c/span>的理论\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>而是实际实施时的细节\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>这一讲我们就来聊一聊\u003cspan class=\"fw-op \">\u003cspan>「\u003c/span>\u003c/span>同构应用中往往被忽略的细节\u003cspan class=\" fw-cl fw--collapsed\">\u003cspan>」\u003c/span>\u003c/span>\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>需要读者提前了解服务端渲染和同构应用的概念\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>相关知识点如下\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003cbr>\u003c/p>\n\u003cfigure class=\"central\">\u003cimg src=\"https://pic2.zhimg.com/v2-25910174b3cb3d895c86405207c91401.png\" alt=\"图片\" data-rawwidth=\"461\" data-rawheight=\"536\">\u003c/figure>\n\u003ch3>打包环境区分\u003c/h3>\n\u003cp>第一个细节\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>我们知道同构应用实现了客户端代码和服务端代码的基本统一\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们只需要编写一种组件\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>就能生成适用于服务端和客户端的组件案例\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>可是你是否知道\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>服务端代码和客户端代码大多数情况下还是需要单独处理\u003cspan class=\" fw-cl \">\u003cspan>？\u003c/span>\u003c/span>比如\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cul>\n \u003cli style=\"\">路由代码差别\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>服务端需要根据请求路径\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>匹配页面组件\u003cspan class=\" fw-cl \">\u003cspan>；\u003c/span>\u003c/span>客户端需要通过浏览器中的地址\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>匹配页面组件\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/li>\n\u003c/ul>\n\u003cp>客户端代码\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>const App = () => {\u003cbr>\n &nbsp;return (\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cProvider store={store}>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cBrowserRouter>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cdiv>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cRoute path='/' component={Home}>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cRoute path='/product' component={Product}>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/div>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/BrowserRouter>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/Provider>\u003cbr>\n &nbsp;)\u003cbr>\n}\u003cbr>\nReactDom.render(\u003cApp/>, document.querySelector('#root'))\u003c/code>\u003c/p>\n\u003cp>BrowserRouter 组件根据 window.location 以及 history API 实现页面切换\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>而服务端肯定是无法获取 window.location 的\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>服务端代码如下\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>const App = () => {\u003cbr>\n &nbsp;return \u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cProvider store={store}>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cStaticRouter location={req.path} context={context}>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cdiv>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cRoute path='/' component={Home}>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/div>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/StaticRouter>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/Provider>\u003cbr>\n}\u003cbr>\nReturn ReactDom.renderToString(\u003cApp/>)\u003c/code>\u003c/p>\n\u003cp>需要使用 StaticRouter 组件\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并将请求地址和上下文信息作为 location 和 context 这两个 props 传入 StaticRouter 中\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cul>\n \u003cli style=\"\">\u003cbr>\u003c/li>\n\u003c/ul>\n\u003cp>打包差别\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>服务端运行的代码如果需要依赖 Node 核心模块或者第三方模块\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>就不再需要把这些模块代码打包到最终代码中了\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>因为环境已经安装这些依赖\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>可以直接引用\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>这样一来\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>就需要我们在 webpack 中配置\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>target\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>node\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并借助 webpack-node-externals 插件\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>解决第三方依赖打包的问题\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cul>\n \u003cli style=\"\">\u003cbr>\u003c/li>\n\u003c/ul>\n\u003cp>对于图片等静态资源\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>url-loader 会在服务端代码和客户端代码打包过程中分别被引用\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>因此会在资源目录中生成了重复的文件\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>当然后打包出来的因为重名\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>会覆盖前一次打包出来的结果\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并不影响使用\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>但是整个构建过程并不优雅\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cul>\n \u003cli style=\"\">\u003cbr>\u003c/li>\n\u003c/ul>\n\u003cp>由于路由在服务端和客户端的差别\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>因此 webpack 配置文件的 entry 会不相同\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>{\u003cbr>\n &nbsp;&nbsp;&nbsp;entry: './src/client/index.js',\u003cbr>\n}\u003cbr>\n\u003cbr>\n{\u003cbr>\n &nbsp;&nbsp;&nbsp;entry: './src/server/index.js',\u003cbr>\n}\u003c/code>\u003c/p>\n\u003ch3>注水和脱水\u003c/h3>\n\u003cp>什么叫做注水和脱水呢\u003cspan class=\" fw-cl \">\u003cspan>？\u003c/span>\u003c/span>这个和同构应用中数据的获取有关\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>在服务器端渲染时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>首先服务端请求接口拿到数据\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并处理准备好数据状态\u003cspan class=\"fw-op \">\u003cspan>（\u003c/span>\u003c/span>如果使用 Redux\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>就是进行 store 的更新\u003cspan class=\" fw-cl fw--collapsed\">\u003cspan>）\u003c/span>\u003c/span>\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>为了减少客户端的请求\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们需要保留住这个状态\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>一般做法是在服务器端返回 HTML 字符串的时候\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>将数据 JSON.stringify 一并返回\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>这个过程\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>叫做脱水\u003cspan class=\"fw-op \">\u003cspan>（\u003c/span>\u003c/span>dehydrate\u003cspan class=\" fw-cl fw--collapsed\">\u003cspan>）\u003c/span>\u003c/span>\u003cspan class=\" fw-cl \">\u003cspan>；\u003c/span>\u003c/span>在客户端\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>就不再需要进行数据的请求了\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>可以直接使用服务端下发下来的数据\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>这个过程叫注水\u003cspan class=\"fw-op \">\u003cspan>（\u003c/span>\u003c/span>hydrate\u003cspan class=\" fw-cl fw--collapsed\">\u003cspan>）\u003c/span>\u003c/span>\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>用代码来表示\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>服务端\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>ctx.body = `\u003cbr>\n &nbsp;\u003c!DOCTYPE html>\u003cbr>\n &nbsp;\u003chtml lang=\"en\">\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003chead>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cmeta charset=\"UTF-8\">\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/head>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cbody>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cscript>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.context = {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialState: ${JSON.stringify(store.getState())}\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/script>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cdiv id=\"app\">\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/div>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/body>\u003cbr>\n &nbsp;\u003c/html>\u003cbr>\n`\u003c/code>\u003c/p>\n\u003cp>客户端\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>export const getClientStore = () => {\u003cbr>\n &nbsp;const defaultState = JSON.parse(window.context.state)\u003cbr>\n &nbsp;return createStore(reducer, defaultState, applyMiddleware(thunk))\u003cbr>\n}\u003c/code>\u003c/p>\n\u003cp>这一系列过程非常典型\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>但是也会有几个细节值得探讨\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003cstrong style=\"\">在服务端渲染时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>服务端如何能够请求所有的 APIs\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>保障数据全部已经请求呢\u003cspan class=\" fw-cl \">\u003cspan>？\u003c/span>\u003c/span>\u003c/strong>\u003c/p>\n\u003cp>一般有两种方法\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cul>\n \u003cli style=\"\">react-router 的解决方案是配置路由 route-config\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>结合 matchRoutes\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>找到页面上相关组件所需的请求接口的方法并执行请求\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>这就要求开发者通过路由配置信息\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>显式地告知服务端请求内容\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/li>\n\u003c/ul>\n\u003cp>我们首先配置路由\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>const routes = [\u003cbr>\n &nbsp;{\u003cbr>\n &nbsp;&nbsp;&nbsp;path: \"/\",\u003cbr>\n &nbsp;&nbsp;&nbsp;component: Root,\u003cbr>\n &nbsp;&nbsp;&nbsp;loadData: () => getSomeData()\u003cbr>\n &nbsp;}\u003cbr>\n &nbsp;// etc.\u003cbr>\n]\u003cbr>\n\u003cbr>\nimport { routes } from \"./routes\"\u003cbr>\n\u003cbr>\nfunction App() {\u003cbr>\n &nbsp;return (\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cSwitch>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{routes.map(route => (\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cRoute {...route} />\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;))}\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/Switch>\u003cbr>\n &nbsp;)\u003cbr>\n}\u003c/code>\u003c/p>\n\u003cp>在服务端代码中\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>import { matchPath } from \"react-router-dom\"\u003cbr>\n\u003cbr>\nconst promises = []\u003cbr>\nroutes.some(route => {\u003cbr>\n &nbsp;const match = matchPath(req.path, route)\u003cbr>\n &nbsp;if (match) promises.push(route.loadData(match))\u003cbr>\n &nbsp;return match\u003cbr>\n})\u003cbr>\n\u003cbr>\nPromise.all(promises).then(data => {\u003cbr>\n &nbsp;putTheDataSomewhereTheClientCanFindIt(data)\u003cbr>\n})\u003c/code>\u003c/p>\n\u003cul>\n \u003cli style=\"\">另外一种思路类似 Next.js\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们需要在 React 组件上定义静态方法\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span> 比如定义静态 loadData 方法\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>在服务端渲染时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们可以遍历所有组件的 loadData\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>获取需要请求的接口\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>这样的方式借鉴了早期 React-apollo 的解决方案\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我个人很喜欢这种设计\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>这里贴出我为 Facebook 团队 react-apollo 开源项目贡献的改动代码\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>其目的就是遍历组件\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>获取请求接口\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/li>\n\u003c/ul>\n\u003cp>\u003ccode>function getPromisesFromTree({\u003cbr>\n &nbsp;rootElement,\u003cbr>\n &nbsp;rootContext = {},\u003cbr>\n}: PromiseTreeArgument): PromiseTreeResult[] {\u003cbr>\n &nbsp;const promises: PromiseTreeResult[] = [];\u003cbr>\n\u003cbr>\n &nbsp;walkTree(rootElement, rootContext, (_, instance, context, childContext) => {\u003cbr>\n &nbsp;&nbsp;&nbsp;if (instance && hasFetchDataFunction(instance)) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const promise = instance.fetchData();\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isPromise\u003cObject>(promise)) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promises.push({ promise, context: childContext || context, instance });\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;});\u003cbr>\n\u003cbr>\n &nbsp;return promises;\u003cbr>\n}\u003cbr>\n\u003cbr>\n// Recurse a React Element tree, running visitor on each element.\u003cbr>\n// If visitor returns `false`, don't call the element's render function\u003cbr>\n// or recurse into its child elements.\u003cbr>\nexport function walkTree(\u003cbr>\n &nbsp;element: React.ReactNode,\u003cbr>\n &nbsp;context: Context,\u003cbr>\n &nbsp;visitor: (\u003cbr>\n &nbsp;&nbsp;&nbsp;element: React.ReactNode,\u003cbr>\n &nbsp;&nbsp;&nbsp;instance: React.Component\u003cany> | null,\u003cbr>\n &nbsp;&nbsp;&nbsp;context: Context,\u003cbr>\n &nbsp;&nbsp;&nbsp;childContext?: Context,\u003cbr>\n &nbsp;) => boolean | void,\u003cbr>\n) {\u003cbr>\n &nbsp;if (Array.isArray(element)) {\u003cbr>\n &nbsp;&nbsp;&nbsp;element.forEach(item => walkTree(item, context, visitor));\u003cbr>\n &nbsp;&nbsp;&nbsp;return;\u003cbr>\n &nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;if (!element) {\u003cbr>\n &nbsp;&nbsp;&nbsp;return;\u003cbr>\n &nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;// A stateless functional component or a class\u003cbr>\n &nbsp;if (isReactElement(element)) {\u003cbr>\n &nbsp;&nbsp;&nbsp;if (typeof element.type === 'function') {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const Comp = element.type;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const props = Object.assign({}, Comp.defaultProps, getProps(element));\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let childContext = context;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let child;\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Are we are a react class?\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isComponentClass(Comp)) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const instance = new Comp(props, context);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// In case the user doesn't pass these to super in the constructor.\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Note: `Component.props` are now readonly in `@types/react`, so\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// we're using `defineProperty` as a workaround (for now).\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.defineProperty(instance, 'props', {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: instance.props || props,\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.context = instance.context || context;\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set the instance state to null (not undefined) if not set, to match React behaviour\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.state = instance.state || null;\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Override setState to just change the state, not queue up an update\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (we can't do the default React thing as we aren't mounted\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// \"properly\", however we don't need to re-render as we only support\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setState in componentWillMount, which happens *before* render).\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.setState = newState => {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof newState === 'function') {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// React's TS type definitions don't contain context as a third parameter for\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// setState's updater function.\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Remove this cast to `any` when that is fixed.\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newState = (newState as any)(instance.state, instance.props, instance.context);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.state = Object.assign({}, instance.state, newState);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Comp.getDerivedStateFromProps) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const result = Comp.getDerivedStateFromProps(instance.props, instance.state);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result !== null) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.state = Object.assign({}, instance.state, result);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (instance.UNSAFE_componentWillMount) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.UNSAFE_componentWillMount();\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (instance.componentWillMount) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance.componentWillMount();\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (providesChildContext(instance)) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childContext = Object.assign({}, context, instance.getChildContext());\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (visitor(element, instance, context, childContext) === false) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child = instance.render();\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Just a stateless functional\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (visitor(element, null, context) === false) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child = Comp(props, context);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (child) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Array.isArray(child)) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.forEach(item => walkTree(item, childContext, visitor));\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;walkTree(child, childContext, visitor);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;} else if ((element.type as any)._context || (element.type as any).Consumer) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A React context provider or consumer\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (visitor(element, null, context) === false) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let child;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((element.type as any)._context) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A provider \- sets the context value before rendering children\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((element.type as any)._context as any)._currentValue = element.props.value;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child = element.props.children;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A consumer\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child = element.props.children((element.type as any)._currentValue);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (child) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Array.isArray(child)) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.forEach(item => walkTree(item, context, visitor));\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;walkTree(child, context, visitor);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;} else {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// A basic string or dom element, just get children\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (visitor(element, null, context) === false) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (element.props && element.props.children) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React.Children.forEach(element.props.children, (child: any) => {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (child) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;walkTree(child, context, visitor);\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;} else if (typeof element === 'string' || typeof element === 'number') {\u003cbr>\n &nbsp;&nbsp;&nbsp;// Just visit these, they are leaves so we don't keep traversing.\u003cbr>\n &nbsp;&nbsp;&nbsp;visitor(element, null, context);\u003cbr>\n &nbsp;}\u003cbr>\n}\u003c/code>\u003c/p>\n\u003cp>注水和脱水\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>是同构应用最为核心和关键的细节点\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003ch3>请求认证处理\u003c/h3>\n\u003cp>上面讲到服务端预先请求数据\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>那么思考这样的场景\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>某个请求依赖 cookie 表明的用户信息\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>比如请求\u003cspan class=\"fw-op \">\u003cspan>「\u003c/span>\u003c/span>我的学习计划列表\u003cspan class=\" fw-cl fw--collapsed\">\u003cspan>」\u003c/span>\u003c/span>\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>这种情况下服务端请求是不同于客户端的\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>不会有浏览器添加 cookie 以及不含有其他相关的 header 信息\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>这个请求在服务端发送时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>一定不会拿到预期的结果\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>为了解决这个问题\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们来看看 React-apollo 的解决方法\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>import { ApolloProvider } from 'react-apollo'\u003cbr>\nimport { ApolloClient } from 'apollo-client'\u003cbr>\nimport { createHttpLink } from 'apollo-link-http'\u003cbr>\nimport Express from 'express'\u003cbr>\nimport { StaticRouter } from 'react-router'\u003cbr>\nimport { InMemoryCache } from \"apollo-cache-inmemory\"\u003cbr>\n\u003cbr>\nimport Layout from './routes/Layout'\u003cbr>\n\u003cbr>\n// Note you don't have to use any particular http server, but\u003cbr>\n// we're using Express in this example\u003cbr>\nconst app = new Express();\u003cbr>\napp.use((req, res) => {\u003cbr>\n\u003cbr>\n &nbsp;const client = new ApolloClient({\u003cbr>\n &nbsp;&nbsp;&nbsp;ssrMode: true,\u003cbr>\n &nbsp;&nbsp;&nbsp;// Remember that this is the interface the SSR server will use to connect to the\u003cbr>\n &nbsp;&nbsp;&nbsp;// API server, so we need to ensure it isn't firewalled, etc\u003cbr>\n &nbsp;&nbsp;&nbsp;link: createHttpLink({\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uri: 'http://localhost:3010',\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;credentials: 'same-origin',\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;headers: {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cookie: req.header('Cookie'),\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\u003cbr>\n &nbsp;&nbsp;&nbsp;}),\u003cbr>\n &nbsp;&nbsp;&nbsp;cache: new InMemoryCache(),\u003cbr>\n &nbsp;});\u003cbr>\n\u003cbr>\n &nbsp;const context = {}\u003cbr>\n\u003cbr>\n &nbsp;// The client-side App will instead use \u003cBrowserRouter>\u003cbr>\n &nbsp;const App = (\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cApolloProvider client={client}>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cStaticRouter location={req.url} context={context}>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cLayout />\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/StaticRouter>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/ApolloProvider>\u003cbr>\n &nbsp;);\u003cbr>\n\u003cbr>\n &nbsp;// rendering code (see below)\u003cbr>\n})\u003c/code>\u003c/p>\n\u003cp>这个做法也非常简单\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>原理是\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>服务端请求时需要保留客户端页面请求的信息\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并在 API 请求时携带并透传这个信息\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>上述代码中\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>createHttpLink 方法调用时\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>headers: {\u003cbr>\n &nbsp;&nbsp;&nbsp;cookie: req.header('Cookie'),\u003cbr>\n},\u003c/code>\u003c/p>\n\u003cp>这个配置项就是关键\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>它使得服务端的请求完整地还原了客户端信息\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>因此验证类接口也不再会有问题\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>事实上\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>很多早期 React 完成服务端渲染的轮子都借鉴了 React-apollo 众多优秀思想\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>对这个话题感兴趣的读者可以抽空去了解 React-apollo\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003ch3>样式问题处理\u003c/h3>\n\u003cp>同构应用的样式处理容易被开发者所忽视\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>而一旦忽略\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>就会掉到坑里\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>比如\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>正常的服务端渲染只是返回了 HTML 字符串\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>样式需要浏览器加载完 CSS 后才会加上\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>这个样式添加的过程就会造成页面的闪动\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>再比如\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们不能再使用 style-loader 了\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>因为这个 webpack loader 会在编译时将样式模块载入到 HTML header 中\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>但是在服务端渲染环境下\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>没有 window 对象\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>style-loader 进而会报错\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>一般我们换用 isomorphic-style-loader 来实现\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>{\u003cbr>\n &nbsp;&nbsp;&nbsp;test: /\\.css$/,\u003cbr>\n &nbsp;&nbsp;&nbsp;use: [\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'isomorphic-style-loader',\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'css-loader',\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'postcss-loader'\u003cbr>\n &nbsp;&nbsp;&nbsp;],\u003cbr>\n}\u003c/code>\u003c/p>\n\u003cp>同时 isomorphic-style-loader 也会解决页面样式闪动的问题\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>它的原理也不难理解\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>在服务器端输出 html 字符串的同时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>也将样式插入到 html 字符串当中\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>将结果一同传送到客户端\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>isomorphic-style-loader 的原理是什么呢\u003cspan class=\" fw-cl \">\u003cspan>？\u003c/span>\u003c/span>\u003c/p>\n\u003cp>我们知道对于 webpack 来说\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>所有的资源都是模块\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>webpack loader 在编译过程中可以将导入的 CSS 文件转换成对象\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>拿到样式信息\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>因此 isomorphic-style-loader 可以获取页面中所有组件样式\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>为了实现的更加通用化\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>isomorphic-style-loader 利用 context API\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>在渲染页面组件时获取所有 React 组件的样式信息\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>最终插入到 HTML 字符串中\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>在服务端渲染时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们需要加入这样的逻辑\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>import express from 'express'\u003cbr>\nimport React from 'react'\u003cbr>\nimport ReactDOM from 'react-dom'\u003cbr>\nimport StyleContext from 'isomorphic-style-loader/StyleContext'\u003cbr>\nimport App from './App.js'\u003cbr>\n\u003cbr>\nconst server = express()\u003cbr>\nconst port = process.env.PORT || 3000\u003cbr>\n\u003cbr>\n// Server-side rendering of the React app\u003cbr>\nserver.get('*', (req, res, next) => {\u003cbr>\n\u003cbr>\n &nbsp;const css = new Set() // CSS for all rendered React components\u003cbr>\n\u003cbr>\n &nbsp;const insertCss = (...styles) => styles.forEach(style => css.add(style._getCss()))\u003cbr>\n\u003cbr>\n &nbsp;const body = ReactDOM.renderToString(\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cStyleContext.Provider value={{ insertCss }}>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cApp />\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/StyleContext.Provider>\u003cbr>\n &nbsp;)\u003cbr>\n &nbsp;const html = `\u003c!doctype html>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003chtml>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003chead>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cscript src=\"client.js\" defer>\u003c/script>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cstyle>${[...css].join('')}\u003c/style>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/head>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cbody>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cdiv id=\"root\">${body}\u003c/div>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/body>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/html>`\u003cbr>\n &nbsp;res.status(200).send(html)\u003cbr>\n})\u003cbr>\n\u003cbr>\nserver.listen(port, () => {\u003cbr>\n &nbsp;console.log(`Node.js app is running at http://localhost:${port}/`)\u003cbr>\n})\u003c/code>\u003c/p>\n\u003cp>我们定义了 css Set 类型来存储页面所有的样式\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并定义了 insertCss 方法\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>该方法通过 context 传给每个 React 组件\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>这样每个组件就可以调用 insertCss 方法\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>该方法调用时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>会将组件样式加入到 css Set 当中\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>最后我们用 [...css].join('') 就可以获取页面的所有样式字符串\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>强调一下\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>isomorphic-style-loader 的源码目前已经更新\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>采用了最新的 React hooks API\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我推荐给 React 开发者阅读\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>相信一定收获很多\u003cspan class=\" fw-cl \">\u003cspan>！\u003c/span>\u003c/span>\u003c/p>\n\u003ch3>meta tags 渲染\u003c/h3>\n\u003cp>React 应用中\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>骨架往往类似\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>const App = () => {\u003cbr>\n &nbsp;return (\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cdiv>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cComponent1 />\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cComponent2 />\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/div>\u003cbr>\n &nbsp;)\u003cbr>\n}\u003cbr>\nReactDom.render(\u003cApp/>, document.querySelector('#root'))\u003c/code>\u003c/p>\n\u003cp>App 组件嵌入到 document.querySelector('#root') 节点当中\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>一般是不包含 head 标签的\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>但是单页应用在切换路由时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>可能也会需要动态修改 head 标签信息\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>比如 title 内容\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>也就是说\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>在单页面应用切换页面\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>不会经过服务端渲染\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>但是我们仍然需要更改 document 的 title 内容\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>那么服务端如何渲染 meta tags head 标签就是一个常被忽略但是至关重要的话题\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们往往使用 React-helmet 库来解决问题\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>Home 组件\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>import Helmet from \"react-helmet\";\u003cbr>\n\u003cbr>\n\u003cdiv>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cHelmet>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003ctitle>Home page\u003c/title>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cmeta name=\"description\" content=\"Home page description\" />\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/Helmet>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003ch1>Home component\u003c/h1>\u003c/code>\u003c/p>\n\u003cp>Users 组件\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>\u003cHelmet>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003ctitle>Users page\u003c/title>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cmeta name=\"description\" content=\"Users page description\" />\u003cbr>\n\u003c/Helmet>\u003c/code>\u003c/p>\n\u003cp>React-helmet 这个库会在 Home 组件和 Users 组件渲染时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>检测到 Helmet\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并自动执行副作用逻辑\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003ch3>404 处理\u003c/h3>\n\u003cp>当服务端渲染时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们还需要留心对 404 的情况进行处理\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>有 layout.js 文件如下\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>\u003cSwitch>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cRoute path=\"/\" exact component={Home} />\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cRoute path=\"/users\" exact component={Users} />\u003cbr>\n\u003c/Switch>\u003c/code>\u003c/p>\n\u003cp>当访问\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003ccode>/home\u003c/code> 时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>会得到一个空白页面\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>浏览器也没有得到 404 的状态码\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>为了处理这种情况\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们加入\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>\u003cSwitch>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cRoute path=\"/\" exact component={Home} />\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cRoute path=\"/users\" exact component={Users} />\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cRoute component={NotFound} />\u003cbr>\n\u003c/Switch>\u003c/code>\u003c/p>\n\u003cp>并创建 NotFound.js 文件\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>import React from 'react'\u003cbr>\n\u003cbr>\nexport default function NotFound({ staticContext }) {\u003cbr>\n &nbsp;&nbsp;&nbsp;if (staticContext) {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;staticContext.notFound = true\u003cbr>\n &nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;return (\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cdiv>Not found\u003c/div>\u003cbr>\n &nbsp;&nbsp;&nbsp;)\u003cbr>\n}\u003c/code>\u003c/p>\n\u003cp>注意\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>在访问一个不存在的地址时\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们要返回 404 状态码\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>一般 React router 类库已经帮我们进行了较好的封装\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>Static Router 会注入一个 context prop\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并将 context.notFound 赋值为 true\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>在 server/index.js 加入\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>const context = {}\u003cbr>\nconst html = renderer(data, req.path, context);\u003cbr>\nif (context.notFound) {\u003cbr>\n &nbsp;&nbsp;&nbsp;res.status(404)\u003cbr>\n}\u003cbr>\nres.send(html)\u003c/code>\u003c/p>\n\u003cp>即可\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>这一系列处理过程没有什么难点\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>但是这种处理意识\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>还是需要具备的\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003ch3>安全问题\u003c/h3>\n\u003cp>安全问题非常关键\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>尤其是涉及到服务端渲染\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>开发者要格外小心\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>这里提出一个点\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>我们前面提到了注水和脱水过程\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>其中的代码\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003ccode>ctx.body = `\u003cbr>\n &nbsp;\u003c!DOCTYPE html>\u003cbr>\n &nbsp;\u003chtml lang=\"en\">\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003chead>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cmeta charset=\"UTF-8\">\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/head>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003cbody>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cscript>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.context = {\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialState: ${JSON.stringify(store.getState())}\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/script>\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003cdiv id=\"app\">\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...\u003cbr>\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u003c/div>\u003cbr>\n &nbsp;&nbsp;&nbsp;\u003c/body>\u003cbr>\n &nbsp;\u003c/html>\u003cbr>\n`\u003c/code>\u003c/p>\n\u003cp>非常容易遭受 XSS 攻击\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>JSON.stringify 可能会造成 script 注入\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>因此\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们需要严格清洗 JSON 字符串中的 HTML 标签和其他危险的字符\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>我习惯使用 serialize-javascript 库进行处理\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>这也是同构应用中最容易被忽视的细节\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>这里给大家留一个思考题\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>React dangerouslySetInnerHTML API 也有类似风险\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>React 是怎么处理这个安全隐患的呢\u003cspan class=\" fw-cl \">\u003cspan>？\u003c/span>\u003c/span>\u003c/p>\n\u003ch3>性能优化\u003c/h3>\n\u003cp>我们将数据请求移到了服务端\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>但是依然要格外重视性能优化\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>目前针对于此\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>业界普遍做法包括以下几点\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cul>\n \u003cli style=\"\">使用缓存\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>服务端优化一个最重要的手段就是缓存\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>不同于传统服务端缓存措施\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们甚至可以实现组件级缓存\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>业界 walmartlabs 在这方面的实践非常多\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>且收获了较大的性能提升\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>感兴趣的读者可以找到相关技术信息\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/li>\n \u003cli style=\"\">采用 HSF 代替 HTTP\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>HSF 是 High-Speed Service Framework 的缩写\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>译为分布式的远程服务调用框架\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>对外提供服务上\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>HSF 性能远超过 HTTP\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/li>\n \u003cli style=\"\">对于服务端压力过大的场景\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>动态切换为客户端渲染\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/li>\n \u003cli style=\"\">NodeJS 升级\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/li>\n \u003cli style=\"\">React 升级\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/li>\n\u003c/ul>\n\u003cp>如图所示\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>React 16 在服务端渲染上的性能对比提升\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>\u003c/p>\n\u003cp>\u003cbr>\u003c/p>\n\u003cfigure class=\"central\">\u003cimg src=\"https://pic3.zhimg.com/v2-93ef7dcef817c7a36e1a22b84a874905.png\" alt=\"图片\" data-rawwidth=\"1600\" data-rawheight=\"987\">\u003c/figure>\n\u003cblockquote>\u003cbr>\u003c/blockquote>\n\u003cp>备注\u003cspan class=\" fw-cl \">\u003cspan>：\u003c/span>\u003c/span>图片来自 \u003ca href=\"https://hackernoon.com/whats-new-with-server-side-rendering-in-react-16-9b0d78585d67\" title=\"hacker noon\">hacker noon\u003c/a>\u003c/p>\n\u003ch3>总结\u003c/h3>\n\u003cp>本讲没有\u003cspan class=\"fw-op \">\u003cspan>「\u003c/span>\u003c/span>手把手\u003cspan class=\" fw-cl \">\u003cspan>」\u003c/span>\u003c/span>教你实现服务端渲染的同构应用\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>因为这些知识并不困难\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>社区上资料也很多\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>我们从更高的角度出发\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>剖析同构应用中那些关键的细节点和疑难问题的解决方案\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>这些经验来源于真刀真枪的线上案例\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>如果读者没有开发过同构应用\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>也能从中全方位地了解关键信息\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>一旦掌握了这些细节\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>同构应用的实现就会更稳\u003cspan class=\" fw-cl \">\u003cspan>、\u003c/span>\u003c/span>更可靠\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>同构应用其实远比理论复杂\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>绝对不是几个 APIs 和几台服务器就能完成的\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>希望大家多思考\u003cspan class=\" fw-cl \">\u003cspan>、\u003c/span>\u003c/span>多动手\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>一定会更有体会\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>另外\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>同构应用各种细节也不止于此\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>坑也不止于此\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>欢迎大家和我讨论\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003ch3>分享交流\u003c/h3>\n\u003cp>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>或者直接向作者 LucasHC 提问\u003cspan class=\"fw-op \">\u003cspan>（\u003c/span>\u003c/span>作者看到后抽空回复\u003cspan class=\" fw-cl fw--collapsed\">\u003cspan>）\u003c/span>\u003c/span>\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003cstrong style=\"\">你的分享不仅帮助他人\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>更会提升自己\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/strong>\u003c/p>\n\u003cp>你也可以说说自己最想了解的主题\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>课程内容会根据部分读者的意见和建议迭代和完善\u003cspan class=\" fw-cl \">\u003cspan>。\u003c/span>\u003c/span>\u003c/p>\n\u003cp>此外\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>我们为本课程付费读者创建了\u003cspan class=\"fw-op \">\u003cspan>《\u003c/span>\u003c/span>前端开发核心知识进阶\u003cspan class=\" fw-cl \">\u003cspan>》\u003c/span>\u003c/span>微信交流群\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>以方便更有针对性地讨论课程相关问题\u003cspan class=\"fw-op \">\u003cspan>（\u003c/span>\u003c/span>入群请到第 1-2 课末尾添加 GitChat 小助手伽利略的微信\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>并注明\u003cspan class=\"fw-op \">\u003cspan>「\u003c/span>\u003c/span>前端核心\u003cspan class=\" fw-cl fw--collapsed\">\u003cspan>」\u003c/span>\u003c/span>\u003cspan class=\" fw-cl \">\u003cspan>，\u003c/span>\u003c/span>谢谢~\u003cspan class=\" fw-cl \">\u003cspan>）\u003c/span>\u003c/span>\u003c/p>\u003cp>\u003cspan style=\"display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);\">备案号:YXX1p6PmGY5tXLQyEwI5olY\u003c/span>\u003c/p>","audio":null,"is_fold":false,"has_like":false,"has_oppose":false,"like_count":2,"comment_count":0,"share":{"title":"同构应用中你所忽略的细节","description":"同构应用中你所忽略的细节","artwork":"https://picx.zhimg.com/v2-25910174b3cb3d895c86405207c91401.png?source=f65c3faf","url":"https://www.zhihu.com/market/paid_column/1167078439772721152/section/1169971710572367872?is_share_data=true"},"next_section":{"id":"1169972844762206208","title":"从框架和类库，我们该学到什么","url":"https://www.zhihu.com/market/paid_column/1167078439772721152/section/1169972844762206208","is_end":false},"head_artwork":null,"learn_progress":{"progress":0,"is_finished":false},"section_type":"article","sku_right_type":"svip_free","truncate_text":"最低 0.3 元/天开通会员，查看完整内容","svip_right_card":{"day":"https://pic3.zhimg.com/v2-4ed2fd42766dbac1ba5cffa1d7a01638.png","night":"https://pic4.zhimg.com/v2-1b83a176355a5370778dc7c5c14b9c62.png"},"related_labels":[],"main_character":"","on_shelves":true,"section_on_shelves":true,"right":{"ownership":true,"purchased":false,"anonymous":false},"pTagList":[]},"moreInformationData":{"share_records":[{"section_id":1563866763892338700,"title":"有没有虐文催泪的那种?","url":"https://www.zhihu.com/market/paid_column/1480182785314394112/section/1563866763892338689?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"结婚第五年纪念日 ， 许嘉年说要给我一个盛大的婚礼 。\n\n他说他特别遗憾当年结婚时没有给我一场婚礼 ， 他说我一定是最美的新娘 。\n\n然后婚礼当天 ， 他收到一条短信 ， 匆匆忙忙地跑了 。\n\n我穿着","artwork":"","is_read":false},{"section_id":1368261744087957500,"title":"有哪些根据真实犯罪故事改编的电影？","url":"https://www.zhihu.com/market/paid_column/1365688702828765184/section/1368261744087957504?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"1\n\n2008 年 4 月 29 日 ， 香港新界北失踪人口调查组接到了一件看似很普通的报案 。\n\n失踪的是个 16 岁的少女 ， 前来报案的是她的母亲和 19 岁的姐姐 。 母女俩焦急地告诉警员 ，","artwork":"","is_read":false},{"section_id":1556645118949412900,"title":"有没有青梅竹马追妻火葬场的小说?","url":"https://www.zhihu.com/market/paid_column/1489624547859505152/section/1556645118949412864?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"穿书十年 ， 我用了七年攻略男二反派大魔头无果 。\n\n他的心中只有纯白如月光的女主 。\n\n于是我用了三年和他道别 ， 从此在心中彻底放下他 。\n\n可是他却好像再也不能放下了 。\n\n1.\n\n「 云荣受伤","artwork":"","is_read":false},{"section_id":1540708067771072500,"title":"在自己家公司上班是什么感觉？","url":"https://www.zhihu.com/market/paid_column/1533512394957021184/section/1540708067771072512?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"跟男朋友进了同一家公司实习 。\n\n同部门的学姐一直暗示他分手 ， 说我没钱没靠山 ， 会耽误他的前途 。\n\n我 ： ？\n\n公司都是我爸的 。\n\n明天我就让他继承皇位 。\n\n1\n\n男朋友第八次被学姐叫去","artwork":"","is_read":false},{"section_id":1578072225504264200,"title":"姐妹们见过最心狠手辣的女主是谁？（最近想看点刺激的）？","url":"https://www.zhihu.com/market/paid_column/1470907509230239744/section/1578072225504264192?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"1\n\n赵小婵出生的时候 ， 家里也是富过的 。\n\n她爹赵明义是个二世祖 ， 对于女儿的出生 ， 既不高兴 ， 也不难过 。\n\n闺女出生那天 ， 烈日当头 ， 外面的蝉鸣声吵得烦死个人 。\n\n赵明义也没","artwork":"","is_read":false},{"section_id":1396516846212792300,"title":"什么样的女人才是聪明女人？","url":"https://www.zhihu.com/market/paid_column/1386393729327116288/section/1396516846212792320?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"我和我老公在一起 ， 不是因为他有多优秀 ， 而是因为他对我好 。\n\n我以为我会一直被宠下去 。\n\n结果一个月前 ， 一个陌生人的微信加我 ， 给我发了张照片 。\n\n照片里的男人 ， 切着一个金黄色的","artwork":"","is_read":false},{"section_id":1553715330438140000,"title":"是什么样的鬼故事吓了你十几年？","url":"https://www.zhihu.com/market/paid_column/1487743293379670017/section/1553715330438139905?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"妹妹的尸体 ， 是在家里的抽屉里被发现的 。\n\n她整个身体被压缩成一个肉块 ， 塞在了抽屉里 。\n\n但她却留下了一个线索 ：\n\n小心家里多出来的那个妈妈 。\n\n01\n\n妹妹离家后的第三天 。\n\n家里的","artwork":"","is_read":false},{"section_id":1588190659995029500,"title":"有什么大快人心的复仇故事？","url":"https://www.zhihu.com/market/paid_column/1584194746330796032/section/1588190659995029504?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"我向上天许愿 ， 我想变成女生 ， 变成霸凌我的那个人的理想型女生 。\n\n让他爱上我 ， 为我痴狂 ， 为我疯魔 。\n\n这样 ， 我就能轻易毁掉他光明灿烂的人生了 。\n\n1\n\n小时候我很喜欢看 《 哆","artwork":"","is_read":false},{"section_id":1431756526964490200,"title":"国考和省考公务员薪资待遇真的有天壤之别吗？","url":"https://www.zhihu.com/market/paid_column/1424430624366698499/section/1431756526964490240?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"国考与省考有什么区别 ？ 怎么报名 、 什么时候报名 ？ 如何选择岗位才能提高上岸率 ？ 本文都将一一为你解答 。\n\n*一 、 个人背景介绍*\n\n上岸年龄 ： 32 岁 。\n\n上岸成绩 ： 行测 78","artwork":"","is_read":false},{"section_id":1571909212002889700,"title":"有哪些好看的女主爽文？","url":"https://www.zhihu.com/market/paid_column/1569379904310890497/section/1571909212002889728?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"幼弟受封世子的第二天 ， 夺了我的掌家权 ， 还把我许给了一个痴肥的傻子 。\n\n他说我本就是过继来的农家女 ， 从血到肉都下贱无比 ， 根本不配做他长姐 。 只有二房嫡女才是侯府真正的小姐 ， 他真正","artwork":"","is_read":false},{"section_id":1551216533984260000,"title":"有没有女主人间清醒的小说？","url":"https://www.zhihu.com/market/paid_column/1545060110682230784/section/1551216533984260096?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"陆子宸在酒吧泡妞 ， 叫我去付钱 。\n\n三年来 ， 我陆陆续续在他身上花了 1000 万 。\n\n他给我没买过一杯奶茶 。\n\n他觉得我是他的舔狗 ， 这辈子想让我怎样 ， 我就会怎样 。\n\n直到我听到脑","artwork":"","is_read":false},{"section_id":1583882091246370800,"title":"你有哪些绝妙的反击？","url":"https://www.zhihu.com/market/paid_column/1581708871797743616/section/1583882091246370816?marketing_token=null&member_code=Q44ZYN&is_share_data=true&vp_share_title=0","description":"我是恶毒女配 ， 但我摆烂了 。\n\n因为只要我努力 ， 女主就能获得美颜加成 。\n\n嘿 ， 那我专心开摆 ， 女主面目可憎指日可待 。\n\n1\n\n我偶然发现 ：\n\n只要我熬夜苦干 ， 柳依依就光彩焕发 ","artwork":"","is_read":false}],"next_page_url":"/slytherin/task/member_recommand?page=0&limit=12&token=null&section_id=0"},"annotationsData":{}},"error":null}},"self":{"type":"people","user_type":"people","id":"3e3ca09c9310955765cf24d9860888a6","url":"https://api.zhihu.com/people/3e3ca09c9310955765cf24d9860888a6","name":"会飞的鱼","url_token":"49952","headline":"混迹职场，希望一生如鱼得水！","avatar_url":"https://pic1.zhimg.com/v2-396f760fc224757bdaf0bf39178fdf7e_l.jpg?source=8c5c7284","gender":1,"actived":1670464665,"subscriptions":[{"id":"4","real_id":"4","appellation":"尊敬的盐选会员","name":"svip","real_name":"svip","has_checked_in":false,"title":"盐选会员","checked_in_days":0,"is_active":true,"rank":null,"alert":"盐选会员剩余 28 天到期","show_recharge_notic":true,"contract_id":null,"checked_in_url":"https://www.zhihu.com/remix/instabooks","expires_at":1676044799,"available_at":1673345684,"is_expired":false,"package_list":[]}],"is_new":false,"member_rights":[{"status":"active","alert":"盐选会员 2023.02.10 到期","expire_at":1676044799,"available_at":1673345684,"type":"svip","icon":{"day":"https://picx.zhimg.com/v2-034fefe15c83232cb448718998719d34.png?source=8c5c7284","night":"https://picx.zhimg.com/v2-c9686ff064ea3579730756ac6c289978.png?source=8c5c7284"},"real_type":"svip"}],"has_speaker_admin_permission":false,"is_following_mp_wechat":false,"is_bind_phone":true,"is_unicom_free":false,"from":"go","button_bubble":""},"readSetting":{},"isKocPage":false,"isShareAbConfig":false}}```