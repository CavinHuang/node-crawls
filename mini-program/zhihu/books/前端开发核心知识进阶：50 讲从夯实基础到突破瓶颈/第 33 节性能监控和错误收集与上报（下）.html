<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>第 33 节性能监控和错误收集与上报（下）</h1>
  <p>上一节课我们学习了性能监控方面的知识<span class=" fw-cl "><span>。</span></span>这一节来深入了解关于错误和异常的收集<span class=" fw-cl "><span>，</span></span>并学习如何统一将这些信息进行上报<span class=" fw-cl "><span>。</span></span></p>
<p>在此之前<span class=" fw-cl "><span>，</span></span>我们先回顾一下这个主题的知识点<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-77e87ff3f31131eea915011461a63ec1.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:59.33412604042806% 0" data-src="https://pic3.zhimg.com/v2-77e87ff3f31131eea915011461a63ec1.png">加载中...</span></figure>
<h3>错误信息收集</h3>
<p>提到错误收集方案<span class=" fw-cl "><span>，</span></span>大家应该会首先想到两种<span class=" fw-cl "><span>：</span></span>try catch 捕获错误和 window.onerror 监听<span class=" fw-cl "><span>。</span></span></p>
<h4>认识 try catch 方案</h4>
<p>我们先看一下 try catch 方案<span class=" fw-cl "><span>：</span></span></p>
<p><code>try {<br>
 &nbsp;&nbsp;&nbsp;// 代码块<br>
} catch(e) {<br>
 &nbsp;&nbsp;&nbsp;// 错误处理<br>
 &nbsp;&nbsp;&nbsp;// 在这里<span class=" fw-cl "><span>，</span></span>我们可以将错误信息发送给服务端<br>
}</code></p>
<p>这种方式需要开发者对预估有错误风险的代码进行包裹<span class=" fw-cl "><span>，</span></span>这个包裹过程可以手动添加<span class=" fw-cl "><span>，</span></span>也可以通过自动化工具或类库完成<span class=" fw-cl "><span>。</span></span>自动化方案的基本原理是 AST 技术<span class=" fw-cl "><span>：</span></span>比如 UglifyJS 就提供操作 AST 的 API<span class=" fw-cl "><span>，</span></span>我们可以对每个函数添加 try catch<span class=" fw-cl "><span>，</span></span>社区上 <a href="https://github.com/foio/try-catch-global.js/blob/master/try-catch-global.js" title="foio">foio</a> 的实现<span class=" fw-cl "><span>，</span></span>就是一个很好的例子<span class=" fw-cl "><span>：</span></span></p>
<p><code>const fs = require('fs')<br>
const _ = require('lodash')<br>
const UglifyJS = require('uglify-js')<br>
<br>
const isASTFunctionNode = &nbsp;node =&gt; node instanceof UglifyJS.AST_Defun || node instanceof UglifyJS.AST_Function<br>
​ &nbsp;&nbsp;<br>
const globalFuncTryCatch = (source, errorHandler) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;if (!_.isFunction(errorHandler)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw 'errorHandler should be a valid function'<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;const errorHandlerSource = errorHandler.toString()<br>
 &nbsp;&nbsp;&nbsp;const errorHandlerAST = UglifyJS.parse('(' + errorHandlerSource + ')(error);')<br>
 &nbsp;&nbsp;&nbsp;var tryCatchAST = UglifyJS.parse('try{}catch(error){}')<br>
 &nbsp;&nbsp;&nbsp;const sourceAST = UglifyJS.parse(source)<br>
 &nbsp;&nbsp;&nbsp;var topFuncScope = []<br>
<br>
 &nbsp;&nbsp;&nbsp;tryCatchAST.body[0].catch.body[0] = errorHandlerAST<br>
<br>
 &nbsp;&nbsp;&nbsp;const walker = new UglifyJS.TreeWalker(function (node) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isASTFunctionNode(node)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topFuncScope.push(node)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;})<br>
 &nbsp;&nbsp;&nbsp;sourceAST.walk(walker)<br>
 &nbsp;&nbsp;&nbsp;sourceAST.transform(transfer)<br>
<br>
 &nbsp;&nbsp;&nbsp;const transfer = new UglifyJS.TreeTransformer(null,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isASTFunctionNode(node) &amp;&amp; _.includes(topFuncScope, node)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var stream = UglifyJS.OutputStream()<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; node.body.length; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.body[i].print(stream)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var innerFuncCode = stream.toString()<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tryCatchAST.body[0].body.splice(0, tryCatchAST.body[0].body.length)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var innerTyrCatchNode = UglifyJS.parse(innerFuncCode, {toplevel: tryCatchAST.body[0]})<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.body.splice(0, node.body.length)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return UglifyJS.parse(innerTyrCatchNode.print_to_string(), {toplevel: node});<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>
 &nbsp;&nbsp;&nbsp;const outputCode = sourceAST.print_to_string({beautify: true})<br>
 &nbsp;&nbsp;&nbsp;return outputCode<br>
}<br>
<br>
module.exports.globalFuncTryCatch = globalFuncTryCatch</code></p>
<p>我们从 globalFuncTryCatch 函数的第一个参数中获得目标代码 source<span class=" fw-cl "><span>，</span></span>将其转换为 AST<span class=" fw-cl "><span>：</span></span></p>
<p><code>const sourceAST = UglifyJS.parse(source)</code></p>
<p>globalFuncTryCatch 函数的第二个参数为开发者定义的在出现错误时的响应函数<span class=" fw-cl "><span>，</span></span>我们将其字符串化并转为 AST<span class=" fw-cl "><span>，</span></span>并插入到 catch 块当中<span class=" fw-cl "><span>：</span></span></p>
<p><code>var tryCatchAST = UglifyJS.parse('try{}catch(error){}')<br>
const errorHandlerSource = errorHandler.toString()<br>
const errorHandlerAST = UglifyJS.parse('(' + errorHandlerSource + ')(error);')<br>
tryCatchAST.body[0].catch.body[0] = errorHandlerAST</code></p>
<p>这样<span class=" fw-cl "><span>，</span></span>借助于 globalFuncTryCatch<span class=" fw-cl "><span>，</span></span>我们可以对每个函数添加 try catch 语句<span class=" fw-cl "><span>，</span></span>并根据 globalFuncTryCatch 的第二个参数<span class=" fw-cl "><span>，</span></span>传入自定义的错误处理函数<span class="fw-op  "><span>（</span></span>可以在该函数中进行错误上报<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>：</span></span></p>
<p><code>globalFuncTryCatch(inputCode, function (error) {<br>
 &nbsp;&nbsp;&nbsp;// 此处是异常处理代码<span class=" fw-cl "><span>，</span></span>可以上报并记录日志<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
})</code></p>
<p>关键之处在于使用 UglifyJS 的能力<span class=" fw-cl "><span>，</span></span>对 AST 语法树进行遍历<span class=" fw-cl "><span>，</span></span>并转换<span class=" fw-cl "><span>：</span></span></p>
<p><code>const walker = new UglifyJS.TreeWalker(function (node) {<br>
 &nbsp;&nbsp;&nbsp;if (isASTFunctionNode(node)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topFuncScope.push(node)<br>
 &nbsp;&nbsp;&nbsp;}<br>
})<br>
sourceAST.walk(walker)<br>
sourceAST.transform(transfer)</code></p>
<p>最终再返回经过处理后的代码<span class=" fw-cl "><span>：</span></span></p>
<p><code>const outputCode = sourceAST.print_to_string({beautify: true})<br>
return outputCode</code></p>
<p>使用 try catch<span class=" fw-cl "><span>，</span></span>我们可以保证页面不崩溃<span class=" fw-cl "><span>，</span></span>并对错误进行兜底处理<span class=" fw-cl "><span>，</span></span>这是一个非常好的习惯<span class=" fw-cl "><span>。</span></span></p>
<h4>try catch 方案的局限性</h4>
<p>但是 try catch 处理异常的能力有限<span class=" fw-cl "><span>，</span></span>对于运行时非异步错误<span class=" fw-cl "><span>，</span></span>它并没有问题<span class=" fw-cl "><span>。</span></span>但是对于<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">语法错误</li>
  <li style="">异步错误</li>
</ul>
<p>try catch 就无法 cover 了<span class=" fw-cl "><span>。</span></span>我们来看一个运行时非异步错误<span class=" fw-cl "><span>：</span></span></p>
<p><code>try {<br>
 &nbsp;&nbsp;&nbsp;a // 未定义变量 <br>
} catch(e) {<br>
 &nbsp;&nbsp;&nbsp;console.log(e)<br>
}</code></p>
<p>可以被 try catch 处理<span class=" fw-cl "><span>。</span></span>但是<span class=" fw-cl "><span>，</span></span>将上述代码改动为语法错误<span class=" fw-cl "><span>：</span></span></p>
<p><code>try {<br>
 &nbsp;&nbsp;&nbsp;var a =\ 'a'<br>
} catch(e) {<br>
 &nbsp;&nbsp;&nbsp;console.log(e);<br>
}</code></p>
<p>就无法捕获<span class=" fw-cl "><span>。</span></span></p>
<p>我们再看一下异步的情况<span class=" fw-cl "><span>：</span></span></p>
<p><code>try {<br>
 &nbsp;&nbsp;&nbsp;setTimeout(() =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a<br>
 &nbsp;&nbsp;&nbsp;})<br>
} catch(e) {<br>
 &nbsp;&nbsp;&nbsp;console.log(e)<br>
}</code></p>
<p>也无法捕获<span class=" fw-cl "><span>。</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-b55f6c2ea953ff970bf9915ccedca2d5.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:22.5201072386059% 0" data-src="https://pic4.zhimg.com/v2-b55f6c2ea953ff970bf9915ccedca2d5.png">加载中...</span></figure>
<p>除非在 setTimeout 中再加一层 try catch<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-ebcf0daf4494144a2025005b0a77c2c2.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:37.06070287539936% 0" data-src="https://pic1.zhimg.com/v2-ebcf0daf4494144a2025005b0a77c2c2.png">加载中...</span></figure>
<p>总结一下<span class=" fw-cl "><span>，</span></span><strong style="">try catch 能力有限<span class=" fw-cl "><span>，</span></span>且对于代码的侵入性较强<span class=" fw-cl "><span>。</span></span></strong></p>
<h4>认识 window.onerror</h4>
<p>我们再看一下 window.onerror 对错误进行处理的方案<span class=" fw-cl "><span>：</span></span>开发者只需要给 window 添加 onerror 事件监听<span class=" fw-cl "><span>，</span></span>同时<strong style="">注意需要将 window.onerror 放在所有脚本之前<span class=" fw-cl "><span>，</span></span>这样才能对语法异常和运行异常进行处理<span class=" fw-cl "><span>。</span></span></strong></p>
<p><code>window.onerror = function (message, source, lineno, colno, error) { <br>
 &nbsp;&nbsp;&nbsp;// ... <br>
}</code></p>
<p>这里的参数较为重要<span class=" fw-cl "><span>，</span></span>包含稍后需要上传的信息<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">mesage 为错误信息提示</li>
  <li style="">source 为错误脚本地址</li>
  <li style="">lineno 为错误的代码所在行号</li>
  <li style="">colno 为错误的代码所在列号</li>
  <li style="">error 为错误的对象信息<span class=" fw-cl "><span>，</span></span>比如 error.stack 获取错误的堆栈信息</li>
</ul>
<p>window.onerror 这种方式对代码侵入性较小<span class=" fw-cl "><span>，</span></span>也就不必涉及 AST 自动插入脚本<span class=" fw-cl "><span>。</span></span>除了对语法错误和网络错误<span class="fw-op  "><span>（</span></span>因为<strong style="">网络请求异常不会事件冒泡</strong><span class=" fw-cl "><span>）</span></span>无能为力以外<span class=" fw-cl "><span>，</span></span>无论是异步还是非异步<span class=" fw-cl "><span>，</span></span>onerror 都能捕获到运行时错误<span class=" fw-cl "><span>。</span></span></p>
<p>但是需要注意的是<span class=" fw-cl "><span>，</span></span>如果想使用 window.onerror 函数消化错误<span class=" fw-cl "><span>，</span></span>需要显示返回 true<span class=" fw-cl "><span>，</span></span>以保证错误不会向上抛出<span class=" fw-cl "><span>，</span></span>控制台也就不会看到一堆错误提示<span class=" fw-cl "><span>。</span></span></p>
<h4>跨域脚本的错误处理</h4>
<p>千万不要以为掌握了这些<span class=" fw-cl "><span>，</span></span>就万事大吉了<span class=" fw-cl "><span>。</span></span>现实场景多种多样<span class=" fw-cl "><span>，</span></span>比如<strong style="">一种情况是<span class=" fw-cl "><span>：</span></span>加载不同域的 JavaScript 脚本</strong><span class=" fw-cl "><span>，</span></span>这样的场景较为常见<span class=" fw-cl "><span>，</span></span>比如加载第三方内容<span class=" fw-cl "><span>，</span></span>以展示广告<span class=" fw-cl "><span>，</span></span>进行性能测试<span class=" fw-cl "><span>、</span></span>错误统计<span class=" fw-cl "><span>，</span></span>或者想用第三方服务等<span class=" fw-cl "><span>。</span></span></p>
<p>对于不同域的 JavaScript 文件<span class=" fw-cl "><span>，</span></span>window.onerror 不能保证获取有效信息<span class=" fw-cl "><span>。</span></span>由于安全原因<span class=" fw-cl "><span>，</span></span>不同浏览器返回的错误信息参数可能并不一致<span class=" fw-cl "><span>。</span></span>比如<span class=" fw-cl "><span>，</span></span>跨域之后 window.onerror 在很多浏览器中是无法捕获异常信息的<span class=" fw-cl "><span>，</span></span>要统一返回 Script error<span class=" fw-cl "><span>，</span></span>这就需要 script 脚本设置为<span class=" fw-cl "><span>：</span></span></p>
<p><code>crossorigin="anonymous"</code></p>
<p>同时服务器添加 Access-Control-Allow-Origin 以指定允许哪些域的请求访问<span class=" fw-cl "><span>。</span></span></p>
<h4>使用 source map 进行错误还原</h4>
<p>到目前为止<span class=" fw-cl "><span>，</span></span>我们已经学习了获取错误信息的<span class="fw-op  "><span>「</span></span>十八般武艺<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>但是<span class=" fw-cl "><span>，</span></span>如果错误脚本是经过压缩的<span class=" fw-cl "><span>，</span></span>那么纵使你有千般本领<span class=" fw-cl "><span>，</span></span>也无用武之地了<span class=" fw-cl "><span>，</span></span>因为这样捕获到的错误信息的位置<span class="fw-op  "><span>（</span></span>行列号<span class=" fw-cl "><span>）</span></span>就会出现较大偏差<span class=" fw-cl "><span>，</span></span>错误代码也经过压缩而难以辨认<span class=" fw-cl "><span>。</span></span>这时候就需要启用 source map<span class=" fw-cl "><span>。</span></span>很多构建工具都支持 source map<span class=" fw-cl "><span>，</span></span>比如我们利用 webpack 打包压缩生成的一份对应脚本的 map 文件进行追踪<span class=" fw-cl "><span>，</span></span>在 webpack 中开启 source map 功能<span class=" fw-cl "><span>：</span></span></p>
<p><code>module.exports = {<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;devtool: '#source-map',<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
}</code></p>
<p>更多 source map 的内容<span class=" fw-cl "><span>，</span></span>感兴趣的读者还可以参考以下资料<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style=""><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" title="JavaScript Source Map 详解">JavaScript Source Map 详解</a></li>
  <li style=""><a href="https://webpack.js.org/guides/development/#using-source-maps" title="Using source maps">Using source maps</a></li>
</ul>
<p>Webpack sourcemap 这里不是我们的重点<span class=" fw-cl "><span>，</span></span>就不再展开<span class=" fw-cl "><span>。</span></span></p>
<h4>对 Promise 错误处理</h4>
<p><strong style="">我们再来看一下针对 Promise 的错误收集与处理</strong><span class=" fw-cl "><span>。</span></span>我们都提倡养成写 Promise 的时候最后写上 catch 函数的习惯<span class=" fw-cl "><span>。</span></span>ESLint 插件 eslint-plugin-promise 会帮我们完成这项工作<span class=" fw-cl "><span>，</span></span>使用规则<span class=" fw-cl "><span>：</span></span>catch-or-return 来保障代码中所有的 promise<span class="fw-op  "><span>（</span></span>被显式返回的除外<span class=" fw-cl "><span>）</span></span>都有相应的 catch 处理<span class=" fw-cl "><span>。</span></span>比如这样的写法<span class=" fw-cl "><span>：</span></span></p>
<p><code>var p = new Promise()<br>
p.then(fn1)<br>
p.then(fn1, fn2)<br>
function fn1() {<br>
 &nbsp;&nbsp;&nbsp;p.then(doSomething)<br>
}</code></p>
<p>是无法通过代码检查的<span class=" fw-cl "><span>。</span></span></p>
<p>这类 ESLint 插件基于 AST 实现<span class=" fw-cl "><span>，</span></span>逻辑也很简单<span class=" fw-cl "><span>：</span></span></p>
<p><code>module.exports = {<br>
 &nbsp;meta: {<br>
 &nbsp;&nbsp;&nbsp;docs: {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;},<br>
 &nbsp;&nbsp;&nbsp;messages: {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;},<br>
 &nbsp;create(context) {<br>
 &nbsp;&nbsp;&nbsp;const options = context.options[0] || {}<br>
 &nbsp;&nbsp;&nbsp;const allowThen = options.allowThen<br>
 &nbsp;&nbsp;&nbsp;let terminationMethod = options.terminationMethod || 'catch'<br>
<br>
 &nbsp;&nbsp;&nbsp;if (typeof terminationMethod === 'string') {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminationMethod = [terminationMethod]<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;return {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExpressionStatement(node) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!isPromise(node.expression)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowThen &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.type === 'CallExpression' &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.callee.type === 'MemberExpression' &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.callee.property.name === 'then' &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.arguments.length === 2<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.type === 'CallExpression' &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.callee.type === 'MemberExpression' &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminationMethod.indexOf(node.expression.callee.property.name) !== -1<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.type === 'CallExpression' &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.callee.type === 'MemberExpression' &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.callee.property.type === 'Literal' &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.expression.callee.property.value === 'catch'<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.report({<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;messageId: 'terminationMethod',<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data: { terminationMethod }<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;}<br>
}</code></p>
<p>如果读者对于 AST 和 ESLint 相关内容感兴趣<span class=" fw-cl "><span>，</span></span>请关注课程<span class="fw-op  "><span>《</span></span>代码风格规范和背后技术设计<span class=" fw-cl fw--collapsed"><span>》</span></span><span class=" fw-cl "><span>，</span></span>会展开分析这方面的话题<span class=" fw-cl "><span>。</span></span></p>
<p>可能大家会想到<span class=" fw-cl "><span>，</span></span>promise 实例的 then 方法中的第二个 onRejected 函数也能处理错误<span class=" fw-cl "><span>，</span></span>这个和上面提到的 catch 方法有什么差别呢<span class=" fw-cl "><span>？</span></span>事实上<span class=" fw-cl "><span>，</span></span>我更加推荐 catch 方法<span class=" fw-cl "><span>，</span></span>请看下面代码<span class=" fw-cl "><span>：</span></span></p>
<p><code>new Promise((resolve, reject) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;throw new Error()<br>
}).then( () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log('resolved')<br>
}, err =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log('rejected')<br>
 &nbsp;&nbsp;&nbsp;throw err<br>
}).catch(err =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log(err, 'catch')<br>
})</code></p>
<p>输出<span class=" fw-cl "><span>：</span></span>rejected<span class=" fw-cl "><span>，</span></span>在有 onRejected 的情况下<span class=" fw-cl "><span>，</span></span>onRejected 发挥作用<span class=" fw-cl "><span>，</span></span>catch 并未被调用<span class=" fw-cl "><span>。</span></span> 而当<span class=" fw-cl "><span>：</span></span></p>
<p><code>new Promise((resolve, reject) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;resolve()<br>
}).then(() =&gt; {<br>
 &nbsp;&nbsp;&nbsp;throw new Error()<br>
 &nbsp;&nbsp;&nbsp;console.log('resolved')<br>
}, err =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log('rejected')<br>
 &nbsp;&nbsp;&nbsp;throw err<br>
}).catch(err =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log(err, 'catch')<br>
})</code></p>
<p>输出<span class=" fw-cl "><span>：</span></span><code>VM705:10 Error at Promise.then (<anonymous>:4:9) "catch"</anonymous></code><span class=" fw-cl "><span>，</span></span>此时 onRejected 并不能捕获 then 方法中第一个参数 onResolved 函数中的错误<span class=" fw-cl "><span>。</span></span>一经对比<span class=" fw-cl "><span>，</span></span>也许 catch 是进行错误处理更好的选择<span class=" fw-cl "><span>。</span></span>但是<span class=" fw-cl "><span>，</span></span>这两种方式各有特点<span class=" fw-cl "><span>，</span></span>还是需要读者对 Promise 有较为深入的认识<span class=" fw-cl "><span>。</span></span></p>
<p>除此之外<span class=" fw-cl "><span>，</span></span>对于 Promise 的错误处理<span class=" fw-cl "><span>，</span></span>我们还可以注册对 Promise 全局异常的捕获事件 unhandledrejection<span class=" fw-cl "><span>：</span></span></p>
<p><code>window.addEventListener("unhandledrejection", &nbsp;e =&gt; {<br>
 &nbsp;&nbsp;&nbsp;e.preventDefault()<br>
 &nbsp;&nbsp;&nbsp;console.log(e.reason)<br>
 &nbsp;&nbsp;&nbsp;return true<br>
})</code></p>
<p>这对于集中管理和错误收集更加友好<span class=" fw-cl "><span>。</span></span></p>
<h4>处理网络加载错误</h4>
<p>前面介绍的处理方式都是对已经在浏览器端的脚本逻辑错误进行的<span class=" fw-cl "><span>，</span></span>我们设想用 script 标签<span class=" fw-cl "><span>，</span></span>link 标签进行脚本或者其他资源加载时<span class=" fw-cl "><span>，</span></span>由于某种原因<span class="fw-op  "><span>（</span></span>可能是服务器错误<span class=" fw-cl "><span>，</span></span>也可能是网络不稳定<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>导致了脚本请求失败<span class=" fw-cl "><span>，</span></span>网络加载错误<span class=" fw-cl "><span>。</span></span></p>
<p><code><script src="***.js"></script><br>
<link rel="stylesheet" href="***.css"></code></p>
<p>为了捕获这些加载异常<span class=" fw-cl "><span>，</span></span>我们可以<span class=" fw-cl "><span>：</span></span></p>
<p><code><script src="***.js" &nbsp;onerror="errorHandler(this)"></script><br>
<link rel="stylesheet" href="***.css" onerror="errorHandler(this)"></code></p>
<p>除此之外<span class=" fw-cl "><span>，</span></span>也可以使用 window.addEventListener('error') 方式对加载异常进行处理<span class=" fw-cl "><span>，</span></span>注意这时候我们无法使用 window.onerror 进行处理<span class=" fw-cl "><span>，</span></span><strong style="">因为 window.onerror 事件是通过事件冒泡获取 error 信息的<span class=" fw-cl "><span>，</span></span>而网络加载错误是不会进行事件冒泡的<span class=" fw-cl "><span>。</span></span></strong></p>
<p>这里多提一下<span class=" fw-cl "><span>，</span></span><strong style="">不支持冒泡的事件还有</strong><span class=" fw-cl "><span>：</span></span>鼠标聚焦 / 失焦<span class="fw-op  "><span>（</span></span>focus / blur<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>、</span></span>鼠标移动相关事件<span class="fw-op  "><span>（</span></span>mouseleave / mouseenter<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>、</span></span>一些 UI 事件<span class="fw-op  "><span>（</span></span>如 scroll<span class=" fw-cl "><span>、</span></span>resize 等<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span></p>
<p>因此<span class=" fw-cl "><span>，</span></span>我们也就知道 <strong style="">window.addEventListener 不同于 window.onerror<span class=" fw-cl "><span>，</span></span>它通过事件捕获获取 error 信息<span class=" fw-cl "><span>，</span></span>从而可以对网络资源的加载异常进行处理<span class=" fw-cl "><span>：</span></span></strong></p>
<p><code>window.addEventListener('error', error =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log(error)<br>
}, true)</code></p>
<p><strong style="">那么<span class=" fw-cl "><span>，</span></span>怎么区分网络资源加载错误和其他一般错误呢</strong><span class=" fw-cl "><span>？</span></span>这里有个小技巧<span class=" fw-cl "><span>，</span></span>普通错误的 error 对象中会有一个 error.message 属性<span class=" fw-cl "><span>，</span></span>表示错误信息<span class=" fw-cl "><span>，</span></span>而资源加载错误对应的 error 对象却没有<span class=" fw-cl "><span>，</span></span>因此可以根据下面代码进行判断<span class=" fw-cl "><span>：</span></span></p>
<p><code>window.addEventListener('error', error =&gt; {<br>
 &nbsp;&nbsp;&nbsp;if (!error.message) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 网络资源加载错误<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(error)<br>
 &nbsp;&nbsp;&nbsp;}<br>
}, true)</code></p>
<p>但是<span class=" fw-cl "><span>，</span></span>也因为没有 error.message 属性<span class=" fw-cl "><span>，</span></span>我们也就没有额外信息获取具体加载的错误细节<span class=" fw-cl "><span>，</span></span>现阶段也无法具体区分加载的错误类别<span class=" fw-cl "><span>：</span></span>比如是 404 资源不存在还是服务端错误等<span class=" fw-cl "><span>，</span></span>只能配合后端日志进行排查<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">到这里<span class=" fw-cl "><span>，</span></span>我们简单做一个总结<span class=" fw-cl "><span>，</span></span>分析 window.onerror 和 window.addEventListener('error') 的区别<span class=" fw-cl "><span>。</span></span></strong></p>
<ul>
  <li style="">window.onerror 需要进行函数赋值<span class=" fw-cl "><span>：</span></span>window.onerror = function() {//...}<span class=" fw-cl "><span>，</span></span>因此重复声明后会被替换<span class=" fw-cl "><span>，</span></span>后续赋值会覆盖之前的值<span class=" fw-cl "><span>。</span></span>这是一个弊端<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>请看下图示例<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-768caae6b73c828256b4028fe0055407.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:12.131147540983607% 0" data-src="https://pic1.zhimg.com/v2-768caae6b73c828256b4028fe0055407.png">加载中...</span></figure>
<ul>
  <li style="">而 window.addEventListener('error') 可以绑定多个回调函数<span class=" fw-cl "><span>，</span></span>按照绑定顺序依次执行<span class=" fw-cl "><span>，</span></span>请看下图示例<span class=" fw-cl "><span>：</span></span></li>
</ul>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-fb7da0212ce983c480bc68e35c4852b6.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:13.360655737704919% 0" data-src="https://pic1.zhimg.com/v2-fb7da0212ce983c480bc68e35c4852b6.png">加载中...</span></figure>
<h4>页面崩溃收集和处理</h4>
<p>一个成熟的系统还需要收集崩溃和卡顿<span class=" fw-cl "><span>，</span></span>对此我们可以监听 window 对象的 load 和 beforeunload 事件<span class=" fw-cl "><span>，</span></span>并结合 sessionStorage 对网页崩溃实施监控<span class=" fw-cl "><span>：</span></span></p>
<p><code>window.addEventListener('load', () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;sessionStorage.setItem('good_exit', 'pending')<br>
})<br>
<br>
window.addEventListener('beforeunload', () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;sessionStorage.setItem('good_exit', 'true')<br>
})<br>
<br>
if(sessionStorage.getItem('good_exit') &amp;&amp;<br>
 &nbsp;&nbsp;&nbsp;sessionStorage.getItem('good_exit') !== 'true') {<br>
 &nbsp;&nbsp;&nbsp;// 捕获到页面崩溃<br>
}</code></p>
<p>代码很简单<span class=" fw-cl "><span>，</span></span>思路是首先在网页 load 事件的回调里<span class=" fw-cl "><span>：</span></span>利用 sessionStorage 记录 good_exit 值为 pending<span class=" fw-cl "><span>；</span></span>接下来<span class=" fw-cl "><span>，</span></span>在页面无异常退出前<span class=" fw-cl "><span>，</span></span>即 beforeunload 事件回调中<span class=" fw-cl "><span>，</span></span>修改 sessionStorage 记录的 good_exit 值为 true<span class=" fw-cl "><span>。</span></span>因此<span class=" fw-cl "><span>，</span></span>如果页面没有崩溃的话<span class=" fw-cl "><span>，</span></span>good_exit 值都会在离开前设置为 true<span class=" fw-cl "><span>，</span></span>否则就可以通过 sessionStorage.getItem('good_exit') &amp;&amp; sessionStorage.getItem('good_exit') !== 'true' 判断出页面崩溃<span class=" fw-cl "><span>，</span></span>并进行处理<span class=" fw-cl "><span>。</span></span></p>
<p>如果你的应用部署了 PWA<span class=" fw-cl "><span>，</span></span>那么便可以享受 service worker 带来的福利<span class=" fw-cl "><span>！</span></span>在这里<span class=" fw-cl "><span>，</span></span>可以通过 service worker 来完成网页崩溃的处理工作<span class=" fw-cl "><span>。</span></span>基本原理在于<span class=" fw-cl "><span>：</span></span>service worker 和网页的主线程独立<span class=" fw-cl "><span>。</span></span>因此<span class=" fw-cl "><span>，</span></span>即便网页发生了崩溃现象<span class=" fw-cl "><span>，</span></span>也不会影响 service worker 所在线程的工作<span class=" fw-cl "><span>。</span></span>我们在监控网页的状态时<span class=" fw-cl "><span>，</span></span>通过 navigator.serviceWorker.controller.postMessage API 来进行信息的获取和记录<span class=" fw-cl "><span>。</span></span></p>
<h4>框架的错误处理</h4>
<p>对于框架来说<span class=" fw-cl "><span>，</span></span>React 16 版本之前<span class=" fw-cl "><span>，</span></span>使用 unstable_handleError 来处理捕获的错误<span class=" fw-cl "><span>；</span></span>16 版本之后<span class=" fw-cl "><span>，</span></span>使用著名的 componentDidCatch 来处理错误<span class=" fw-cl "><span>。</span></span>Vue 中<span class=" fw-cl "><span>，</span></span>提供了 Vue.config.errorHandler 来处理捕获到的错误<span class=" fw-cl "><span>，</span></span>如果开发者没有配置 Vue.config.errorHandler<span class=" fw-cl "><span>，</span></span>那么捕获到的错误会以 console.error 的方式输出<span class=" fw-cl "><span>。</span></span>具体 API 的使用方式和框架特点<span class=" fw-cl "><span>，</span></span>这里不再赘述<span class=" fw-cl "><span>。</span></span></p>
<p>上面提到框架会用 console.error 的方法抛出错误<span class=" fw-cl "><span>，</span></span>因此可以劫持 console.error<span class=" fw-cl "><span>，</span></span>捕获框架中的错误并做出处理<span class=" fw-cl "><span>：</span></span></p>
<p><code>const nativeConsoleError = window.console.error<br>
window.console.error = (...args) =&gt; nativeConsoleError.apply(this, [`I got ${args}`])</code></p>
<p>如下图<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-e4952a976d3ec9fcdca2907d8bc1e736.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:14.624183006535949% 0" data-src="https://pic1.zhimg.com/v2-e4952a976d3ec9fcdca2907d8bc1e736.png">加载中...</span></figure>
<p>最后总结一下<span class=" fw-cl "><span>，</span></span>我们大概处理了以下错误或者异常<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">JavaScript 语法错误<span class=" fw-cl "><span>、</span></span>代码异常</li>
  <li style="">AJAX 请求异常<span class="fw-op  "><span>（</span></span>xhr.addEventListener('error', function (e) { //... })<span class=" fw-cl "><span>）</span></span></li>
  <li style="">静态资源加载异常</li>
  <li style="">Promise 异常</li>
  <li style="">跨域 Script error</li>
  <li style="">页面崩溃</li>
  <li style="">框架错误</li>
</ul>
<p>在真实生产环境中<span class=" fw-cl "><span>，</span></span>错误和异常多种多样<span class=" fw-cl "><span>，</span></span>需要开发者格外留心<span class=" fw-cl "><span>，</span></span>并对每一种情况进行覆盖<span class=" fw-cl "><span>。</span></span>另外<span class=" fw-cl "><span>，</span></span>除了性能和错误信息<span class=" fw-cl "><span>，</span></span>一些额外信息<span class=" fw-cl "><span>，</span></span>比如页面停留时间<span class=" fw-cl "><span>、</span></span>长任务处理耗时等往往对分析网页表现非常重要<span class=" fw-cl "><span>。</span></span>所有这些话题<span class=" fw-cl "><span>，</span></span>欢迎大家在评论区展开讨论<span class=" fw-cl "><span>，</span></span>也可以直接向我提问<span class=" fw-cl "><span>。</span></span>对于错误信息采集和处理的介绍到此为止<span class=" fw-cl "><span>，</span></span>接下来看一下数据的上报和系统设计<span class=" fw-cl "><span>。</span></span></p>
<h3>性能数据和错误信息上报</h3>
<p>数据都有了<span class=" fw-cl "><span>，</span></span>我们该如何上报呢<span class=" fw-cl "><span>？</span></span>可能有的开发者会想<span class=" fw-cl "><span>：</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>不就是一个 AJAX 请求吗<span class=" fw-cl fw--collapsed"><span>？</span></span><span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>实际上还真没有这么简单<span class=" fw-cl "><span>，</span></span>有一些细节需要考虑<span class=" fw-cl "><span>。</span></span></p>
<h5><strong style="">上报采用单独域名是否更好</strong></h5>
<p>我们发现<span class=" fw-cl "><span>，</span></span>成熟的网站数据上报的域名往往与业务域名并不相同<span class=" fw-cl "><span>。</span></span>这样做的好处主要有两点<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">使用单独域名<span class=" fw-cl "><span>，</span></span>可以防止对主业务服务器的压力<span class=" fw-cl "><span>，</span></span>能够避免日志相关处理逻辑和数据在主业务服务器的堆积<span class=" fw-cl "><span>；</span></span></li>
  <li style="">另外<span class=" fw-cl "><span>，</span></span>很多浏览器对同一个域名的请求量有并发数的限制<span class=" fw-cl "><span>，</span></span>单独域名能够充分利用现代浏览器的并发设置<span class=" fw-cl "><span>。</span></span></li>
</ul>
<h5><strong style="">独立域名的跨域问题</strong></h5>
<p>对于单独的日志域名<span class=" fw-cl "><span>，</span></span>肯定会涉及跨域问题<span class=" fw-cl "><span>。</span></span>我们经常发现页面使用<span class="fw-op  "><span>「</span></span>构造空的 Image 对象的方式<span class=" fw-cl "><span>」</span></span>进行数据上报<span class=" fw-cl "><span>。</span></span>原因是请求图片并不涉及跨域的问题<span class=" fw-cl "><span>：</span></span></p>
<p><code>let url = 'xxx'<br>
let img = new Image()<br>
img.src = url</code></p>
<p>我们可以将数据进行序列化<span class=" fw-cl "><span>，</span></span>作为 URL 参数传递<span class=" fw-cl "><span>：</span></span></p>
<p><code>let url = 'xxx?data=' + JSON.stringify(data)<br>
let img = new Image()<br>
img.src = url</code></p>
<h5><strong style="">何时上报数据</strong></h5>
<p>页面加载性能数据可以在页面稳定后进行上报<span class=" fw-cl "><span>。</span></span></p>
<p>一次上报就是一次访问<span class=" fw-cl "><span>，</span></span>对于其他错误和异常数据的上报<span class=" fw-cl "><span>，</span></span>假设我们的应用日志量很大<span class=" fw-cl "><span>，</span></span>则有必要合并日志在统一时间<span class=" fw-cl "><span>，</span></span>统一上报<span class=" fw-cl "><span>。</span></span>那么什么情况下上报性能数据呢<span class=" fw-cl "><span>？</span></span>一般合适的场景为<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">页面加载和重新刷新</li>
  <li style="">页面切换路由</li>
  <li style="">页面所在的 Tab 标签重新变得可见</li>
  <li style="">页面关闭</li>
</ul>
<p>但是<span class=" fw-cl "><span>，</span></span>对于越来越多的单页应用来说<span class=" fw-cl "><span>，</span></span>需要格外注意数据上报时机<span class=" fw-cl "><span>，</span></span>请看下文<span class=" fw-cl "><span>。</span></span></p>
<h4>单页应用上报</h4>
<p>如果切换路由是通过改变 hash 值来实现的<span class=" fw-cl "><span>，</span></span>那么只需要监听 hashchange 事件<span class=" fw-cl "><span>，</span></span>如果是通过 history API 来改变 URL<span class=" fw-cl "><span>，</span></span>那么需要使用 pushState 和 replaceState 事件<span class=" fw-cl "><span>。</span></span>当然一劳永逸的做法是进行 monkey patch<span class=" fw-cl "><span>，</span></span>结合发布订阅模式<span class=" fw-cl "><span>，</span></span>为相关事件的触发添加处理<span class=" fw-cl "><span>：</span></span></p>
<p><code>const patchMethod = type =&gt; <br>
 &nbsp;&nbsp;&nbsp;() =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const result = history[type].apply(this, arguments)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const event = new Event(type)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event.arguments = arguments<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.dispatchEvent(event)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
<br>
history.pushState = patchMethod('pushState')<br>
history.replaceState = patchMethod('replaceState')</code></p>
<p>我们通过重写 history.pushState 和 history.replaceState 方法<span class=" fw-cl "><span>，</span></span>添加并触发 pushState 和 replaceState 事件<span class=" fw-cl "><span>。</span></span>这样一来 history.pushState 和 history.replaceState 事件触发时<span class=" fw-cl "><span>，</span></span>可以添加订阅函数<span class=" fw-cl "><span>，</span></span>进行上报<span class=" fw-cl "><span>：</span></span></p>
<p><code>window.addEventListener('replaceState', e =&gt; {<br>
 &nbsp;&nbsp;&nbsp;// report...<br>
})<br>
window.addEventListener('pushState', e =&gt; {<br>
 &nbsp;&nbsp;&nbsp;// report...<br>
})</code></p>
<h5><strong style="">何时以及如何上报</strong></h5>
<p>如果是在页面离开时进行数据发送<span class=" fw-cl "><span>，</span></span>那么在页面卸载期间是否能够安全地发送完数据是一个难题<span class=" fw-cl "><span>：</span></span>因为页面跳转<span class=" fw-cl "><span>，</span></span>进入下一个页面<span class=" fw-cl "><span>，</span></span>就难以保证异步数据的发送了<span class=" fw-cl "><span>。</span></span>如果使用同步的 AJAX<span class=" fw-cl "><span>：</span></span></p>
<p><code>window.addEventListener('unload', logData, false);<br>
const logData = () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;var client = new XMLHttpRequest()<br>
 &nbsp;&nbsp;&nbsp;client.open("POST", "/log", false) // 第三个参数表明是同步的 XHR<br>
 &nbsp;&nbsp;&nbsp;client.setRequestHeader("Content-Type", "text/plain;charset=UTF-8")<br>
 &nbsp;&nbsp;&nbsp;client.send(data)<br>
}</code></p>
<p>又会对页面跳转流畅程度和用户体验造成影响<span class=" fw-cl "><span>。</span></span></p>
<p>这时候给大家推荐一下 sendBeacon 方法<span class=" fw-cl "><span>：</span></span></p>
<p><code>window.addEventListener('unload', logData, false)<br>
<br>
const logData = () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;navigator.sendBeacon("/log", data)<br>
}</code></p>
<p>navigator.sendBeacon 就是天生来解决<span class="fw-op  "><span>「</span></span>页离开时的请求发送<span class=" fw-cl "><span>」</span></span>问题的<span class=" fw-cl "><span>。</span></span>它的几个特点决定了对应问题的解决方案<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">它的行为是异步的<span class=" fw-cl "><span>，</span></span>也就是说请求的发送不会阻塞向下一个页面的跳转<span class=" fw-cl "><span>，</span></span>因此可以保证跳转的流畅度<span class=" fw-cl "><span>；</span></span></li>
  <li style="">它在不受到极端<span class="fw-op  "><span>「</span></span>数据 size 和队列总数<span class=" fw-cl "><span>」</span></span>的限制下<span class=" fw-cl "><span>，</span></span>优先返回 true 以保证请求的发送成功<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>目前 Google Analytics 使用 navigator.sendBeacon 来上报数据<span class=" fw-cl "><span>，</span></span>请参考<span class=" fw-cl "><span>：</span></span><a href="https://www.thyngster.com/google-analytics-added-sendbeacon-functionality-universal-analytics-javascript-api/" title="Google Analytics added sendBeacon functionality to Universal Analytics JavaScript API">Google Analytics added sendBeacon functionality to Universal Analytics JavaScript API</a><span class=" fw-cl "><span>。</span></span>通过这篇文章<span class=" fw-cl "><span>，</span></span>我们看到 Google Analytics 通过动态创建 img 标签<span class=" fw-cl "><span>，</span></span>在 img.src 中拼接 URL 的方式发送请求<span class=" fw-cl "><span>，</span></span>不存在跨域限制<span class=" fw-cl "><span>。</span></span>如果 URL 太长<span class=" fw-cl "><span>，</span></span>就会采用 sendBeacon 的方式发送请求<span class=" fw-cl "><span>，</span></span>如果 sendBeacon 方法不兼容<span class=" fw-cl "><span>，</span></span>则发送 AJAX post 同步请求<span class=" fw-cl "><span>。</span></span>类似<span class=" fw-cl "><span>：</span></span></p>
<p><code>const reportData = url =&gt; {<br>
 &nbsp;&nbsp;&nbsp;// ...<br>
 &nbsp;&nbsp;&nbsp;if (urlLength &lt; 2083) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgReport(url, times)<br>
 &nbsp;&nbsp;&nbsp;} else if (navigator.sendBeacon) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sendBeacon(url, times)<br>
 &nbsp;&nbsp;&nbsp;} else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlLoadData(url, times)<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>最后<span class=" fw-cl "><span>，</span></span>如果网页访问量很大<span class=" fw-cl "><span>，</span></span>那么一个错误发送的信息就非常多<span class=" fw-cl "><span>，</span></span>我们可以给上报设置一个采集率<span class=" fw-cl "><span>：</span></span></p>
<p><code>&nbsp;const reportData = url =&gt; {<br>
 &nbsp;&nbsp;&nbsp;// 只采集 30%<br>
 &nbsp;&nbsp;&nbsp;if (Math.random() &lt; 0.3) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(data)<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>这个采集率当然可以通过具体实际的情况来设定<span class=" fw-cl "><span>，</span></span>方法多种多样<span class=" fw-cl "><span>。</span></span></p>
<h3>无侵入和性能友好的方案设计</h3>
<p>目前为止<span class=" fw-cl "><span>，</span></span>我们已经了解了性能监控和错误收集的所有必要知识点<span class=" fw-cl "><span>。</span></span>那么根据这些知识点<span class=" fw-cl "><span>，</span></span>如何设计一个好的系统方案呢<span class=" fw-cl "><span>？</span></span></p>
<p>首先<span class=" fw-cl "><span>，</span></span>这样的系统大致可分为四个阶段<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-f136a7563dc40257e4e4be840de22724.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:8.975% 0" data-src="https://pic4.zhimg.com/v2-f136a7563dc40257e4e4be840de22724.png">加载中...</span></figure>
<p>针对这几个阶段<span class=" fw-cl "><span>，</span></span>我们聊一下关键方面的核心细节<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">数据上报优化方面</strong>&nbsp;</p>
<p>借助 HTTP 2.0 带来的新特性<span class=" fw-cl "><span>，</span></span>我们可以持续优化上报性能<span class=" fw-cl "><span>。</span></span>比如<span class=" fw-cl "><span>：</span></span>采用 HTTP 2.0 头部压缩<span class=" fw-cl "><span>，</span></span>以减少数据传送大小<span class=" fw-cl "><span>；</span></span>采用 HTTP 2.0 多路复用技术<span class=" fw-cl "><span>，</span></span>以充分利用链接资源<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">接口和智能化设计方面</strong>&nbsp;</p>
<p>我们可以考虑以下方面<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">识别周高峰和节假日<span class=" fw-cl "><span>，</span></span>动态设置上报采样率<span class=" fw-cl "><span>；</span></span></li>
  <li style="">增强数据清洗能力<span class=" fw-cl "><span>，</span></span>提高数据的可用性<span class=" fw-cl "><span>，</span></span>对一些垃圾信息进行过滤<span class=" fw-cl "><span>；</span></span></li>
  <li style="">通过配置化<span class=" fw-cl "><span>，</span></span>减少业务接入成本<span class=" fw-cl "><span>；</span></span></li>
  <li style="">如果用户一直触发错误<span class=" fw-cl "><span>，</span></span>相同的错误内容会不停上报<span class=" fw-cl "><span>，</span></span>这时可以考虑是否需要做一个短时间滤重<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p><strong style="">实时性方面</strong>&nbsp;</p>
<p>目前我们对系统数据的分析都是后置的<span class=" fw-cl "><span>，</span></span>如何做到实时提醒呢<span class=" fw-cl "><span>？</span></span>这就要依赖后端服务<span class=" fw-cl "><span>，</span></span>将超过阈值的情况进行邮件或短信发送<span class=" fw-cl "><span>。</span></span></p>
<p>在这个链路中<span class=" fw-cl "><span>，</span></span>所有细节单独拿出来都是一个值得玩味的话题<span class=" fw-cl "><span>。</span></span>打个比方<span class=" fw-cl "><span>，</span></span>报警阈值如何设定<span class=" fw-cl "><span>。</span></span>我们的应用可能在不同的时段和日期<span class=" fw-cl "><span>，</span></span>流量差别很大<span class=" fw-cl "><span>，</span></span>比如<span class="fw-op  "><span>「</span></span>点评<span class=" fw-cl "><span>」</span></span>类应用<span class=" fw-cl "><span>，</span></span>或<span class="fw-op  "><span>「</span></span>酒店预订<span class=" fw-cl "><span>」</span></span>类应用<span class=" fw-cl "><span>，</span></span>在节假日流量远远高于平时<span class=" fw-cl "><span>。</span></span>如果报警阈值不做特殊处理<span class=" fw-cl "><span>，</span></span>报警过于敏感<span class=" fw-cl "><span>，</span></span>也许运维或开发者就要收到<span class="fw-op  "><span>「</span></span>骚扰<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>业界上流行 3-sigma 的阈值设置<span class=" fw-cl "><span>，</span></span>这是一个统计学概念<span class=" fw-cl "><span>。</span></span>它表示对于一个正态分布或近似正态分布来说<span class=" fw-cl "><span>，</span></span>数值分布在<span class="fw-op  "><span>（</span></span>μ-3σ,μ+3σ) 中属于正常范围区间<span class=" fw-cl "><span>。</span></span>这方面更多内容可以参考<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style=""><a href="https://www.investopedia.com/terms/t/three-sigma-limits.asp" title="https://www.investopedia.com/terms/t/three-sigma-limits.asp">https://www.investopedia.com/terms/t/three-sigma-limits.asp</a></li>
  <li style=""><a href="https://thecuriousastronomer.wordpress.com/2014/06/26/what-does-a-1-sigma-3-sigma-or-5-sigma-detection-mean/" title="What does a 1-sigma, a 3-sigma or a 5-sigma detection mean">What does a 1-sigma, a 3-sigma or a 5-sigma detection mean</a></li>
</ul>
<p>最后<span class=" fw-cl "><span>，</span></span>我收集了业界几个性能监控和错误收集上报系统的分享<span class=" fw-cl "><span>，</span></span>这些分享方案有的以 PPT 形式呈现<span class=" fw-cl "><span>，</span></span>有的以源码分析实现<span class=" fw-cl "><span>，</span></span>希望大家能够继续了解学习<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style=""><a href="https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/" title="前端异常监控解决方案研究">前端异常监控解决方案研究</a></li>
  <li style=""><a href="https://zhuanlan.zhihu.com/p/37275225" title="解密 ARMS 前端监控数据上报技术内幕">解密 ARMS 前端监控数据上报技术内幕</a></li>
  <li style=""><a href="https://mp.weixin.qq.com/s/Z8daa96JD5NbjTPn9mGPPg" title="别再让你的 Web 页面在用户浏览器端裸奔">别再让你的 Web 页面在用户浏览器端裸奔</a></li>
  <li style=""><a href="https://zhuanlan.zhihu.com/p/32262716?utm_medium=social&amp;utm_source=wechat_session&amp;from=singlemessage&amp;isappinstalled=0" title="把前端监控做到极致">把前端监控做到极致</a></li>
  <li style=""><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247485669&amp;idx=1&amp;sn=a4d4aee73b606d412aba71abafb88325&amp;source=41#wechat_redirect" title="浏览器端 JS 异常监控探索与实践">浏览器端 JS 异常监控探索与实践</a></li>
</ul>
<h3>总结</h3>
<p>本节梳理了性能监控和错误收集上报方方面面的内容<span class=" fw-cl "><span>。</span></span>前端业务场景和浏览器的兼容性千差万别<span class=" fw-cl "><span>，</span></span>因此数据监控上报系统要兼容多种情况<span class=" fw-cl "><span>。</span></span>页面生命周期<span class=" fw-cl "><span>、</span></span>业务逻辑复杂性也决定了成熟稳定的系统不是一蹴而就的<span class=" fw-cl "><span>。</span></span>我们也要持续打磨<span class=" fw-cl "><span>，</span></span>结合新技术和老经验<span class=" fw-cl "><span>，</span></span>同时对比类似 Sentry 这样的巨型方案<span class=" fw-cl "><span>，</span></span>探索更稳定高效的系统<span class=" fw-cl "><span>。</span></span></p>
<p>课程代码仓库<span class=" fw-cl "><span>：</span></span></p>
<p><a href="https://github.com/HOUCe/lucas-gitchat-courses%3C/a%3E" title="https://github.com/HOUCe/lucas-gitchat-courses</a>">https://github.com/HOUCe/lucas-gitchat-courses</a></p><p><span style="display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);">备案号:YXX1p6PmMpFXLQyEwI5olY</span></p>
</body>
</html>