<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>第 41 节古老又新潮的函数式</h1>
  <p>函数式这个概念我们在以往的课程中其实已经有所涉及了<span class=" fw-cl "><span>，</span></span>比如第 1-2<span class=" fw-cl "><span>、</span></span>1-3 课介绍的闭包知识<span class=" fw-cl "><span>；</span></span>比如 1-4 课<span class="fw-op  "><span>《</span></span>我们不背诵 API<span class=" fw-cl "><span>，</span></span>只实现 API<span class=" fw-cl "><span>》</span></span>中剖析的 5 种 compose 方法<span class=" fw-cl "><span>，</span></span>以及 reduce 实现 pipe<span class=" fw-cl "><span>、</span></span>runPromiseInSequence 等都是典型的函数式概念<span class=" fw-cl "><span>。</span></span></p>
<p>函数式其实很早就出现在了编程领域当中<span class=" fw-cl "><span>，</span></span>近些年由于 React 的带动<span class=" fw-cl "><span>，</span></span>在前端开发中重新<span class="fw-op  "><span>「</span></span>焕发活力<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span></p>
<p>很多读者可能一听到函数式就眉头一皱<span class=" fw-cl "><span>，</span></span>毕竟相比于面向对象等其他编程概念<span class=" fw-cl "><span>，</span></span>它更加晦涩难懂<span class=" fw-cl "><span>。</span></span>对于函数式的学习<span class=" fw-cl "><span>，</span></span>也一定不是使用或者模仿 compose 那么简单<span class=" fw-cl "><span>。</span></span>这一节课<span class=" fw-cl "><span>，</span></span>我们就来梳理几个函数式概念<span class=" fw-cl "><span>。</span></span>但是我认为单纯的概念介绍并没有意义<span class=" fw-cl "><span>，</span></span>因此也准备了大量实战例题以及库的设计方案<span class=" fw-cl "><span>，</span></span>与大家一起分享<span class=" fw-cl "><span>。</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-9184d3f33942f97694dd41c16ce95790.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:26.693548387096772% 0" data-src="https://pic1.zhimg.com/v2-9184d3f33942f97694dd41c16ce95790.png">加载中...</span></figure>
<h3>函数式和高质量函数</h3>
<p>函数式通常意味着高质量的代码<span class=" fw-cl "><span>，</span></span>本小节的主标题之所以是<span class="fw-op  "><span>「</span></span>函数式和高质量函数<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>而不是<span class="fw-op  "><span>「</span></span>函数式和高质量代码<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>因为在函数式看来<span class=" fw-cl "><span>，</span></span>一切都是函数<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>函数是第一等公民<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>围绕着函数<span class=" fw-cl "><span>，</span></span>取代面向过程式的代码<span class=" fw-cl "><span>，</span></span>往往能够有以下收益<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style=""><strong style="">表达力更加清晰</strong><span class=" fw-cl "><span>，</span></span>因为<span class="fw-op  "><span>「</span></span>一切都是函数<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>通过函数的合理命名<span class=" fw-cl "><span>，</span></span>函数原子的拆分<span class=" fw-cl "><span>，</span></span>我们能够一眼看出来程序在做什么<span class=" fw-cl "><span>，</span></span>以及做的过程<span class=" fw-cl "><span>；</span></span></li>
  <li style=""><strong style="">利于复用</strong><span class=" fw-cl "><span>，</span></span>因为<span class="fw-op  "><span>「</span></span>一切都是函数<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>函数本身具有天然的复用能力<span class=" fw-cl "><span>；</span></span></li>
  <li style=""><strong style="">利于维护</strong><span class=" fw-cl "><span>，</span></span>纯函数和幂等性保证同样的输入就有同样的输出<span class=" fw-cl "><span>，</span></span>在维护或者调试代码时<span class=" fw-cl "><span>，</span></span>能够更加专注<span class=" fw-cl "><span>，</span></span>减少因为共享带来的潜在问题<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>我们下面来通过概念具体展开<span class=" fw-cl "><span>。</span></span></p>
<h4>纯函数</h4>
<p>之前我们提到过<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>一个函数如果输入参数确定<span class=" fw-cl "><span>，</span></span>输出结果是唯一确定的<span class=" fw-cl "><span>，</span></span>那么它就是纯函数<span class=" fw-cl "><span>。</span></span></p>
<p>并且纯函数不能修改外部变量<span class=" fw-cl "><span>，</span></span>造成副作用<span class=" fw-cl "><span>，</span></span>不能调用 Math.radom() 方法以及发送异步请求等<span class=" fw-cl "><span>，</span></span>因为这些操作都不具有确定性<span class=" fw-cl "><span>。</span></span></p>
<p>根据定义我们知道纯函数的特点是<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">无状态</li>
  <li style="">无副作用</li>
  <li style="">无关时序</li>
  <li style="">幂等<span class="fw-op  "><span>（</span></span>指无论调用多少次<span class=" fw-cl "><span>，</span></span>结果相同<span class=" fw-cl "><span>）</span></span></li>
</ul>
<p>看代码举例<span class=" fw-cl "><span>：</span></span></p>
<p><code>let array = [1,2,3,4]<br>
<br>
// array 的 slice 方法属于纯函数方法<span class=" fw-cl "><span>，</span></span>它不对数组本身进行操作<br>
// array 的 splice 方法不属于纯函数方法<span class=" fw-cl "><span>，</span></span>它对数组本身进行操作 <br>
<br>
const minusCount = () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;window.count--<br>
} <br>
<br>
// minusCount 不是纯函数<span class=" fw-cl "><span>，</span></span>它依赖并改变外部变量<span class=" fw-cl "><span>，</span></span>具有副作用<br>
<br>
const setHtml = (node, html) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;node.innerHtml = html<br>
} <br>
<br>
// setHtml 不是纯函数<span class=" fw-cl "><span>，</span></span>同上</code></p>
<p>这样的纯函数不仅易于维护<span class=" fw-cl "><span>，</span></span>逻辑清晰<span class=" fw-cl "><span>，</span></span>而且具有更好的组合和测试性<span class=" fw-cl "><span>。</span></span>之前的课程中我们多次提到<span class=" fw-cl "><span>，</span></span>这里不再单独展开<span class=" fw-cl "><span>。</span></span></p>
<h4>高阶函数</h4>
<p>高阶函数体现了<span class="fw-op  "><span>「</span></span>函数是第一等公民<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>它是指这样的一类函数<span class=" fw-cl "><span>：</span></span>该函数接受一个函数作为参数<span class=" fw-cl "><span>，</span></span>返回另外一个函数<span class=" fw-cl "><span>。</span></span></p>
<p>没错<span class=" fw-cl "><span>，</span></span>和高阶组件的概念类似<span class=" fw-cl "><span>。</span></span>为什么会有这么一个<span class="fw-op  "><span>「</span></span>怪异<span class=" fw-cl "><span>」</span></span>的高阶函数呢<span class=" fw-cl "><span>？</span></span>来看一个例子<span class=" fw-cl "><span>：</span></span>filterLowerThan10 这个函数接受一个数组作为参数<span class=" fw-cl "><span>，</span></span>它会挑选出数组中数值小于 10 的项目<span class=" fw-cl "><span>，</span></span>所有符合条件的值都会构成新数组被返回<span class=" fw-cl "><span>：</span></span></p>
<p><code>const filterLowerThan10 = array =&gt; {<br>
 &nbsp;&nbsp;&nbsp;let result = []<br>
 &nbsp;&nbsp;&nbsp;for (let i = 0, length = array.length; i &lt; length; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let currentValue = array[i]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (currentValue &lt; 10) result.push(currentValue)<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return result<br>
}</code></p>
<p>另外一个需求<span class=" fw-cl "><span>，</span></span>挑选出数组中非数值项目<span class=" fw-cl "><span>，</span></span>所有符合条件的值都会构成新数组被返回<span class=" fw-cl "><span>：</span></span></p>
<p><code>const filterNaN = array =&gt; {<br>
 &nbsp;&nbsp;&nbsp;let result = []<br>
 &nbsp;&nbsp;&nbsp;for (let i = 0, length = array.length; i &lt; length; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let currentValue = array[i]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isNaN(currentValue)) result.push(currentValue)<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return result<br>
}</code></p>
<p>这都是很基本的面向过程编程的代码<span class=" fw-cl "><span>。</span></span>不够优雅的一点是 filterLowerThan10 和 filterNaN 都有遍历的逻辑<span class=" fw-cl "><span>，</span></span>都存在了重复的 for 循环<span class=" fw-cl "><span>。</span></span>本质上都是遍历一个列表<span class=" fw-cl "><span>，</span></span>并用给定的条件过滤列表<span class=" fw-cl "><span>。</span></span>我们能否用函数式的思想<span class=" fw-cl "><span>，</span></span>将遍历和筛选解耦呢<span class=" fw-cl "><span>？</span></span></p>
<p>好在 JavaScript 对函数式较为友好<span class=" fw-cl "><span>，</span></span>我们使用 filter 函数来完成<span class=" fw-cl "><span>，</span></span>并进行一定程度的改造<span class=" fw-cl "><span>：</span></span></p>
<p><code>const lowerThan10 = value =&gt; value &lt; 10<br>
<br>
[12, 3, 4, 89].filter(lowerThan10)<br>
<br>
[12, 'sd', null, undefined, {}].filter(isNaN)</code></p>
<p>这非常简单<span class=" fw-cl "><span>，</span></span>我们以此来热身进入状态<span class=" fw-cl "><span>。</span></span></p>
<p>另一个高阶函数的典型应用场景是函数缓存<span class=" fw-cl "><span>：</span></span></p>
<p><code>const memorize = fn =&gt; {<br>
 &nbsp;&nbsp;&nbsp;let cacheMap = {}<br>
 &nbsp;&nbsp;&nbsp;return function(...args) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const cacheKey = args.join('_')<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (cacheKey in cacheMap) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cache[cacheKey]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cacheMap[cacheKey] = fn.apply(this || {}, args)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>高阶函数可以和 decorator 相结合<span class=" fw-cl "><span>，</span></span>再来看一个实例<span class=" fw-cl "><span>，</span></span>实现有限次数函数调用的装饰器<span class=" fw-cl "><span>：</span></span></p>
<p><code>&nbsp;class MyClass {<br>
 &nbsp;&nbsp;&nbsp;@callLimit getSum() {}<br>
}</code></p>
<p>实现<span class=" fw-cl "><span>：</span></span></p>
<p><code>function callLimit(limitCallCount = 1, level = 'warn') {<br>
 &nbsp;&nbsp;&nbsp;// 记录调用次数<br>
 &nbsp;&nbsp;&nbsp;let count = 0<br>
 &nbsp;&nbsp;&nbsp;return function(target, name, descriptor) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 记录原始函数<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var fn = descriptor.value<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 改写新函数<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;descriptor.value = function(...args) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (count &lt; limitCallCount) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fn.apply(this || {}, args)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (console[level]) console[level](name, 'call limit')<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.warn(name, 'call limit')<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
}</code></p>
<p>严格来说<span class=" fw-cl "><span>，</span></span>这也不算是一个高阶函数的使用场景<span class=" fw-cl "><span>，</span></span>但是体现了类似的思想<span class=" fw-cl "><span>。</span></span>读者可以举一反三<span class=" fw-cl "><span>。</span></span></p>
<h4>组合</h4>
<p>继续延伸我们的场景<span class=" fw-cl "><span>，</span></span>如果输入比较复杂<span class=" fw-cl "><span>，</span></span>想先过滤出小于 10 的项目需要先保证数组中每一项都是 Number 类型<span class=" fw-cl "><span>，</span></span>那么可以<span class=" fw-cl "><span>：</span></span></p>
<p><code>[12, 'sd', null, undefined, {}, 23, 45, 3, 6].filter(value=&gt; !isNaN(value) &amp;&amp; value !== null).filter(lowerThan10)s</code></p>
<p>这样的做法得益于 JavaScript filter 对函数式的友好支持<span class=" fw-cl "><span>，</span></span>链式调用也在一定程度上实现了组合性<span class=" fw-cl "><span>。</span></span></p>
<p>更加通用的组合做法是使用 compose 方法<span class=" fw-cl "><span>，</span></span>收益非常直观<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">单一功能的小函数更好维护</li>
  <li style="">通过组合<span class=" fw-cl "><span>，</span></span>将单一功能的小函数串联起来<span class=" fw-cl "><span>，</span></span>完成复杂的功能</li>
  <li style="">复用性更好<span class=" fw-cl "><span>，</span></span>硬编码更少</li>
</ul>
<h4>point free</h4>
<p>point free 是指一种函数式的编程风格<span class=" fw-cl "><span>，</span></span>有时候也可以叫做 tacit programming<span class=" fw-cl "><span>。</span></span>point 在这里的意思是指形参<span class=" fw-cl "><span>，</span></span>那么 point free<span class=" fw-cl "><span>，</span></span>自然就是指没有行参了<span class=" fw-cl "><span>。</span></span>这样做的目的是什么呢<span class=" fw-cl "><span>？</span></span>没有参数<span class=" fw-cl "><span>，</span></span>就意味着我们将注意力放在函数本身上<span class=" fw-cl "><span>。</span></span>一般参数存在的意义是传递或者携带某个值<span class=" fw-cl "><span>，</span></span>函数根据这个值<span class=" fw-cl "><span>，</span></span>来得到另一个值<span class=" fw-cl "><span>。</span></span>这样造成的困扰是我们不得不操作数据<span class=" fw-cl "><span>，</span></span>同时要给参数命名<span class=" fw-cl "><span>。</span></span>如果没有参数<span class=" fw-cl "><span>，</span></span>不返回一个数据<span class=" fw-cl "><span>，</span></span>那么 point free 的目的就是得到一个函数<span class=" fw-cl "><span>。</span></span></p>
<p>当然业务中不可能永远不存在参数<span class=" fw-cl "><span>，</span></span>因此我们允许底层函数非 point free<span class=" fw-cl "><span>，</span></span>而 point free 函数更像是一种上层封装<span class=" fw-cl "><span>，</span></span>它灵活调度带有参数的的底层函数<span class=" fw-cl "><span>，</span></span>通过 point free 和非 point free 的解耦<span class=" fw-cl "><span>，</span></span>使得代码更具有声明式特征<span class=" fw-cl "><span>，</span></span>更具有美感<span class=" fw-cl "><span>。</span></span></p>
<p>point free 是我们的追求<span class=" fw-cl "><span>，</span></span>而非标准<span class=" fw-cl "><span>，</span></span>过度使用某种模式往往让代码<span class="fw-op  "><span>「</span></span>变坏<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>这里给大家介绍这种概念<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>见多识广<span class=" fw-cl "><span>」</span></span>和<span class="fw-op  "><span>「</span></span>矫枉过正<span class=" fw-cl "><span>」</span></span>往往只有一线之隔<span class=" fw-cl "><span>。</span></span></p>
<h3>curry 化分析</h3>
<p>curry 化也是一个常见的概念<span class=" fw-cl "><span>，</span></span>维基百科对齐解释为<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>在计算机科学中<span class=" fw-cl "><span>，</span></span>柯里化<span class="fw-op  "><span>（</span></span>currying<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>又译为卡瑞化或加里化<span class=" fw-cl "><span>，</span></span>是把接受多个参数的函数变换成接受一个单一参数<span class="fw-op  "><span>（</span></span>最初函数的第一个参数<span class=" fw-cl "><span>）</span></span>的函数<span class=" fw-cl "><span>，</span></span>并且返回接受余下的参数而且返回结果的新函数的技术<span class=" fw-cl "><span>。</span></span>这个技术由克里斯托弗·斯特雷奇以逻辑学家哈斯凯尔·加里命名的<span class=" fw-cl "><span>。</span></span></p>
<p>简单来说<span class=" fw-cl "><span>，</span></span>就是在一个函数中预先填充几个参数<span class=" fw-cl "><span>，</span></span>这个函数返回另一个函数<span class=" fw-cl "><span>，</span></span>这个返回的新函数将其参数和预先填充的参数进行合并<span class=" fw-cl "><span>，</span></span>再执行函数逻辑<span class=" fw-cl "><span>。</span></span></p>
<p>那我们上述代码举例<span class=" fw-cl "><span>：</span></span></p>
<p><code>const filterLowerThan10 = array =&gt; {<br>
 &nbsp;&nbsp;&nbsp;let result = []<br>
 &nbsp;&nbsp;&nbsp;for (let i = 0, length = array.length; i &lt; length; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let currentValue = array[i]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (currentValue &lt; 10) result.push(currentValue)<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return result<br>
}</code></p>
<p>filterLowerThan10 还是硬编码写死了 10 这个阈值<span class=" fw-cl "><span>，</span></span>我们用 curry 化的思想将其改造<span class=" fw-cl "><span>：</span></span></p>
<p><code>const filterLowerNumber = number =&gt; {<br>
 &nbsp;&nbsp;&nbsp;return array =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = []<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0, length = array.length; i &lt; length; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let currentValue = array[i]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (currentValue &lt; number) result.push(currentValue)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result<br>
 &nbsp;&nbsp;&nbsp;}<br>
}<br>
<br>
const filterLowerThan10 = filterLowerNumber(10)<br>
<br>
<br>
filterLowerThan10([1, 3, 5, 29, 34])</code></p>
<h4>curry 化面试题</h4>
<p>再通过一到面试题加深理解<span class=" fw-cl "><span>。</span></span></p>
<blockquote><br></blockquote>
<p>实现 add 方法<span class=" fw-cl "><span>，</span></span>要求<span class=" fw-cl "><span>：</span></span></p>
<p><code>add(1)(2) == 3 // true<br>
<br>
add(1)(2)(3) == 6 // true</code></p>
<p>分析这道题<span class=" fw-cl "><span>：</span></span>add 函数每次执行后一定需要保证返回一个函数<span class=" fw-cl "><span>，</span></span>以供后续继续调用<span class=" fw-cl "><span>，</span></span>且返回的这个函数还有返回自身<span class=" fw-cl "><span>，</span></span>以支持连续调用<span class=" fw-cl "><span>。</span></span>同时<span class=" fw-cl "><span>，</span></span>为了满足例题条件<span class=" fw-cl "><span>，</span></span>需要改写内部返回的函数 toString<span class=" fw-cl "><span>：</span></span></p>
<p><code>const add = arg1 =&gt; {<br>
 &nbsp;&nbsp;const fn = arg2 =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fn<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;fn.toString = function () {<br>
<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return fn<br>
<br>
}</code></p>
<p>为了进行<span class="fw-op  "><span>「</span></span>求和<span class=" fw-cl "><span>」</span></span>操作<span class=" fw-cl "><span>，</span></span>需要在 add 函数内部维护一个闭包变量 args<span class=" fw-cl "><span>，</span></span>args 是个数组<span class=" fw-cl "><span>，</span></span>记录了每次调用是传进来的参数<span class=" fw-cl "><span>，</span></span>toString 方法体中对参数进行求和<span class=" fw-cl "><span>，</span></span>fn 方法体中对数组 args 进行添加当前参数的操作<span class=" fw-cl "><span>：</span></span></p>
<p><code>const add = arg1 =&gt; {<br>
 &nbsp;&nbsp;let args = [arg1]<br>
 &nbsp;&nbsp;const fn = arg2 =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args.push(arg2)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fn<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;fn.toString = function () {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return args.reduce((prev, item) =&gt; prev + item, 0)<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return fn<br>
}</code></p>
<p>注意这里只支持<span class=" fw-cl "><span>：</span></span></p>
<p><code>add(1)(2)(3)</code></p>
<p>单个参数的调用<span class=" fw-cl "><span>，</span></span>如果更加通用化<span class=" fw-cl "><span>，</span></span>支持<span class=" fw-cl "><span>：</span></span></p>
<p><code>add(1)(2, 3)(4)</code></p>
<p>需要我们改动为<span class=" fw-cl "><span>：</span></span></p>
<p><code>const add = (...arg1) =&gt; {<br>
 &nbsp;&nbsp;let args = [...arg1]<br>
 &nbsp;&nbsp;const fn = (...arg2) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args = [...args, ...arg2]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fn<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;fn.toString = function () {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return args.reduce((prev, item) =&gt; prev + item, 0)<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return fn<br>
}</code></p>
<p>实现<span class=" fw-cl "><span>：</span></span></p>
<p><code>add(1)(2, 3)(4) == 10</code></p>
<p>还有一个细节<span class=" fw-cl "><span>，</span></span>如果将 == 改为 ===<span class=" fw-cl "><span>，</span></span>将会输出 false<span class=" fw-cl "><span>，</span></span>这并不奇怪<span class=" fw-cl "><span>。</span></span>因为 add 调用后的返回值类型始终为 Function<span class=" fw-cl "><span>，</span></span>我们只是改写了其 toString 方法<span class=" fw-cl "><span>，</span></span>利用了隐式转换规则而已<span class=" fw-cl "><span>。</span></span></p>
<h4>通用 curry 化</h4>
<p>我们回到 filterLowerThan10 函数的案例中<span class=" fw-cl "><span>，</span></span>从中感受到 curry 化的优势<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">提高复用性</li>
  <li style="">减少重复传递不必要的参数</li>
  <li style="">动态根据上下文创建函数</li>
</ul>
<p>其中动态根据上下文创建函数<span class=" fw-cl "><span>，</span></span>也是一种惰性求值的体现<span class=" fw-cl "><span>：</span></span></p>
<p><code>const addEvent = (function() {<br>
 &nbsp;&nbsp;&nbsp;if (window.addEventListener) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return function (type, element, handler, capture) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.addEventListener(type, handler, capture)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;else if (window.attachEvent){<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return function (type, element, fn) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element.attachEvent('on' + type, fn)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
})()</code></p>
<p>这是一个典型兼容 IE9 浏览器事件 API 的例子<span class=" fw-cl "><span>，</span></span>根据兼容性的嗅探<span class=" fw-cl "><span>，</span></span>充分利用 curry 化思想<span class=" fw-cl "><span>，</span></span>完成了需求<span class=" fw-cl "><span>。</span></span></p>
<p>那么我们如何编写一个通用化的 curry 函数呢<span class=" fw-cl "><span>？</span></span></p>
<p><code>const curry = (fn, length) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;length = length || fn.length<br>
 &nbsp;&nbsp;&nbsp;return function (...args) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (args.length &lt; length) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return curry(fn.bind(this, ...args), length - args.length)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fn.call(this, ...args)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>这里我们利用 Function.length 获取函数预期需要的参数个数<span class=" fw-cl "><span>，</span></span>并利用了 bind 方法绑定参数<span class=" fw-cl "><span>。</span></span></p>
<p>如果不想使用 bind<span class=" fw-cl "><span>，</span></span>另一种常规思路是对每次调用时产生的参数进行存储<span class=" fw-cl "><span>：</span></span></p>
<p><code>const curry = fn =&gt; {<br>
 &nbsp;&nbsp;&nbsp;return tempFn = (...arg1) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (arg1.length &gt;= fn.length) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fn(...arg1)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (...arg2) =&gt; tempFn(...arg1, ...arg2)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>简化为<span class=" fw-cl "><span>：</span></span></p>
<p><code>const curry = fn =&gt;<br>
 &nbsp;&nbsp;&nbsp;judge = (...arg1) =&gt;<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg1.length &gt;= fn.length<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? fn(...arg1)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: (...arg2) =&gt; judge(...arg1, ...arg2)</code></p>
<p>总之<span class=" fw-cl "><span>，</span></span>实现原理就是<span class=" fw-cl "><span>：</span></span>先用闭包把传入参数保存起来<span class=" fw-cl "><span>，</span></span>当传入参数的数量足够执行函数时<span class=" fw-cl "><span>，</span></span>就开始执行函数<span class=" fw-cl "><span>。</span></span>抽象成步骤<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">先逐步接受参数<span class=" fw-cl "><span>，</span></span>并进行存储<span class=" fw-cl "><span>，</span></span>以供后续使用</li>
  <li style="">先不进行函数计算<span class=" fw-cl "><span>，</span></span>延后执行</li>
  <li style="">在符合条件时<span class=" fw-cl "><span>，</span></span>根据存储的参数<span class=" fw-cl "><span>，</span></span>统一传给函数进行计算</li>
</ul>
<h4>反 curry 化</h4>
<p>反 curry 化与 curry 正好相反<span class=" fw-cl "><span>。</span></span>反 curry 化在于扩大函数的适用性<span class=" fw-cl "><span>，</span></span>使本来作为特定对象所拥有的功能函数可以被任意对象所使用<span class=" fw-cl "><span>。</span></span></p>
<p>说到<span class="fw-op  "><span>「</span></span>特定对象所拥有的功能函数可以被任意对象所使用<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>有经验的读者可能会想到用于类型判断的 Object.prototype.toString.call(target)<span class=" fw-cl "><span>：</span></span></p>
<p><code>const foo = () =&gt; ({})<br>
const bar = ''<br>
<br>
Object.prototype.toString.call(foo) === '[object Function]'<br>
// true<br>
<br>
Object.prototype.toString.call(bar) === '[object String]'<br>
// true</code></p>
<p>通过反 curry 化<span class=" fw-cl "><span>，</span></span>我们将这个 Object 原型上的属性函数变得更加通用<span class=" fw-cl "><span>：</span></span></p>
<p><code>const toString = Object.prototype.toString.unCurry</code></p>
<p>或者有一个 UI 组件 Toast<span class=" fw-cl "><span>：</span></span></p>
<p><code>function Toast (options) {<br>
 &nbsp;&nbsp;&nbsp;this.message = ''<br>
}<br>
<br>
Toast.prototype = {<br>
 &nbsp;&nbsp;&nbsp;showMessage: function () {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.message)<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>这样的代码<span class=" fw-cl "><span>，</span></span>使得 Toast 实例均可使用 showMessage 方法<span class=" fw-cl "><span>：</span></span></p>
<p><code>new Toast({}).showMessage()</code></p>
<p>如果有一个变量对象<span class=" fw-cl "><span>：</span></span></p>
<p><code>const obj = {<br>
 &nbsp;&nbsp;&nbsp;message: 'uncurry test'<br>
}</code></p>
<p>如果想使用 Toast 原型上的 showMessage 方法<span class=" fw-cl "><span>：</span></span></p>
<p><code>const unCurryShowMessaage = unCurry(Toast.prototype.showMessage)<br>
<br>
unCurryShowMessaage(obj)</code></p>
<p>就是使用反 curry 化的另一个场景了<span class=" fw-cl "><span>。</span></span></p>
<h4>反 curry 化实现</h4>
<p>那么上述的 unCurry 方法应该如何实现呢<span class=" fw-cl "><span>？</span></span></p>
<p>我们来分析<span class=" fw-cl "><span>：</span></span>unCurry 的参数是一个<span class="fw-op  "><span>「</span></span>希望被其他对象所调用的方法<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>暂且称为 fn<span class=" fw-cl "><span>，</span></span>unCurry 执行后返回一个新的函数<span class=" fw-cl "><span>，</span></span>该函数的第一个参数是预期要执行方法的对象<span class="fw-op  "><span>（</span></span>obj<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>后面的参数是执行这个方法时需要传递的参数<span class=" fw-cl "><span>。</span></span></p>
<p><code>function unCurry(fn) {<br>
 &nbsp;&nbsp;&nbsp;return function () {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var obj = [].shift.call(arguments)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fn.apply(obj, arguments)<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>改成 ES6 的写法<span class=" fw-cl "><span>：</span></span></p>
<p><code>const unCurry = fn =&gt; (...args) =&gt; fn.call(...args)</code></p>
<p>以上是正常函数实现 uncurry 的实现<span class=" fw-cl "><span>。</span></span>我们也可以将 uncurry 挂载在函数原型上<span class=" fw-cl "><span>：</span></span></p>
<p><code>Function.prototype.unCurry = !Function.prototype.unCurry || function () {<br>
 &nbsp;&nbsp;&nbsp;const self = this<br>
 &nbsp;&nbsp;&nbsp;return function () {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Function.prototype.call.apply(self, arguments)<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>这里不太好理解的点在于<span class=" fw-cl "><span>：</span></span>Function.prototype.call.apply(self, arguments)<span class=" fw-cl "><span>，</span></span>其实这个问题本课程的读者群里也有人问过<span class=" fw-cl "><span>，</span></span>我们就一起来讨论下<span class=" fw-cl "><span>，</span></span>拆开看就会非常清晰了<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">第一步<span class=" fw-cl "><span>：</span></span>Function.prototype.call.apply(self, arguments) 可以看成 Fn.apply(self, arguments)<span class=" fw-cl "><span>，</span></span>Fn 函数执行时<span class=" fw-cl "><span>，</span></span>this 指向了 self<span class=" fw-cl "><span>。</span></span>而根据代码<span class=" fw-cl "><span>，</span></span>self 是调用 unCurry 的函数<span class=" fw-cl "><span>，</span></span>执行结果就是 Fn(arguments)<span class=" fw-cl "><span>，</span></span>只不过 this 被绑定在 self 上<span class=" fw-cl "><span>，</span></span>用 callFn(arguments) 来表示<span class=" fw-cl "><span>。</span></span></li>
  <li style="">第二步<span class=" fw-cl "><span>：</span></span>callFn(arguments) 解析<span class=" fw-cl "><span>，</span></span>callFn 指的是<span class=" fw-cl "><span>：</span></span>Function.prototype.call<span class=" fw-cl "><span>，</span></span>call 方法第一个参数是用来指定 this 的<span class=" fw-cl "><span>，</span></span>因此 callFn(arguments) 相当于 callFn(arguments[0], arguments[n - 1])<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>因此<span class=" fw-cl "><span>，</span></span>最终执行就相当于<span class=" fw-cl "><span>：</span></span>callFn(arguments[0], arguments[n - 1])<span class=" fw-cl "><span>，</span></span>也就是说反 curry 化后得到的函数<span class=" fw-cl "><span>，</span></span>第一个参数是用来决定 this 指向的<span class=" fw-cl "><span>，</span></span>也就是需要应用的目标对象<span class=" fw-cl "><span>，</span></span>剩下的参数是函数执行所需要的参数<span class=" fw-cl "><span>。</span></span></p>
<p>当然<span class=" fw-cl "><span>，</span></span>我们可以借助 bind 实现<span class=" fw-cl "><span>：</span></span></p>
<p><code>Function.prototype.unCurry = function() {<br>
 &nbsp;return this.call.bind(this)<br>
}</code></p>
<p>借助 bind<span class=" fw-cl "><span>，</span></span>call/apply 实现过程相对抽象<span class=" fw-cl "><span>，</span></span>读者可以根据示例尝试理解<span class=" fw-cl "><span>。</span></span>这里允许我再赘述一下<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>call 中的 this 指的是调用它的函数<span class=" fw-cl "><span>，</span></span>call 的内部实现中<span class=" fw-cl "><span>：</span></span>第一个参数替换了这个函数中的 this<span class=" fw-cl "><span>，</span></span>其余作为形参执行了函数<span class=" fw-cl "><span>。</span></span>而我们的代码<span class=" fw-cl "><span>：</span></span>Function.prototype.call.apply<span class=" fw-cl "><span>，</span></span>使用 apply 之后<span class=" fw-cl "><span>，</span></span>apply 的第一个参数更换了 call 中的 this<span class=" fw-cl "><span>。</span></span>因此执行时<span class=" fw-cl "><span>，</span></span>实际执行计算的的函数为 self<span class=" fw-cl "><span>。</span></span></p>
<p>这里再补充一个例子<span class=" fw-cl "><span>，</span></span>供大家理解<span class=" fw-cl "><span>：</span></span></p>
<p><code>const push = Array.prototype.push.unCurry()<br>
<br>
const test = { foo: 'lucas' }<br>
push(test, 'messi', 'ronaldo', 'neymar')<br>
console.log(test) <br>
<br>
// {0: "messi", 1: "ronaldo", 2: "neymar", foo: "lucas", length: 3}</code></p>
<p>我们借助了数组的 push 方法<span class=" fw-cl "><span>，</span></span>应用在对象上<span class=" fw-cl "><span>，</span></span>test 对象多了类似数组的属性<span class=" fw-cl "><span>，</span></span>键为数组索引<span class=" fw-cl "><span>。</span></span></p>
<h3>偏函数<span class="fw-op  "><span>（</span></span>partial<span class=" fw-cl "><span>）</span></span></h3>
<p>如果了解了 curry 化<span class=" fw-cl "><span>，</span></span>那么偏函数<span class="fw-op  "><span>（</span></span>partial application<span class=" fw-cl "><span>）</span></span>就很容易理解了<span class=" fw-cl "><span>。</span></span>如果说 curry 化是将一个多参数函数转换成多个单参数函数<span class=" fw-cl "><span>，</span></span>也就是 curry 化将 n 原函数转换 n 个一元函数<span class=" fw-cl "><span>，</span></span>那么偏函数就是固定一个函数的一个或者多个参数<span class=" fw-cl "><span>，</span></span>即将一个 n 元函数转换成一个 <span class="fw-op  "><span>（</span></span>n ﹣ k<span class=" fw-cl "><span>）</span></span> 元函数<span class=" fw-cl "><span>：</span></span></p>
<p>curry 化<span class=" fw-cl "><span>：</span></span>n = n * 1</p>
<p>partial<span class=" fw-cl "><span>：</span></span>n = n/k * k</p>
<p>响应偏函数实现<span class=" fw-cl "><span>：</span></span></p>
<p><code>const partial = (fn, ...rest) =&gt; (...args) =&gt; fn(...rest, ...args)</code></p>
<p>使用 bind 版本实现<span class=" fw-cl "><span>：</span></span></p>
<p><code>const partial = (fn, ...args) =&gt; fn.bind(null, ...args)</code></p>
<h4>函子<span class="fw-op  "><span>（</span></span>functor<span class=" fw-cl "><span>）</span></span></h4>
<p>说到函子<span class=" fw-cl "><span>，</span></span>大部分没有深入过函数式编程的读者可能有点陌生<span class=" fw-cl "><span>，</span></span>而函子确实一个很重要的函数式编程思想<span class=" fw-cl "><span>。</span></span>目前社区上介绍的并不算多<span class=" fw-cl "><span>，</span></span>我们这里来进行一下了解<span class=" fw-cl "><span>。</span></span></p>
<p>我想先从链式调用说起<span class=" fw-cl "><span>，</span></span>看以下代码<span class=" fw-cl "><span>：</span></span></p>
<p><code>const addHelloPrefix = str =&gt; `Hello : ${str}`<br>
const addByeSuffix = str =&gt; `${str}, bye!`</code></p>
<p>addHelloPrefix 和 addByeSuffix 分别给所接收到的字符串添加固定的字符串前缀和后缀<span class=" fw-cl "><span>，</span></span>我们可以这样使用<span class=" fw-cl "><span>：</span></span></p>
<p><code>addByeSuffix(addHelloPrefix('lucas'))</code></p>
<p>得到返回结果<span class=" fw-cl "><span>：</span></span>"Hello : lucas, bye!"</p>
<p>如果我们想链式调用<span class=" fw-cl "><span>：</span></span></p>
<p><code>'lucas'.addHelloPrefix().addByeSuffix()<br>
<br>
// VM176:1 Uncaught TypeError: "lucas".addHelloPrefix is not a function</code></p>
<p>得到报错信息<span class=" fw-cl "><span>，</span></span>是因为字符串并不存在 addHelloPrefix 方法<span class=" fw-cl "><span>，</span></span>因此调用失败<span class=" fw-cl "><span>。</span></span>如果 'lucas' 这样的字符串是一个复杂类型<span class=" fw-cl "><span>，</span></span>或者是一个类<span class=" fw-cl "><span>，</span></span>也许问题就能解决<span class=" fw-cl "><span>：</span></span></p>
<p><code>class Person {<br>
 &nbsp;&nbsp;&nbsp;constructor(value) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;addHelloPrefix() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return `Hello : ${this.value}`<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;addByeSuffix() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return `${this.value}, bye`<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>这样的 Person 声明并不足以完成链式调用<span class=" fw-cl "><span>，</span></span>链式调用的关键是 addHelloPrefix 和 addByeSuffix 方法仍然返回该类实例<span class=" fw-cl "><span>，</span></span>而不是字符串<span class=" fw-cl "><span>。</span></span>我们改动如下<span class=" fw-cl "><span>：</span></span></p>
<p><code>class Person {<br>
 &nbsp;&nbsp;&nbsp;constructor(value) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;addHelloPrefix() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Person(`Hello : ${this.value}`)<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;addByeSuffix() {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Person(`${this.value}, bye`)<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>执行代码<span class=" fw-cl "><span>：</span></span></p>
<p><code>new Person('lucas').addHelloPrefix().addByeSuffix()</code></p>
<p>输出<span class=" fw-cl "><span>：</span></span></p>
<p><code>{value: "Hello : lucas, bye"}</code></p>
<p>这样一来<span class=" fw-cl "><span>，</span></span>似乎举例目标更近了些<span class=" fw-cl "><span>。</span></span>我们试图将上述操作变得完全通用<span class=" fw-cl "><span>，</span></span>定义一个 Functor 类<span class=" fw-cl "><span>：</span></span></p>
<p><code>class Functor {<br>
 &nbsp;&nbsp;&nbsp;constructor(value) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;static of(value) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Functor(value)<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;apply(fn) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Functor.of(fn(this.value))<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>Functor 可以理解为函子雏形<span class=" fw-cl "><span>，</span></span>我们看它做了什么<span class=" fw-cl "><span>：</span></span>Functor 的 constructor 按照惯例接收数据<span class=" fw-cl "><span>；</span></span>同时定义 Functor 一个静态方法 of<span class=" fw-cl "><span>，</span></span>这个方法专门用来返回一个 Functor 实例对象<span class=" fw-cl "><span>；</span></span>apply 方法接受一个 fn<span class=" fw-cl "><span>，</span></span>使用 fn 对当前实例的 value 进行计算<span class=" fw-cl "><span>，</span></span>得到新的 value 之后交给静态 of 方法<span class=" fw-cl "><span>，</span></span>最终得到还有新 value 的实例<span class=" fw-cl "><span>。</span></span></p>
<p>这样一来<span class=" fw-cl "><span>，</span></span>可以<span class=" fw-cl "><span>：</span></span></p>
<p><code>Functor.of('lucas').apply(addHelloPrefix).apply(addByeSuffix)</code></p>
<p>仍然得到结果<span class=" fw-cl "><span>：</span></span></p>
<p><code>{value: "Hello : lucas, bye!"}</code></p>
<p>我们总结一下<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">Functor 可以理解为一个容器<span class=" fw-cl "><span>，</span></span>这个容器中含有值 this.value.<span class=" fw-cl "><span>；</span></span></li>
  <li style="">Functor 具有 apply 方法<span class=" fw-cl "><span>，</span></span>该方法将容器里面的每一个值<span class=" fw-cl "><span>，</span></span>应用到到另一个容器<span class=" fw-cl "><span>；</span></span></li>
  <li style="">上述所说的<span class="fw-op  "><span>「</span></span>应用到另一个容器<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>是根据 of 方法<span class=" fw-cl "><span>，</span></span>得到新的实例<span class=" fw-cl "><span>；</span></span></li>
  <li style="">所有运算<span class=" fw-cl "><span>，</span></span>都是通过函子 Functor 来完成<span class=" fw-cl "><span>，</span></span>这样一来<span class=" fw-cl "><span>，</span></span>所有运算不直接针对值<span class=" fw-cl "><span>，</span></span>而是针对这个值的容器 —— Functor<span class=" fw-cl "><span>；</span></span></li>
  <li style="">这样也保证了值的不可变性<span class=" fw-cl "><span>；</span></span></li>
  <li style="">函数式编程有个约定<span class=" fw-cl "><span>，</span></span>函子 Functor 需要拥有一个 of 方法<span class=" fw-cl "><span>，</span></span>用来生成新的容器<span class=" fw-cl "><span>。</span></span></li>
</ul>
<h4>Maybe 函子</h4>
<p>在函字 Functor 的基础上<span class=" fw-cl "><span>，</span></span>为了安全性<span class=" fw-cl "><span>，</span></span>我们将函子里的空值过滤掉<span class=" fw-cl "><span>：</span></span></p>
<p><code>class Maybe {<br>
 &nbsp;&nbsp;&nbsp;constructor(value) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;static of(value) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Maybe(value)<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;apply(fn) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.value ? Maybe.of(fn(this.value)) : new Maybe(null)<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>注意在 apply 方法中<span class=" fw-cl "><span>，</span></span>对当前值 this.value 进行判断<span class=" fw-cl "><span>，</span></span>如果非空<span class=" fw-cl "><span>，</span></span>返回 Maybe.of(fn(this.value)) 调用<span class=" fw-cl "><span>，</span></span>否则直接返回 Maybe(null)<span class=" fw-cl "><span>。</span></span></p>
<p>这就是简单的 Maybe 函子<span class=" fw-cl "><span>，</span></span>为此我们总结一下<span class=" fw-cl "><span>：</span></span><strong style="">不同类型的函子<span class=" fw-cl "><span>，</span></span>可以完成不同的功能<span class=" fw-cl "><span>。</span></span>他们的共同点是<span class=" fw-cl "><span>：</span></span>每个函子并没有直接去操作需要处理的数据<span class="fw-op  "><span>（</span></span>我们没有看到的 this.value 的直接写操作<span class=" fw-cl "><span>）</span></span>而是通过 apply 接口应用 fn<span class=" fw-cl "><span>，</span></span>并最终返回一个新的函子<span class=" fw-cl "><span>。</span></span></strong></p>
<h3>总结</h3>
<p>函数式编程博大精深<span class=" fw-cl "><span>，</span></span>这一节课只是给大家介绍了 JavaScript 中结合函数式编程常用的概念<span class=" fw-cl "><span>，</span></span>已经足够日常开发了<span class=" fw-cl "><span>。</span></span>掌握这些概念的 JavaScript 实现是进阶所必需的要求<span class=" fw-cl "><span>。</span></span></p>
<p>此外读者还可以更多考虑函数式编程的性能负担以及框架类库函数式实现的话题<span class=" fw-cl "><span>，</span></span>函数式结合 ES Next decorator 也可以玩出很多花样<span class=" fw-cl "><span>；</span></span>Ramda.js 是一个典型的函数式类库<span class=" fw-cl "><span>，</span></span>感兴趣的读者也可以深入研究<span class=" fw-cl "><span>。</span></span>同时给大家推荐一本函数式编程的书<span class="fw-op  "><span>《</span></span>JS 函数式编程指南<span class=" fw-cl fw--collapsed"><span>》</span></span><span class=" fw-cl "><span>，</span></span>它特有免费的中文版<span class=" fw-cl "><span>：</span></span><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/" title="mostly-adequate-guide">mostly-adequate-guide</a><span class=" fw-cl "><span>。</span></span></p>
<p>总之<span class=" fw-cl "><span>，</span></span>函数式的话题我们就到此结束<span class=" fw-cl "><span>，</span></span>你可以研究得更深<span class=" fw-cl "><span>、</span></span>更多<span class=" fw-cl "><span>，</span></span>但理解本节课内容足够让读者有的放矢<span class=" fw-cl "><span>，</span></span>在工程中合理使用<span class=" fw-cl "><span>。</span></span></p><p><span style="display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);">备案号:YXX1XkLPOkrUGeZ6LvFJ5YQ</span></p>
</body>
</html>