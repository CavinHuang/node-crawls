<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>第 44 节那些年常考的前端算法（3）</h1>
  <p>前面课程<span class=" fw-cl "><span>，</span></span>我们总结了前端和算法的关系<span class=" fw-cl "><span>，</span></span>在上一讲中<span class=" fw-cl "><span>，</span></span>也已经通过两道题目开启了<span class="fw-op  "><span>「</span></span>刷算法<span class=" fw-cl "><span>」</span></span>的热身<span class=" fw-cl "><span>。</span></span>算法是面试中必不可少的部分<span class=" fw-cl "><span>，</span></span>尤其对于高阶职位来说<span class=" fw-cl "><span>，</span></span>算法题目是面试环节的<span class="fw-op  "><span>「</span></span>最难<span class=" fw-cl "><span>」</span></span>和<span class="fw-op  "><span>「</span></span>最关键<span class=" fw-cl "><span>」</span></span>的环节<span class=" fw-cl "><span>。</span></span></p>
<p>算法说难也不难<span class=" fw-cl "><span>，</span></span>我们大可不必<span class="fw-op  "><span>「</span></span>谈虎色变<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>有策略地<span class="fw-op  "><span>「</span></span>刷算法题<span class=" fw-cl "><span>」</span></span>将会使你更有信心<span class=" fw-cl "><span>。</span></span>我认为在课程中一味地<span class="fw-op  "><span>「</span></span>秀算法<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>找最高深最偏的算法分析没有任何意义<span class=" fw-cl "><span>。</span></span>这里我总结出一些经典的算法题目<span class=" fw-cl "><span>，</span></span>我常用来考察候选者以及我作为面试者遇到的一些题目来讲解<span class=" fw-cl "><span>。</span></span></p>
<p>主要内容如下<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic2.zhimg.com/v2-6b6c32c1a18a2ff0be49724c07a9b36c.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:51.6860465116279% 0" data-src="https://pic2.zhimg.com/v2-6b6c32c1a18a2ff0be49724c07a9b36c.png">加载中...</span></figure>
<h3>爬楼梯</h3>
<p>题目<span class=" fw-cl "><span>：</span></span>假设我们需要爬一个楼梯<span class=" fw-cl "><span>，</span></span>这个楼梯一共有 N 阶<span class=" fw-cl "><span>，</span></span>可以一步跨越 1 个或者 2 个台阶<span class=" fw-cl "><span>，</span></span>那么爬完楼梯一共有多少种方式<span class=" fw-cl "><span>？</span></span></p>
<p>示例<span class=" fw-cl "><span>：</span></span>输入 2<span class="fw-op  "><span>（</span></span>标注 N = 2<span class=" fw-cl "><span>，</span></span>一共是 2 级台阶<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>；</span></span></p>
<p>输出<span class=" fw-cl "><span>：</span></span>2 <span class="fw-op  "><span>（</span></span>爬完一共两种方法<span class=" fw-cl "><span>：</span></span>一次跨两阶 + 分两次走完<span class=" fw-cl "><span>，</span></span>一次走一阶<span class=" fw-cl "><span>）</span></span></p>
<p>示例<span class=" fw-cl "><span>：</span></span>输入 3<span class=" fw-cl "><span>；</span></span>输出 3<span class="fw-op  "><span>（</span></span>1 阶 + 1 阶 + 1 阶<span class=" fw-cl "><span>；</span></span>1 阶 + 2 阶<span class=" fw-cl "><span>；</span></span>2 阶 + 1 阶<span class=" fw-cl "><span>）</span></span></p>
<p>思路<span class=" fw-cl "><span>：</span></span>最直接的想法其实类似 Fibonacci 数列<span class=" fw-cl "><span>，</span></span>使用递归比较简单<span class=" fw-cl "><span>。</span></span>比如我们爬 N 个台阶<span class=" fw-cl "><span>，</span></span>其实就是爬 N － 1 个台阶的方法数 + 爬 N － 2 个台阶的方法数<span class=" fw-cl "><span>。</span></span></p>
<p>解法<span class=" fw-cl "><span>：</span></span></p>
<p><code>const climbing = n =&gt; {<br>
 &nbsp;&nbsp;&nbsp;if (n == 1) return 1<br>
 &nbsp;&nbsp;&nbsp;if (n == 2) return 2<br>
 &nbsp;&nbsp;&nbsp;return climbing(n - 1) + climbing(n - 2)<br>
}</code></p>
<p>我们来分析一下时间复杂度<span class=" fw-cl "><span>：</span></span>递归方法的时间复杂度是高度为 n−1 的不完全二叉树节点数<span class=" fw-cl "><span>，</span></span>因此近似为 O(2^n)<span class=" fw-cl "><span>，</span></span>具体数学公式不再展开<span class=" fw-cl "><span>。</span></span></p>
<p>我们来尝试进行优化<span class=" fw-cl "><span>。</span></span>实际上<span class=" fw-cl "><span>，</span></span>上述的计算过程肯定都包含了不少重复计算<span class=" fw-cl "><span>，</span></span>比如 climbing(N) + climbing(N － 1) 后会计算 climbing(N － 1) + climbing(N － 2)<span class=" fw-cl "><span>，</span></span>而实际上 climbing(N － 1) 只需要计算一次就可以了<span class=" fw-cl "><span>。</span></span></p>
<p>优化方案<span class=" fw-cl "><span>：</span></span></p>
<p><code>const climbing = n =&gt; {<br>
 &nbsp;&nbsp;&nbsp;let array = []<br>
 &nbsp;&nbsp;&nbsp;const step = n =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n == 1) return 1<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n == 2) return 2<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (array[n] &gt; 0) return array[n]<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[n] = step(n - 1) + step(n - 2)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return array[n]<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return step(n)<br>
}</code></p>
<p>我们使用了一个数组 array 来储存计算结果<span class=" fw-cl "><span>，</span></span>时间复杂度为 O(n)<span class=" fw-cl "><span>。</span></span></p>
<p>另外一个优化方向是<span class=" fw-cl "><span>：</span></span>所有递归都可以用循环来代替<span class=" fw-cl "><span>。</span></span></p>
<p><code>const climbing = n =&gt; {<br>
 &nbsp;&nbsp;&nbsp;if (n == 1) return 1<br>
 &nbsp;&nbsp;&nbsp;if (n == 2) return 2<br>
<br>
 &nbsp;&nbsp;&nbsp;let array = []<br>
 &nbsp;&nbsp;&nbsp;array[1] = 1<br>
 &nbsp;&nbsp;&nbsp;array[2] = 2<br>
<br>
 &nbsp;&nbsp;&nbsp;for (let i = 3; i&lt;= n; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[i] = array[i - 1] + array[i - 2]<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return array[n]<br>
}</code></p>
<p>时间复杂度仍然为 O(n)<span class=" fw-cl "><span>，</span></span>但是我们优化了内存的开销<span class=" fw-cl "><span>。</span></span></p>
<p>因此这道题看似<span class="fw-op  "><span>「</span></span>困难<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>其实就是一个 Fibonacci 数列<span class=" fw-cl "><span>。</span></span>很多算法题目都是类似的<span class=" fw-cl "><span>，</span></span>也许第一次读题会觉得没有思路<span class=" fw-cl "><span>，</span></span>但是隐藏在题目后边的解决方案<span class=" fw-cl "><span>，</span></span>其实就是我们常见的知识<span class=" fw-cl "><span>。</span></span></p>
<h3>Combination Sum</h3>
<p>这个算法<span class=" fw-cl "><span>，</span></span>让我们来聚焦<span class="fw-op  "><span>「</span></span>回溯<span class=" fw-cl "><span>」</span></span>这两个字<span class=" fw-cl "><span>，</span></span>题目出处 <a href="https://juejin.im/post/5d1ca2c5e51d4550bf1ae8cd" title="Combination Sum">Combination Sum</a><span class=" fw-cl "><span>。</span></span></p>
<p>题目<span class=" fw-cl "><span>：</span></span>给定一组不含重复数字的非负数组和一个非负目标数字<span class=" fw-cl "><span>，</span></span>在数组中找出所有数加起来等于给定的目标数字的组合<span class=" fw-cl "><span>。</span></span></p>
<p>示例<span class=" fw-cl "><span>：</span></span>输入</p>
<p><code>const array = [2, 3, 6, 7]<br>
const target = 7</code></p>
<p>输出<span class=" fw-cl "><span>：</span></span></p>
<p><code>[<br>
 &nbsp;[7],<br>
 &nbsp;[2,2,3]<br>
]</code></p>
<p>我们直接来看优化后的思想<span class=" fw-cl "><span>：</span></span>回溯解决问题的套路就是先用<span class="fw-op  "><span>「</span></span>笨办法<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>遍历所有的情况来找出问题的解<span class=" fw-cl "><span>，</span></span>在这个遍历过程当中<span class=" fw-cl "><span>，</span></span>以深度优先的方式搜索解空间<span class=" fw-cl "><span>，</span></span>并且在搜索过程中用剪枝函数避免无效搜索<span class=" fw-cl "><span>。</span></span></p>
<p>回到这个问题<span class=" fw-cl "><span>，</span></span>我们先通过图来遍历所有情况<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-c8841cd4e8075caf27ad23a52c2b5740.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:23.589743589743588% 0" data-src="https://pic1.zhimg.com/v2-c8841cd4e8075caf27ad23a52c2b5740.png">加载中...</span></figure>
<p>对于这个题目<span class=" fw-cl "><span>，</span></span>事实上我们思考<span class=" fw-cl "><span>，</span></span>数组 [2, 2, 3] 和 [2, 3, 2] 实际是重复的<span class=" fw-cl "><span>，</span></span>因此可以删除掉重复的项<span class=" fw-cl "><span>，</span></span>优化递归树为<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-18be79d4d56eace92973e04e4535b4d3.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:32% 0" data-src="https://pic1.zhimg.com/v2-18be79d4d56eace92973e04e4535b4d3.png">加载中...</span></figure>
<p>我们该如何用代码描述上述过程呢<span class=" fw-cl "><span>？</span></span>这时候需要一个临时数组 tmpArray<span class=" fw-cl "><span>，</span></span>进入递归前 push 一个结果<span class=" fw-cl "><span>，</span></span></p>
<p>最终答案<span class=" fw-cl "><span>：</span></span></p>
<p><code>const find = (array, target) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;let result = []<br>
<br>
 &nbsp;&nbsp;&nbsp;const dfs = (index, sum, tmpArray) &nbsp;=&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (sum === target) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push(tmpArray.slice())<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (sum &gt; target) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (let i = index; i &lt; array.length; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpArray.push(array[i])<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dfs(i, sum + array[i], tmpArray)<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpArray.pop()<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;dfs(0, 0, [])<br>
<br>
 &nbsp;&nbsp;&nbsp;return result &nbsp;&nbsp;&nbsp;<br>
}</code></p>
<p>如果读者存在理解问题<span class=" fw-cl "><span>，</span></span>建议打断点调试一下<span class=" fw-cl "><span>。</span></span>回溯是一个非常常见的思想<span class=" fw-cl "><span>，</span></span>这也是一个典型的回溯常考题目<span class=" fw-cl "><span>。</span></span></p>
<p>另外<span class=" fw-cl "><span>，</span></span>该题有另一个变种<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>从一个数组中找出 N 个数<span class=" fw-cl "><span>，</span></span>其和为 M 的所有可能<span class=" fw-cl "><span>。</span></span></p>
<p>这里我们指定数组元素个数的和<span class=" fw-cl "><span>，</span></span>需要这个和为指定值<span class=" fw-cl "><span>。</span></span></p>
<p>举例<span class=" fw-cl "><span>：</span></span>从数组 [1, 2, 3, 4] 中选取 2 个元素<span class=" fw-cl "><span>，</span></span>求和为 5 的所有可能<span class=" fw-cl "><span>。</span></span>答案是两组组合: [1, 4] 和 [2, 3]<span class=" fw-cl "><span>。</span></span></p>
<p>这里我们介绍一种借助<span class="fw-op  "><span>「</span></span>二进制<span class=" fw-cl "><span>」</span></span>实现的解法<span class=" fw-cl "><span>，</span></span>可以用 0 和 1 来表示数组中相应的元素是否被选中<span class=" fw-cl "><span>。</span></span>因此<span class=" fw-cl "><span>，</span></span>对于一个长度为 4 的数组来说<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">0000 表示没有选择数组中的任何元素</li>
  <li style="">0100 表示选择了数组中第 1 位元素</li>
</ul>
<p>以此类推<span class=" fw-cl "><span>，</span></span>数组长度为 4<span class=" fw-cl "><span>，</span></span>那么上述情况一共有 16 种可能<span class="fw-op  "><span>（</span></span>Math.pow(length, 2)<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span></p>
<p>而这道题目中<span class=" fw-cl "><span>，</span></span>只需要选择指定数组元素个数的和<span class=" fw-cl "><span>，</span></span>还是对于数组长度为 4 的情况<span class=" fw-cl "><span>：</span></span>只需要考虑 0011 等 1 的个数累加为 0 case<span class=" fw-cl "><span>，</span></span>而不需要考虑类似 0111 这样的 case<span class=" fw-cl "><span>。</span></span></p>
<p>针对符合个数的所有情况<span class=" fw-cl "><span>，</span></span>我们进行数组项目的求和<span class=" fw-cl "><span>，</span></span>判断是否等于指定值的情况即可<span class=" fw-cl "><span>：</span></span></p>
<p><code>const find = (array, target, sum) =&gt; {<br>
 &nbsp;const len = array.length<br>
 &nbsp;let result = []<br>
<br>
 &nbsp;for (let i = 0; i &lt; Math.pow(2, len); i++) {<br>
 &nbsp;&nbsp;&nbsp;if (getCount(i) == target) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let s = 0 <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let temp = []<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (let j = 0; j &lt; len; j++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i &amp; 1 &lt;&lt; (len - 1 -j)) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s += array[j]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp.push(array[j])<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s == sum) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push(temp)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;}<br>
 &nbsp;return result<br>
}<br>
<br>
function getCount(i) {<br>
 &nbsp;let count = 0;<br>
 &nbsp;while (i) {<br>
 &nbsp;&nbsp;if (i &amp; 1){<br>
 &nbsp;&nbsp;&nbsp;++count<br>
 &nbsp;&nbsp;}<br>
 &nbsp;&nbsp;i &gt;&gt;= 1<br>
 &nbsp;}<br>
 &nbsp;return count<br>
}</code></p>
<h3>remove duplicates from sorted array</h3>
<p>题目<span class=" fw-cl "><span>：</span></span>对一个给定一个排序数组去重<span class=" fw-cl "><span>，</span></span>同时返回去重后数组的新长度<span class=" fw-cl "><span>。</span></span></p>
<p>难点<span class=" fw-cl "><span>：</span></span>这道题并不困难<span class=" fw-cl "><span>，</span></span>但是需要临时加一些条件<span class=" fw-cl "><span>，</span></span>即需要原地操作<span class=" fw-cl "><span>，</span></span>在使用 O(1) 额外空间的条件下完成<span class=" fw-cl "><span>。</span></span></p>
<p>示例<span class=" fw-cl "><span>：</span></span></p>
<p>输入<span class=" fw-cl "><span>：</span></span></p>
<p><code>let array = [0,0,1,1,1,2,2,3,3,4]</code></p>
<p>输出<span class=" fw-cl "><span>：</span></span></p>
<p><code>console.log(removeDuplicates(array))<br>
// 5<br>
<br>
console.log(array)<br>
// 0, 1, 2, 3, 4</code></p>
<p>这道题既然规定 in-place 的操作<span class=" fw-cl "><span>，</span></span>那么可以考虑算法中的另一个重要思想<span class=" fw-cl "><span>：</span></span>双指针<span class=" fw-cl "><span>。</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-26ab425b765f5440a53ce13d3473df1e.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:27.93427230046948% 0" data-src="https://pic1.zhimg.com/v2-26ab425b765f5440a53ce13d3473df1e.png">加载中...</span></figure>
<p>使用快慢指针<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">开始时<span class=" fw-cl "><span>，</span></span>快指针和慢指针都指向数组中的第一项</li>
  <li style="">如果快指针和慢指针指的数字相同<span class=" fw-cl "><span>，</span></span>则快指针向前走一步</li>
  <li style="">如果快指针和慢指针指的数字不同<span class=" fw-cl "><span>，</span></span>则两个指针都向前走一步<span class=" fw-cl "><span>，</span></span>同时快指针指向的数字赋值给慢指针指向的数字</li>
  <li style="">当快指针走完整个数组后<span class=" fw-cl "><span>，</span></span>慢指针当前的坐标加 1 就是数组中不同数字的个数</li>
</ul>
<p>代码很简单<span class=" fw-cl "><span>：</span></span></p>
<p><code>const removeDuplicates = array =&gt; {<br>
 &nbsp;&nbsp;&nbsp;const length = array.length<br>
<br>
 &nbsp;&nbsp;&nbsp;let slowPointer = 0<br>
<br>
 &nbsp;&nbsp;&nbsp;for (let fastPointer = 0; fastPointer &lt; length; fastPointer ++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (array[slowPointer] !== array[fastPointer]) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slowPointer++<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array[slowPointer] = array[fastPointer]<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
}</code></p>
<p>这道题目如果不要求 O(n) 的时间复杂度<span class=" fw-cl "><span>，</span></span> O(1) 的空间复杂度<span class=" fw-cl "><span>，</span></span>那么会非常简单<span class=" fw-cl "><span>。</span></span>如果进行空间复杂度要求<span class=" fw-cl "><span>，</span></span>尤其是 in-place 操作<span class=" fw-cl "><span>，</span></span>开发者往往可以考虑双指针的思路<span class=" fw-cl "><span>。</span></span></p>
<h3>求众数</h3>
<p>这也是一道简单的题目<span class=" fw-cl "><span>，</span></span>关键点在于如何优化<span class=" fw-cl "><span>。</span></span></p>
<p>题目<span class=" fw-cl "><span>：</span></span>给定一个大小为 N 的数组<span class=" fw-cl "><span>，</span></span>找到其中的众数<span class=" fw-cl "><span>。</span></span>众数是指在数组中出现次数大于 N/2 的元素<span class=" fw-cl "><span>。</span></span></p>
<p>可能大家都会想到使用一个额外的空间<span class=" fw-cl "><span>，</span></span>记录元素出现的次数<span class=" fw-cl "><span>，</span></span>我们往往用一个 map 就可以轻易地实现<span class=" fw-cl "><span>。</span></span>那优化点在哪里呢<span class=" fw-cl "><span>？</span></span>答案就是投票算法<span class=" fw-cl "><span>。</span></span></p>
<p><code>const find = array =&gt; {<br>
 &nbsp;&nbsp;&nbsp;let count = 1<br>
 &nbsp;&nbsp;&nbsp;let result = array[0]<br>
<br>
 &nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; array.lenght; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (count === 0) result = array[i]<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (array[i] === result) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count--<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;return result<br>
}</code></p>
<h3>有效括号</h3>
<p>有效括号这个题目和前端息息相关<span class=" fw-cl "><span>，</span></span>在之前课程模版解析时<span class=" fw-cl "><span>，</span></span>其实都需要类似的算法进行模版的分析<span class=" fw-cl "><span>，</span></span>进而实现数据的绑定<span class=" fw-cl "><span>。</span></span>我们来看题目<span class=" fw-cl "><span>：</span></span></p>
<p>举例<span class=" fw-cl "><span>：</span></span>输入 "()"</p>
<p>输出<span class=" fw-cl "><span>：</span></span>true</p>
<p>举例<span class=" fw-cl "><span>：</span></span>输入 "()[]{}"</p>
<p>输出<span class=" fw-cl "><span>：</span></span>true</p>
<p>举例<span class=" fw-cl "><span>：</span></span>输入 "{[]}"</p>
<p>输出<span class=" fw-cl "><span>：</span></span>false</p>
<p>举例<span class=" fw-cl "><span>：</span></span>输入 "([)]"</p>
<p>输出<span class=" fw-cl "><span>：</span></span>false</p>
<p>这道题目的解法非常典型<span class=" fw-cl "><span>，</span></span>就是借助栈实现<span class=" fw-cl "><span>，</span></span>将这些括号自右向左看做栈结构<span class=" fw-cl "><span>。</span></span>我们把成对的括号分为左括号和右括号<span class=" fw-cl "><span>，</span></span>需要左括号和右括号一一匹配<span class=" fw-cl "><span>，</span></span>通过一个 Object 来维护关系<span class=" fw-cl "><span>：</span></span></p>
<p><code>let obj = {<br>
 &nbsp;&nbsp;&nbsp;"]": "[",<br>
 &nbsp;&nbsp;&nbsp;"}": "{",<br>
 &nbsp;&nbsp;&nbsp;")": "(",<br>
}</code></p>
<p>如果编译器中在解析时<span class=" fw-cl "><span>，</span></span>遇见左括号<span class=" fw-cl "><span>，</span></span>我们就入栈<span class=" fw-cl "><span>；</span></span>如果是右括号<span class=" fw-cl "><span>，</span></span>就取出栈顶元素检查是否匹配<span class=" fw-cl "><span>。</span></span>如果匹配<span class=" fw-cl "><span>，</span></span>就出栈<span class=" fw-cl "><span>；</span></span>否则<span class=" fw-cl "><span>，</span></span>就返回 false<span class=" fw-cl "><span>。</span></span></p>
<p><code>const isValid = str =&gt; {<br>
 &nbsp;&nbsp;&nbsp;let stack = []<br>
 &nbsp;&nbsp;&nbsp;var obj = {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"]": "[",<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"}": "{",<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")": "(",<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; str.length; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(str[i] === "[" || str[i] === "{" || str[i] === "(") {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(str[i])<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} <br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let key = stack.pop()<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(obj[key] !== str[i]) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;if (!stack.length) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;return false<br>
};</code></p>
<h3>LRU 缓存算法</h3>
<p>看了这么多小算法题目<span class=" fw-cl "><span>，</span></span>我们来换一个口味<span class=" fw-cl "><span>，</span></span>现在看一个算法的实际应用<span class=" fw-cl "><span>。</span></span></p>
<blockquote><br></blockquote>
<p>LRU<span class="fw-op  "><span>（</span></span>Least Recently Used<span class=" fw-cl "><span>）</span></span>算法是缓存淘汰算法的一种<span class=" fw-cl "><span>。</span></span>简单地说<span class=" fw-cl "><span>，</span></span>由于内存空间有限<span class=" fw-cl "><span>，</span></span>需要根据某种策略淘汰不那么重要的数据<span class=" fw-cl "><span>，</span></span>用以释放内存<span class=" fw-cl "><span>。</span></span>LRU 的策略是最早操作过的数据放最后<span class=" fw-cl "><span>，</span></span>最晚操作过的放开始<span class=" fw-cl "><span>，</span></span>按操作时间逆序<span class=" fw-cl "><span>，</span></span>如果达到上限<span class=" fw-cl "><span>，</span></span>则淘汰末尾的项<span class=" fw-cl "><span>。</span></span></p>
<p>整个 LRU 算法有一定的复杂度<span class=" fw-cl "><span>，</span></span>并且需要很多功能扩展<span class=" fw-cl "><span>。</span></span>因此在生产环境中建议直接使用成熟的库<span class=" fw-cl "><span>，</span></span>比如 npm 搜索 lru-cache<span class=" fw-cl "><span>。</span></span></p>
<p>这里我们尝试实现一个微型体统级别的 LRU 算法<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>运用你所掌握的数据结构<span class=" fw-cl "><span>，</span></span>设计和实现一个 LRU<span class="fw-op  "><span>（</span></span>最近最少使用<span class=" fw-cl "><span>）</span></span>缓存机制<span class=" fw-cl "><span>。</span></span>它应该支持以下操作<span class=" fw-cl "><span>：</span></span>获取数据 get 和 写入数据 put <span class=" fw-cl "><span>。</span></span></p>
<p>获取数据 get(key) － 如果密钥 (key) 存在于缓存中<span class=" fw-cl "><span>，</span></span>则获取密钥的值<span class="fw-op  "><span>（</span></span>总是正数<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>否则返回 －1<span class=" fw-cl "><span>。</span></span></p>
<p>写入数据 put(key, value) － 如果密钥不存在<span class=" fw-cl "><span>，</span></span>则写入其数据值<span class=" fw-cl "><span>。</span></span>当缓存容量达到上限时<span class=" fw-cl "><span>，</span></span>它应该在写入新数据之前删除最近最少使用的数据值<span class=" fw-cl "><span>，</span></span>从而为新的数据值留出空间<span class=" fw-cl "><span>。</span></span></p>
<p>我们先来整体思考<span class=" fw-cl "><span>：</span></span>尽量满足 O(1) 的时间复杂度中完成获取和写入的操作<span class=" fw-cl "><span>，</span></span>那么可以使用一个 Object 来进行存储<span class=" fw-cl "><span>，</span></span>如果 key 不是简单类型<span class=" fw-cl "><span>，</span></span>可以使用 Map 实现<span class=" fw-cl "><span>：</span></span></p>
<p><code>const LRUCache = function(capacity) {<br>
 &nbsp;// ...<br>
 &nbsp;this.map = {};<br>
 &nbsp;// ...<br>
};</code></p>
<p>在这个算法中<span class=" fw-cl "><span>，</span></span>最复杂的应该是淘汰策略<span class=" fw-cl "><span>，</span></span>淘汰数据的时间复杂度必须是 O(1) 的话<span class=" fw-cl "><span>，</span></span>我们一定需要额外的数据结构来完成 O(1) 的淘汰策略<span class=" fw-cl "><span>。</span></span>那应该用什么样的数据结构呢<span class=" fw-cl "><span>？</span></span>答案是双向链表<span class=" fw-cl "><span>。</span></span></p>
<p>链表在插入与删除操作上<span class=" fw-cl "><span>，</span></span>都是 O(1) 时间的复杂度<span class=" fw-cl "><span>，</span></span>唯一有问题的查找元素过程比较麻烦<span class=" fw-cl "><span>，</span></span>是 O(n)<span class=" fw-cl "><span>。</span></span>但是这里我们不需要使用双向链表实现查找逻辑<span class=" fw-cl "><span>，</span></span>因为 map 已经很好的弥补了缺陷<span class=" fw-cl "><span>。</span></span></p>
<p>赘述一下<span class=" fw-cl "><span>：</span></span><strong style="">我们在写入值的时候<span class=" fw-cl "><span>，</span></span>判断缓存容量是否已经达到上限<span class=" fw-cl "><span>，</span></span>如果缓存容量达到上限时<span class=" fw-cl "><span>，</span></span>应该删除最近最少使用的数据值<span class=" fw-cl "><span>，</span></span>从而为以后的新的数据值留出空间<span class=" fw-cl "><span>。</span></span></strong></p>
<p>结合链表的话<span class=" fw-cl "><span>，</span></span>我们将刚刚写入的目标值设置为链表的首项<span class=" fw-cl "><span>，</span></span>超过限制<span class=" fw-cl "><span>，</span></span>就删除链表的尾项<span class=" fw-cl "><span>。</span></span></p>
<p>最终实现<span class=" fw-cl "><span>：</span></span></p>
<p><code>const LRUCache = function(capacity) {<br>
 &nbsp;this.map = {}<br>
 &nbsp;this.size = 0<br>
 &nbsp;this.maxSize = capacity<br>
<br>
 &nbsp;// 链表初始化<span class=" fw-cl "><span>，</span></span>初始化只有一个头和尾<br>
 &nbsp;this.head = {<br>
 &nbsp;&nbsp;&nbsp;prev: null,<br>
 &nbsp;&nbsp;&nbsp;next: null<br>
 &nbsp;}<br>
 &nbsp;this.tail = {<br>
 &nbsp;&nbsp;&nbsp;prev: this.head,<br>
 &nbsp;&nbsp;&nbsp;next: null<br>
 &nbsp;}<br>
<br>
 &nbsp;this.head.next = this.tail<br>
};<br>
<br>
LRUCache.prototype.get = function(key) {<br>
 &nbsp;if (this.map[key]) {<br>
 &nbsp;&nbsp;&nbsp;const node = this.extractNode(this.map[key])<br>
<br>
 &nbsp;&nbsp;&nbsp;// 最新访问<span class=" fw-cl "><span>，</span></span>将该节点放到链表的头部<br>
 &nbsp;&nbsp;&nbsp;this.insertNodeToHead(node)<br>
<br>
 &nbsp;&nbsp;&nbsp;return this.map[key].val<br>
 &nbsp;} <br>
 &nbsp;else {<br>
 &nbsp;&nbsp;&nbsp;return -1<br>
 &nbsp;}<br>
}<br>
<br>
LRUCache.prototype.put = function(key, value) {<br>
 &nbsp;let node<br>
<br>
 &nbsp;if (this.map[key]) {<br>
 &nbsp;&nbsp;&nbsp;// 该项已经存在<span class=" fw-cl "><span>，</span></span>更新值<br>
 &nbsp;&nbsp;&nbsp;node = this.extractNode(this.map[key])<br>
 &nbsp;&nbsp;&nbsp;node.val = value<br>
 &nbsp;} <br>
 &nbsp;else {<br>
 &nbsp;&nbsp;&nbsp;// 如该项不存在<span class=" fw-cl "><span>，</span></span>新创造节点<br>
 &nbsp;&nbsp;&nbsp;node = {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev: null,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next: null,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val: value,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key,<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;this.map[key] = node<br>
 &nbsp;&nbsp;&nbsp;this.size++<br>
 &nbsp;}<br>
<br>
 &nbsp;// 最新写入<span class=" fw-cl "><span>，</span></span>将该节点放到链表的头部<br>
 &nbsp;this.insertNodeToHead(node)<br>
<br>
 &nbsp;// 判断长度是否已经到达上限<br>
 &nbsp;if (this.size &gt; this.maxSize) {<br>
 &nbsp;&nbsp;&nbsp;const nodeToDelete = this.tail.prev<br>
 &nbsp;&nbsp;&nbsp;const keyToDelete = nodeToDelete.key<br>
 &nbsp;&nbsp;&nbsp;this.extractNode(nodeToDelete)<br>
 &nbsp;&nbsp;&nbsp;this.size--<br>
 &nbsp;&nbsp;&nbsp;delete this.map[keyToDelete]<br>
 &nbsp;}<br>
};<br>
<br>
// 插入节点到链表首项<br>
LRUCache.prototype.insertNodeToHead = function(node) {<br>
 &nbsp;const head = this.head<br>
 &nbsp;const lastFirstNode = this.head.next<br>
<br>
 &nbsp;node.prev = head<br>
 &nbsp;head.next = node<br>
 &nbsp;node.next = lastFirstNode<br>
 &nbsp;lastFirstNode.prev = node<br>
<br>
 &nbsp;return node<br>
}<br>
<br>
// 从链表中抽取节点<br>
LRUCache.prototype.extractNode = function(node) {<br>
 &nbsp;const beforeNode = node.prev<br>
 &nbsp;const afterNode = node.next<br>
<br>
 &nbsp;beforeNode.next = afterNode<br>
 &nbsp;afterNode.prev = beforeNode<br>
<br>
 &nbsp;node.prev = null<br>
 &nbsp;node.next = null<br>
<br>
 &nbsp;return node<br>
}</code></p>
<h3>链表相关题目</h3>
<p>在之前的课程中<span class=" fw-cl "><span>，</span></span>我们介绍了链表这种数据结构<span class=" fw-cl "><span>。</span></span>链表应用非常广泛<span class=" fw-cl "><span>，</span></span>这里来熟悉两个常见的对链表的操作算法<span class=" fw-cl "><span>。</span></span></p>
<h4>反转链表</h4>
<p>题目<span class=" fw-cl "><span>：</span></span>对一个单链表进行反转</p>
<p>输入<span class=" fw-cl "><span>：</span></span>1→2→3→4→5→NULL</p>
<p>输出<span class=" fw-cl "><span>：</span></span>5→4→3→2→1→NULL</p>
<p>最直观的解法是使用三个指针<span class=" fw-cl "><span>，</span></span>把头节点变成尾节点点<span class=" fw-cl "><span>，</span></span>进行遍历<span class=" fw-cl "><span>：</span></span>下一个节点 拼接到当前节点的头部<span class=" fw-cl "><span>，</span></span>以此类推<span class=" fw-cl "><span>。</span></span>这种方法的实现我们不再手写<span class=" fw-cl "><span>，</span></span>而是重点关注一下递归解法<span class=" fw-cl "><span>。</span></span></p>
<p>递归解法就要先判断递归终止条件<span class=" fw-cl "><span>，</span></span>当下一个节点为 null<span class=" fw-cl "><span>，</span></span>找到尾节点时<span class=" fw-cl "><span>，</span></span>将其返回<span class=" fw-cl "><span>。</span></span>我们从后往前进行<span class=" fw-cl "><span>：</span></span></p>
<p><code>const reverseList = head =&gt; {<br>
 &nbsp;&nbsp;// 到了尾节点<span class=" fw-cl "><span>，</span></span>则返回尾节点<br>
 &nbsp;&nbsp;if (head == null || head.next == null) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return head<br>
 &nbsp;&nbsp;}<br>
 &nbsp;&nbsp;else {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let newhead = reverseList(head.next)<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 将当前节点的一下节点的 next 指向<span class=" fw-cl "><span>，</span></span>指向为当前节点<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head.next.next = head<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 暂时情况当前节点的 next 指向<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head.next = null<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return newhead<br>
 &nbsp;&nbsp;}<br>
}</code></p>
<h4>删除链表的倒数第 N 个节点</h4>
<p>题目<span class=" fw-cl "><span>：</span></span>给定一个链表<span class=" fw-cl "><span>，</span></span>删除链表的倒数第 n 个节点<span class=" fw-cl "><span>，</span></span>并且返回链表的头结点<span class=" fw-cl "><span>。</span></span></p>
<p>输入<span class=" fw-cl "><span>：</span></span>1→2→3→4→5<span class=" fw-cl "><span>，</span></span>和 n = 2</p>
<p>输出<span class=" fw-cl "><span>：</span></span>1→2→3→5</p>
<p>这道题目的关键是如何优雅地找到倒数第 N 个节点<span class=" fw-cl "><span>。</span></span></p>
<p>我们当然可以使用两次循环<span class=" fw-cl "><span>，</span></span>第一次循环得到整个链表的长度 L<span class=" fw-cl "><span>，</span></span>那么需要删除的节点就位于 L - N + 1 位置处<span class=" fw-cl "><span>，</span></span>第二次遍历到相关位置进行操作即可<span class=" fw-cl "><span>。</span></span></p>
<p>这道题其实是可以用一次遍历来解决的<span class=" fw-cl "><span>。</span></span>我们需要使用双指针<span class=" fw-cl "><span>，</span></span>快指针 fast 先前进 N<span class=" fw-cl "><span>，</span></span>找到需要删除的节点<span class=" fw-cl "><span>；</span></span>然后慢指针 slow 从 head 开始<span class=" fw-cl "><span>，</span></span>和快指针 fast 一起前进<span class=" fw-cl "><span>，</span></span>直到 fast 走到末尾<span class=" fw-cl "><span>。</span></span> 此时 slow 的下一个节点就是要删除的节点<span class=" fw-cl "><span>，</span></span>也就是倒数第 N 个节点<span class=" fw-cl "><span>。</span></span>需要注意的是<span class=" fw-cl "><span>，</span></span>如果快指针移动 N 步之后<span class=" fw-cl "><span>，</span></span>已经到了尾部<span class=" fw-cl "><span>，</span></span>那说明需要删除的就是头节点<span class=" fw-cl "><span>。</span></span></p>
<p><code>const removeNthFromEnd = (head, n) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;if (head === null) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return head<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;if (n === 0) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return head<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;let fast = head<br>
 &nbsp;&nbsp;&nbsp;let slow = head<br>
<br>
 &nbsp;&nbsp;&nbsp;// 快指针前进 N 步<br>
 &nbsp;&nbsp;&nbsp;while (n &gt; 0) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fast = fast.next<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n--<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;// 快指针移动 N 步之后<span class=" fw-cl "><span>，</span></span>已经到了尾部<span class=" fw-cl "><span>，</span></span>那说明需要删除的就是头节点<br>
 &nbsp;&nbsp;&nbsp;if (fast === null) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return head.next<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;while (fast.next != null ){<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fast = fast.next<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slow = slow.next<br>
 &nbsp;&nbsp;&nbsp;}<br>
<br>
 &nbsp;&nbsp;&nbsp;slow.next=slow.next.next<br>
 &nbsp;&nbsp;&nbsp;return head<br>
}</code></p>
<p>这两道关于链表的题目都重点考察了对你链表结构的理解<span class=" fw-cl "><span>，</span></span>其中是用到了多个指针<span class=" fw-cl "><span>，</span></span>这也是解决链表题目的关键<span class=" fw-cl "><span>。</span></span></p>
<h3>算法学习</h3>
<p>本节课内容到这里<span class=" fw-cl "><span>，</span></span>我们只是列举了一些算法题目<span class=" fw-cl "><span>，</span></span>也算不上<span class="fw-op  "><span>「</span></span>题海战术<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>但问题都比较典型<span class=" fw-cl "><span>。</span></span>可是面对这些相对零散的内容<span class=" fw-cl "><span>，</span></span>我们应该如何入手学习呢<span class=" fw-cl "><span>？</span></span>只是一味的刷题<span class=" fw-cl "><span>，</span></span>似乎效率低下而无趣<span class=" fw-cl "><span>。</span></span></p>
<p>我认为对于算法的学习<span class=" fw-cl "><span>，</span></span>需要做到<span class="fw-op  "><span>「</span></span>分门别类<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>按照不同类别的算法思想<span class=" fw-cl "><span>，</span></span>遵循循序渐进的进步路线<span class=" fw-cl "><span>，</span></span>才会<span class="fw-op  "><span>「</span></span>越来越有感觉<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>我把算法的一些基础思想进行了归并<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">枚举</li>
  <li style="">模拟</li>
  <li style="">递归/分治</li>
  <li style="">贪心</li>
  <li style="">排序</li>
  <li style="">二分</li>
  <li style="">倍增</li>
  <li style="">构造</li>
  <li style="">前缀和/差分</li>
</ul>
<p>我们来简单总结一下这些算法基础思想<span class=" fw-cl "><span>。</span></span></p>
<h4>枚举</h4>
<p>枚举是基于已有知识来猜测<span class=" fw-cl "><span>，</span></span>印证答案的一种问题求解策略<span class=" fw-cl "><span>。</span></span>当拿到一道题目时<span class=" fw-cl "><span>，</span></span>枚举这种<span class="fw-op  "><span>「</span></span>暴力解法<span class=" fw-cl "><span>」</span></span>最容易想到<span class=" fw-cl "><span>。</span></span>这其中重点是<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">建立简洁的数学模型</li>
  <li style="">想清楚枚举哪些要素</li>
  <li style="">尝试减少枚举空间</li>
</ul>
<p>举个例子<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>一个数组中的数互不相同<span class=" fw-cl "><span>，</span></span>求其中和为 0 的数对的个数</p>
<p>最笨的方法<span class=" fw-cl "><span>：</span></span></p>
<p><code><br>
for (int i = 0; i &lt; n; ++i)<br>
 &nbsp;for (int j = 0; j &lt; n; ++j)<br>
 &nbsp;&nbsp;&nbsp;if (a[i] + a[j] == 0) ++ans;</code></p>
<p>我们来看看如何操作进行优化<span class=" fw-cl "><span>。</span></span>如果 (a, b) 是答案<span class=" fw-cl "><span>，</span></span>那么 (b, a) 也是答案<span class=" fw-cl "><span>，</span></span>因此对于这种情况只需统计一种顺序之后的答案<span class=" fw-cl "><span>，</span></span>最后再乘 2 就好了<span class=" fw-cl "><span>。</span></span></p>
<p><code><br>
for (int i = 0; i &lt; n; ++i)<br>
 &nbsp;for (int j = 0; j &lt; i; ++j)<br>
 &nbsp;&nbsp;&nbsp;if (a[i] + a[j] == 0) ++ans;</code></p>
<p>如此一来<span class=" fw-cl "><span>，</span></span>就减少了 j 的枚举范围<span class=" fw-cl "><span>，</span></span>减少了这段代码的时间开销<span class=" fw-cl "><span>。</span></span>然而这还不是最优解<span class=" fw-cl "><span>。</span></span></p>
<p>我们思考<span class=" fw-cl "><span>：</span></span>两个数是否都一定要枚举出来呢<span class=" fw-cl "><span>？</span></span>其实枚举第一个数之后<span class=" fw-cl "><span>，</span></span>题目的条件已经帮我们确定了其他的要素<span class="fw-op  "><span>（</span></span>另一个数<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>如果能找到一种方法直接判断题目要求的那个数是否存在<span class=" fw-cl "><span>，</span></span>就可以省掉枚举后一个数的时间了<span class=" fw-cl "><span>。</span></span>代码实现很简单<span class=" fw-cl "><span>，</span></span>我们就不动手实现了<span class=" fw-cl "><span>。</span></span></p>
<h4>模拟</h4>
<p>模拟<span class=" fw-cl "><span>。</span></span>顾名思义<span class=" fw-cl "><span>，</span></span>就是用计算机来模拟题目中要求的操作<span class=" fw-cl "><span>，</span></span>我们只需要按照题面的意思来写就可以了<span class=" fw-cl "><span>。</span></span>模拟题目通常具有码量大<span class=" fw-cl "><span>、</span></span>操作多<span class=" fw-cl "><span>、</span></span>思路繁复的特点<span class=" fw-cl "><span>。</span></span></p>
<p>这种题目往往考察开发者的<span class="fw-op  "><span>「</span></span>逻辑转化为代码<span class=" fw-cl "><span>」</span></span>的能力<span class=" fw-cl "><span>。</span></span>一道典型题目是<span class=" fw-cl "><span>：</span></span><a href="http://bailian.openjudge.cn/practice/3750/" title="魔兽世界">魔兽世界</a><span class=" fw-cl "><span>。</span></span></p>
<h4>递归 &amp; 分治</h4>
<p>递归的基本思想是某个函数直接或者间接地调用自身<span class=" fw-cl "><span>，</span></span>这样就把原问题的求解转换为许多性质相同但是规模更小的子问题<span class=" fw-cl "><span>。</span></span></p>
<p>递归和枚举的区别在于<span class=" fw-cl "><span>：</span></span>枚举是横向地把问题划分<span class=" fw-cl "><span>，</span></span>然后依次求解子问题<span class=" fw-cl "><span>，</span></span>而递归是把问题逐级分解<span class=" fw-cl "><span>，</span></span>是纵向的拆分<span class=" fw-cl "><span>。</span></span>比如请尝试回答这几个问题<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>孙悟空身上有多少根毛<span class=" fw-cl "><span>？</span></span>答<span class=" fw-cl "><span>：</span></span>一根毛加剩下的毛<span class=" fw-cl "><span>。</span></span> 你今年几岁<span class=" fw-cl "><span>？</span></span>答<span class=" fw-cl "><span>：</span></span>去年的岁数加一岁<span class=" fw-cl "><span>，</span></span>1999 年我出生<span class=" fw-cl "><span>。</span></span></p>
<p>递归代码最重要的两个特征<span class=" fw-cl "><span>：</span></span>结束条件和自我调用<span class=" fw-cl "><span>。</span></span></p>
<p><code>int func(传入数值) {<br>
 &nbsp;if (终止条件) return 最小子问题解;<br>
 &nbsp;return func(缩小规模);<br>
}</code></p>
<p>写递归的技巧<span class=" fw-cl "><span>，</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>明白一个函数的作用并相信它能完成这个任务<span class=" fw-cl "><span>，</span></span>千万不要试图跳进细节<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span> 千万不要跳进这个函数里面企图探究更多细节<span class=" fw-cl "><span>，</span></span>否则就会陷入无穷的细节无法自拔<span class=" fw-cl "><span>，</span></span>人脑能压几个栈啊<span class=" fw-cl "><span>。</span></span></p>
<p>先举个最简单的例子<span class=" fw-cl "><span>：</span></span>遍历二叉树<span class=" fw-cl "><span>。</span></span></p>
<p><code>void traverse(TreeNode* root) {<br>
 &nbsp;if (root == nullptr) return;<br>
 &nbsp;traverse(root-&gt;left);<br>
 &nbsp;traverse(root-&gt;right);<br>
}</code></p>
<p>这几行代码就足以遍历任何一棵二叉树了<span class=" fw-cl "><span>。</span></span>对于递归函数 traverse(root) <span class=" fw-cl "><span>，</span></span>我们只要相信<span class=" fw-cl "><span>：</span></span>给它一个根节点 root<span class=" fw-cl "><span>，</span></span>它就能遍历这棵树<span class=" fw-cl "><span>，</span></span>因为写这个函数不就是为了这个目的吗<span class=" fw-cl "><span>？</span></span></p>
<p>那么遍历一棵 N 叉数呢<span class=" fw-cl "><span>？</span></span></p>
<p><code>void traverse(TreeNode* root) {<br>
 &nbsp;if (root == nullptr) return;<br>
 &nbsp;for (child : root-&gt;children) traverse(child);<br>
}</code></p>
<p>总之<span class=" fw-cl "><span>，</span></span>还是那句话<span class=" fw-cl "><span>：</span></span>给它一个根节点 root<span class=" fw-cl "><span>，</span></span>它就能遍历这棵树<span class=" fw-cl "><span>，</span></span>不管你是几个叉<span class=" fw-cl "><span>。</span></span></p>
<p>典型题目<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>给一棵二叉树<span class=" fw-cl "><span>，</span></span>和一个目标值<span class=" fw-cl "><span>，</span></span>节点上的值有正有负<span class=" fw-cl "><span>，</span></span>返回树中和等于目标值的路径条数</p>
<p>这道题目解法很多<span class=" fw-cl "><span>，</span></span>也比较典型<span class=" fw-cl "><span>。</span></span>这里我们只谈思想<span class=" fw-cl "><span>，</span></span>具体实现就不展开<span class=" fw-cl "><span>。</span></span></p>
<p>分治算法可以分三步走<span class=" fw-cl "><span>：</span></span>分解 -&gt; 解决 -&gt; 合并<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">分解原问题为结构相同的子问题</li>
  <li style="">分解到某个容易求解的边界之后<span class=" fw-cl "><span>，</span></span>进行递归求解</li>
  <li style="">将子问题的解合并成原问题的解</li>
</ul>
<p>归并排序是最典型的分治算法<span class=" fw-cl "><span>。</span></span></p>
<p><code>void mergeSort(一个数组) {<br>
 &nbsp;if (可以很容易处理) return<br>
 &nbsp;mergeSort(左半个数组)<br>
 &nbsp;mergeSort(右半个数组)<br>
 &nbsp;merge(左半个数组, 右半个数组)<br>
}</code></p>
<p>分治算法的套路就是前面说的三步走<span class=" fw-cl "><span>：</span></span>分解 -&gt; 解决 -&gt; 合并<span class=" fw-cl "><span>：</span></span>先左右分解<span class=" fw-cl "><span>，</span></span>再处理合并<span class=" fw-cl "><span>，</span></span>回溯就是在退栈<span class=" fw-cl "><span>，</span></span>就相当于后序遍历了<span class=" fw-cl "><span>。</span></span>至于 merge 函数<span class=" fw-cl "><span>，</span></span>相当于两个有序链表的合并<span class=" fw-cl "><span>。</span></span></p>
<p>LeetCode 有<a href="https://leetcode.com/explore/learn/card/recursion-i/" title="递归专题练习">递归专题练习</a> LeetCode 上有<a href="https://leetcode-cn.com/tag/divide-and-conquer/?utm_source=LCUS&amp;utm_medium=ip_redirect_o_uns&amp;utm_campaign=transfer2china" title="分治算法的专项练习">分治算法的专项练习</a></p>
<h4>贪心</h4>
<p>贪心算法顾名思义就是只看眼前<span class=" fw-cl "><span>，</span></span>并不考虑以后可能造成的影响<span class=" fw-cl "><span>。</span></span>可想而知<span class=" fw-cl "><span>，</span></span>并不是所有的时候贪心法都能获得最优解<span class=" fw-cl "><span>。</span></span></p>
<p>最常见的贪心有两种<span class=" fw-cl "><span>。</span></span>一种是<span class=" fw-cl "><span>：</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>将 XXX 按照某某顺序排序<span class=" fw-cl "><span>，</span></span>然后按某种顺序<span class="fw-op  "><span>（</span></span>例如从小到大<span class=" fw-cl "><span>）</span></span>处理<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>另一种是<span class=" fw-cl "><span>：</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>我们每次都取 XXX 中最大/小的东西<span class=" fw-cl "><span>，</span></span>并更新 XXX<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>有时<span class="fw-op  "><span>「</span></span>XXX 中最大/小的东西<span class=" fw-cl "><span>」</span></span>可以优化<span class=" fw-cl "><span>，</span></span>比如用优先队列维护<span class=" fw-cl "><span>。</span></span>这两种方式分别对应了离线的情况以及在线的情况<span class=" fw-cl "><span>。</span></span></p>
<p>相关题目<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style=""><a href="https://www.luogu.org/problem/P2949" title="工作调度 Work Scheduling">工作调度 Work Scheduling</a></li>
  <li style=""><a href="https://www.luogu.org/problem/P1209" title="修理牛棚 Barn Repair">修理牛棚 Barn Repair</a></li>
  <li style=""><a href="https://www.luogu.org/problem/P2123" title="皇后游戏">皇后游戏</a></li>
</ul>
<h4>二分</h4>
<p>以二分搜索为例<span class=" fw-cl "><span>，</span></span>它是用来在一个有序数组中查找某一元素的算法<span class=" fw-cl "><span>。</span></span>它每次考察数组当前部分的中间元素<span class=" fw-cl "><span>，</span></span>如果中间元素刚好是要找的<span class=" fw-cl "><span>，</span></span>就结束搜索过程<span class=" fw-cl "><span>；</span></span>如果中间元素小于所查找的值<span class=" fw-cl "><span>，</span></span>那么左侧的只会更小<span class=" fw-cl "><span>，</span></span>不会有所查找的元素<span class=" fw-cl "><span>，</span></span>只需要到右侧去找就好了<span class=" fw-cl "><span>；</span></span>如果中间元素大于所查找的值<span class=" fw-cl "><span>，</span></span>同理<span class=" fw-cl "><span>，</span></span>右侧的只会更大而不会有所查找的元素<span class=" fw-cl "><span>，</span></span>所以只需要到左侧去找<span class=" fw-cl "><span>。</span></span></p>
<p>在二分搜索过程中<span class=" fw-cl "><span>，</span></span>每次都把查询的区间减半<span class=" fw-cl "><span>，</span></span>因此对于一个长度为 n 的数组<span class=" fw-cl "><span>，</span></span>至多会进行 log(n) 次查找<span class=" fw-cl "><span>。</span></span></p>
<p>一定需要注意的是<span class=" fw-cl "><span>，</span></span>这里的有序是广义的有序<span class=" fw-cl "><span>，</span></span>如果一个数组中的左侧或者右侧都满足某一种条件<span class=" fw-cl "><span>，</span></span>而另一侧都不满足这种条件<span class=" fw-cl "><span>，</span></span>也可以看作是一种有序<span class=" fw-cl "><span>。</span></span></p>
<p>二分法把一个寻找极值的问题转化成一个判定的问题<span class="fw-op  "><span>（</span></span>用二分搜索来找这个极值<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>类比枚举法<span class=" fw-cl "><span>，</span></span>我们当时是枚举答案的可能情况<span class=" fw-cl "><span>，</span></span>现在由于单调性<span class=" fw-cl "><span>，</span></span>我们不再需要一个个枚举<span class=" fw-cl "><span>，</span></span>利用二分的思路<span class=" fw-cl "><span>，</span></span>就可以用更优的方法解决<span class="fw-op  "><span>「</span></span>最大值最小<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>、</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>最小值最大<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>这种解法也成为是<span class="fw-op  "><span>「</span></span>二分答案<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>常见于解题报告中<span class=" fw-cl "><span>。</span></span></p>
<p>比如<span class=" fw-cl "><span>：</span></span><a href="https://www.luogu.org/problem/P1873" title="砍树问题">砍树问题</a><span class=" fw-cl "><span>，</span></span>我们可以在 1 到 1000000000<span class="fw-op  "><span>（</span></span>10 亿<span class=" fw-cl "><span>）</span></span>中枚举答案<span class=" fw-cl "><span>，</span></span>但是这种朴素写法肯定拿不到满分<span class=" fw-cl "><span>，</span></span>因为从 1 跑到 10 亿太耗时间<span class=" fw-cl "><span>。</span></span>我们可以对答案进行 1 到 10 亿的二分<span class=" fw-cl "><span>，</span></span>其中<span class=" fw-cl "><span>，</span></span>每次都对其进行检查可行性<span class="fw-op  "><span>（</span></span>一般都是使用贪心法<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>&nbsp;</p>
<p>依照此思想<span class=" fw-cl "><span>，</span></span>我们还有三分法等展开算法<span class=" fw-cl "><span>。</span></span></p>
<h4>倍增</h4>
<p>倍增法<span class=" fw-cl "><span>，</span></span>通过字面意思来看就是翻倍<span class=" fw-cl "><span>。</span></span>这个方法在很多算法中均有应用<span class=" fw-cl "><span>，</span></span>其中最常用的就是 RMQ 问题和求 LCA<span class=" fw-cl "><span>。</span></span></p>
<p>RMQ 是英文 Range Maximum/Minimum Query 的缩写<span class=" fw-cl "><span>，</span></span>表示区间最大<span class="fw-op  "><span>（</span></span>最小<span class=" fw-cl "><span>）</span></span>值<span class=" fw-cl "><span>。</span></span>解决 RMQ 问题的主要方法有两种<span class=" fw-cl "><span>，</span></span>分别是 ST 表和线段树<span class=" fw-cl "><span>，</span></span>具体请参见 ST 表和 线段树内容<span class=" fw-cl "><span>。</span></span></p>
<h4>构造</h4>
<p>构造针对的问题的答案往往具有某种规律性<span class=" fw-cl "><span>，</span></span>使得在问题规模迅速增大的时候<span class=" fw-cl "><span>，</span></span>仍然有机会比较容易地得到答案<span class=" fw-cl "><span>。</span></span></p>
<p>这种思想我们接触的比较少<span class=" fw-cl "><span>，</span></span>主要体现了数学解题方法啊<span class=" fw-cl "><span>。</span></span>比较典型的有<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style=""><a href="https://www.luogu.org/problemnew/show/P3599" title="Luogu P3599 Koishi Loves Construction">Luogu P3599 Koishi Loves Construction</a></li>
  <li style=""><a href="http://codeforces.com/problemset/problem/743/C" title="Vladik and fractions">Vladik and fractions</a></li>
  <li style=""><a href="https://atcoder.jp/contests/agc032/tasks/agc032_b" title="AtCoder Grand Contest 032 B">AtCoder Grand Contest 032 B</a></li>
</ul>
<p>这里我们不再介绍<span class=" fw-cl "><span>，</span></span>感兴趣的同学可以进行研究<span class=" fw-cl "><span>。</span></span></p>
<h4>前缀和 &amp; 差分</h4>
<p>前缀和是一种重要的预处理<span class=" fw-cl "><span>，</span></span>能大大降低查询的时间复杂度<span class=" fw-cl "><span>。</span></span>我们可以简单理解为<span class="fw-op  "><span>「</span></span>数列的前 n 项的和<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>其实前缀和几乎都是基于容斥原理<span class=" fw-cl "><span>。</span></span></p>
<p>比如这道题目<span class=" fw-cl "><span>：</span></span></p>
<blockquote><br></blockquote>
<p>有 N 个的正整数放到数组 A 里<span class=" fw-cl "><span>，</span></span>现在要求一个新的数组 B<span class=" fw-cl "><span>，</span></span>新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和<span class=" fw-cl "><span>。</span></span></p>
<p>对于这道题<span class=" fw-cl "><span>，</span></span>我们有两种做法<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">把对数组 A 的累加依次放入数组 B 中<span class=" fw-cl "><span>。</span></span></li>
  <li style="">递推<span class=" fw-cl "><span>：</span></span> B[i] = B[i-1] + A[i]</li>
</ul>
<p>我们看第二种方法采用前缀和的思想<span class=" fw-cl "><span>，</span></span>无疑更加优秀<span class=" fw-cl "><span>。</span></span></p>
<p>其他相关题目<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style=""><a href="https://www.luogu.org/problem/U53525" title="前缀和">前缀和</a></li>
  <li style=""><a href="https://www.luogu.org/problem/U69096" title="前缀和的逆">前缀和的逆</a></li>
  <li style=""><a href="https://www.luogu.org/problem/AT2412" title="最大の和">最大の和</a></li>
  <li style=""><a href="https://www.luogu.org/problem/P3131" title="Subsequences Summing to Sevens">Subsequences Summing to Sevens</a></li>
</ul>
<p>更复杂些<span class=" fw-cl "><span>，</span></span>可以延伸出<span class=" fw-cl "><span>：</span></span>基于 DP 计算高维前缀和<span class=" fw-cl "><span>，</span></span>树上前缀和<span class=" fw-cl "><span>。</span></span></p>
<p>最后<span class=" fw-cl "><span>，</span></span>差分是一种和前缀和相对的策略<span class=" fw-cl "><span>。</span></span>这种策略是求相邻两数的差<span class=" fw-cl "><span>。</span></span>相关题目<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style=""><a href="https://loj.ac/problem/132" title="树状数组 3 ：区间修改，区间查询">树状数组 3 <span class=" fw-cl "><span>：</span></span>区间修改<span class=" fw-cl "><span>，</span></span>区间查询</a></li>
  <li style=""><a href="https://www.luogu.org/problem/P3397" title="地毯">地毯</a></li>
  <li style=""><a href="https://www.luogu.org/problem/P3128" title="最大流">最大流</a></li>
</ul>
<h4>思想归并</h4>
<p>我列举了 9 中算法基本思想<span class=" fw-cl "><span>，</span></span>并配上多到典型题目<span class=" fw-cl "><span>。</span></span>实际上<span class=" fw-cl "><span>，</span></span>读者可以根据自身情况酌情进行了解<span class=" fw-cl "><span>，</span></span>在解题外更重要的是体会这些算法思想<span class=" fw-cl "><span>。</span></span>比如我留一个小作业<span class=" fw-cl "><span>：</span></span>在这三节课中所有讲到的算法中<span class=" fw-cl "><span>，</span></span>你能按照这 9 种思想进行归类么<span class=" fw-cl "><span>？</span></span></p>
<p>请动手尝试<span class=" fw-cl "><span>，</span></span>我认为我们可以有解不出来的题目<span class=" fw-cl "><span>，</span></span>但是对于算法思想的理解至关重要<span class=" fw-cl "><span>。</span></span></p>
<h3>总结</h3>
<p>到此我们关于算法的三节课就结束了<span class=" fw-cl "><span>。</span></span>整体来说<span class=" fw-cl "><span>，</span></span>算法需要应试<span class=" fw-cl "><span>。</span></span>算法就像弹簧一样<span class=" fw-cl "><span>，</span></span>只要你有信心<span class=" fw-cl "><span>，</span></span>态度正确<span class=" fw-cl "><span>，</span></span>不畏难<span class=" fw-cl "><span>，</span></span>一定就可以攻克它<span class=" fw-cl "><span>。</span></span></p>
<p>从今天起<span class=" fw-cl "><span>，</span></span>下一个决心<span class=" fw-cl "><span>，</span></span>制定一个计划<span class=" fw-cl "><span>，</span></span>通过不断练习<span class=" fw-cl "><span>，</span></span>提升自己解算法题的能力<span class=" fw-cl "><span>。</span></span>当然学习数据结构和算法不仅仅对面试有帮助<span class=" fw-cl "><span>，</span></span>对于程序的强健性<span class=" fw-cl "><span>、</span></span>稳定性<span class=" fw-cl "><span>、</span></span>性能来说<span class=" fw-cl "><span>，</span></span>算法虽然只是细节<span class=" fw-cl "><span>，</span></span>但却是最重要的一部分之一<span class=" fw-cl "><span>。</span></span>比如 AVL 或者 B+ 树<span class=" fw-cl "><span>，</span></span>可能除了在学校的大作业<span class=" fw-cl "><span>，</span></span>一辈子也不会有机会实现一个出来<span class=" fw-cl "><span>，</span></span>但你学会了分析和比较类似算法的能力, 有了搜索树的知识<span class=" fw-cl "><span>，</span></span>你才能真正理解为什么 InnoDB 索引要用 B+ 树<span class=" fw-cl "><span>，</span></span>你才能明白 like "abc%" 会不会使用索引<span class=" fw-cl "><span>，</span></span>而不是人云亦云<span class=" fw-cl "><span>、</span></span>知其然不知其所以然<span class=" fw-cl "><span>。</span></span></p>
<p>这一节课我挑选的典型算法都不算困难<span class=" fw-cl "><span>，</span></span>但都能体现算法的思想闪光点<span class=" fw-cl "><span>，</span></span>适合类推<span class=" fw-cl "><span>。</span></span>但实话说<span class=" fw-cl "><span>，</span></span>这节课的内容相对零散<span class=" fw-cl "><span>，</span></span>算法的思想却是可以归类的<span class=" fw-cl "><span>，</span></span>也留给大家一个作业<span class=" fw-cl "><span>，</span></span>将上述算法进行思想归类<span class=" fw-cl "><span>，</span></span>并在每个归类下再找一道题目进行扩充<span class=" fw-cl "><span>。</span></span>这样的学习方法一定会让你有所收获<span class=" fw-cl "><span>，</span></span>在全部课程结束后<span class=" fw-cl "><span>，</span></span>我也会和大家针对这个<span class="fw-op  "><span>「</span></span>作业<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>进行交流<span class=" fw-cl "><span>，</span></span>也分享出我的更多算法心得<span class=" fw-cl "><span>。</span></span></p><p><span style="display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);">备案号:YXX1yLrx0kvtjAgXwzFk9NJ</span></p>
</body>
</html>