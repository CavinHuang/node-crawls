<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>第 46 节离不开的网络基础</h1>
  <p>开启本讲之前<span class=" fw-cl "><span>，</span></span>我想先问一句<span class=" fw-cl "><span>：</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>网络基础对于前端程序员重不重要<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>？</span></span>其实答案是毫无疑问的<span class=" fw-cl "><span>，</span></span>如果读者仍然对此有怀疑<span class=" fw-cl "><span>，</span></span>那可能你还是刚入行的程序员<span class=" fw-cl "><span>，</span></span>相信随着工作经验的增加<span class=" fw-cl "><span>，</span></span>你会越来越能意识到网络基础的重要性<span class=" fw-cl "><span>。</span></span>事实上<span class=" fw-cl "><span>，</span></span>具备必要的网络基础<span class=" fw-cl "><span>，</span></span>是对于一个程序员的要求<span class=" fw-cl "><span>，</span></span>绝不仅仅是对前端工程师的要求<span class=" fw-cl "><span>，</span></span>更何况在 Node.js 发展当下<span class=" fw-cl "><span>，</span></span>学好网络知识更是对于前途发展意义重大<span class=" fw-cl "><span>。</span></span></p>
<p>网络基础其实并不难<span class=" fw-cl "><span>，</span></span>但绝不仅仅是一讲的内容就能<span class="fw-op  "><span>「</span></span>融会贯通<span class=" fw-cl "><span>」</span></span>的<span class=" fw-cl "><span>，</span></span>系统性地学习还需要回炉到大学课本<span class=" fw-cl "><span>。</span></span>本讲<span class=" fw-cl "><span>，</span></span>我从网络基础概念和场景应用两大方面来讲解<span class=" fw-cl "><span>，</span></span>主要内容如下<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-ccc1e70f37a5307f56d3a8da8fe81887.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:35.07142857142857% 0" data-src="https://pic4.zhimg.com/v2-ccc1e70f37a5307f56d3a8da8fe81887.png">加载中...</span></figure>
<h3>网络基础知识</h3>
<p>有一个说法——<span class="fw-op  "><span>「</span></span>大厂前端面试对 HTTP 的要求比 CSS 还要高<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>确实从面试的频率上<span class=" fw-cl "><span>，</span></span>以 HTTP 为核心的网络基础考察绝对是重点<span class=" fw-cl "><span>。</span></span>这些考察点其实并不难<span class=" fw-cl "><span>，</span></span>都是基础概念<span class=" fw-cl "><span>，</span></span>我们先从几个高频考点入手<span class=" fw-cl "><span>。</span></span></p>
<p>更为基础的内容<span class=" fw-cl "><span>，</span></span>比如计算机网络体系结构<span class=" fw-cl "><span>，</span></span>OSI 七层协议等我们不再提及<span class=" fw-cl "><span>，</span></span>必要知识需要读者先行了解<span class=" fw-cl "><span>。</span></span></p>
<h4>TCP 和 UDP</h4>
<p>TCP 和 UDP 是运输层的两种协议<span class=" fw-cl "><span>，</span></span>什么是运输层呢<span class=" fw-cl "><span>？</span></span></p>
<blockquote><br></blockquote>
<p>运输层<span class="fw-op  "><span>（</span></span>Transport Layer<span class=" fw-cl "><span>）</span></span>就是负责向两台主机进程之间的通信提供通用的数据传输服务<span class=" fw-cl "><span>，</span></span>应用进程利用该服务传送应用层报文<span class=" fw-cl "><span>。</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>通用的<span class=" fw-cl "><span>」</span></span>是指并不针对某一个特定的网络应用<span class=" fw-cl "><span>，</span></span>而是多种应用可以使用同一个运输层服务<span class=" fw-cl "><span>。</span></span></p>
<p>对于 TCP 和 UDP 这两种协议的理解<span class=" fw-cl "><span>，</span></span>我们可以主要从其特点和区别来掌握<span class=" fw-cl "><span>。</span></span></p>
<p>传输控制协议 TCP<span class="fw-op  "><span>（</span></span>Transmisson Control Protocol<span class=" fw-cl "><span>）</span></span>是一种<strong style="">面向连接的<span class=" fw-cl "><span>、</span></span>可靠的</strong>数据传输服务<span class=" fw-cl "><span>。</span></span>如何理解可靠呢<span class=" fw-cl "><span>？</span></span>通过 TCP 协议传送数据可以无差错<span class=" fw-cl "><span>、</span></span>不丢失<span class=" fw-cl "><span>、</span></span>不重复<span class=" fw-cl "><span>、</span></span>并且按序到达<span class=" fw-cl "><span>；</span></span>如何理解面向连接呢<span class=" fw-cl "><span>？</span></span>就像我们打电话一样<span class=" fw-cl "><span>，</span></span>通过拿起电话和挂掉电话来表示连接的建立和中断<span class=" fw-cl "><span>。</span></span>此外<span class=" fw-cl "><span>，</span></span>TCP 的特点有<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">TCP 提供全双工通信<span class=" fw-cl "><span>，</span></span>也就是说双方在连接建立之后<span class=" fw-cl "><span>，</span></span>都可以在任何时候进行数据发送</li>
  <li style="">TCP 两端连接都设有缓存<span class=" fw-cl "><span>，</span></span>在发送和接收时都可以利用缓存临时存放数据</li>
  <li style="">TCP 是面向字节流的</li>
</ul>
<p>用户数据协议 UDP<span class="fw-op  "><span>（</span></span>User Datagram Protocol<span class=" fw-cl "><span>）</span></span>是一种<strong style="">无连接的<span class=" fw-cl "><span>、</span></span>不保证数据传输的可靠性</strong>的运输层协议<span class=" fw-cl "><span>。</span></span>其特点<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">UDP 无连接</li>
  <li style="">UDP 不保证可靠性<span class=" fw-cl "><span>，</span></span>因此不需要维持复杂的链接状态</li>
  <li style="">UDP 是面向报文的</li>
  <li style="">UDP 没有拥塞控制</li>
  <li style="">UDP 支持一对一<span class=" fw-cl "><span>、</span></span>一对多<span class=" fw-cl "><span>、</span></span>多对一和多对多的交互通信</li>
</ul>
<p>因此根据 TCP 和 UDP 的特点<span class=" fw-cl "><span>，</span></span>可以选择不同的协议进行场景应用<span class=" fw-cl "><span>，</span></span>比如对于直播<span class=" fw-cl "><span>、</span></span>实时视频会议<span class=" fw-cl "><span>，</span></span>你认为哪种协议更加适合呢<span class=" fw-cl "><span>？</span></span></p>
<p>因为 UDP 传输速度更快<span class=" fw-cl "><span>、</span></span>效率更高<span class=" fw-cl "><span>，</span></span>UDP 没有拥塞控制<span class=" fw-cl "><span>，</span></span>所以网络出现拥塞不会使源主机的发送速率降低<span class=" fw-cl "><span>，</span></span>且直播<span class=" fw-cl "><span>、</span></span>实时视频会议丢失一两帧内容对于应用并没有体验性的影响<span class=" fw-cl "><span>，</span></span>因此<span class=" fw-cl "><span>，</span></span>UDP 对于直播<span class=" fw-cl "><span>、</span></span>实时视频会议的场景会更加适合<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">这些内容对应的面试考点<span class=" fw-cl "><span>：</span></span></strong></p>
<ul>
  <li style="">比较 TCP 和 UDP</li>
  <li style="">TCP 和 UDP 的应用场景</li>
  <li style="">TCP 如何保证传输的可靠性</li>
</ul>
<p>前两项考点我们已经有所涉及<span class=" fw-cl "><span>，</span></span>现在针对 TCP 如何保证传输的可靠性进行展开<span class=" fw-cl "><span>。</span></span>TCP 保证传输的可靠性主要手段有以下几个<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">数据包校验<span class=" fw-cl "><span>：</span></span>如果接收端校验出包有错<span class=" fw-cl "><span>，</span></span>则进行丢弃且不进行相应<span class=" fw-cl "><span>。</span></span></li>
  <li style="">对失序数据包重排序<span class=" fw-cl "><span>：</span></span>TCP 协议会对失序数据包进行排序<span class=" fw-cl "><span>，</span></span>然后再交给应用层<span class=" fw-cl "><span>。</span></span></li>
  <li style="">丢弃重复数据<span class=" fw-cl "><span>。</span></span></li>
  <li style="">应答机制<span class=" fw-cl "><span>：</span></span>当接收端接收到数据之后<span class=" fw-cl "><span>，</span></span>将发送确认信息<span class=" fw-cl "><span>。</span></span></li>
  <li style="">超时重发<span class=" fw-cl "><span>：</span></span>当发送端发出数据后<span class=" fw-cl "><span>，</span></span>它启动一个定时器<span class=" fw-cl "><span>，</span></span>如果超出计时器的时限<span class=" fw-cl "><span>，</span></span>将重发这个报文段<span class=" fw-cl "><span>。</span></span></li>
  <li style="">流量控制<span class=" fw-cl "><span>：</span></span>前面提到过<span class=" fw-cl "><span>，</span></span>TCP 连接的每一方都有固定大小的缓冲空间<span class=" fw-cl "><span>，</span></span>可防止接收端缓冲区溢出<span class=" fw-cl "><span>，</span></span>这就是流量控制<span class=" fw-cl "><span>。</span></span>TCP 使用可变大小的滑动窗口协议来进行流量控制<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>最后再补充一点单工/半双工/双工数据通信的概念区分<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">单工数据传输是数据只能在一个方向上传输<span class=" fw-cl "><span>；</span></span></li>
  <li style="">半双工数据传输允许数据在两个方向上传输<span class=" fw-cl "><span>，</span></span>但是<span class=" fw-cl "><span>，</span></span>在某一时刻<span class=" fw-cl "><span>，</span></span>只允许数据在一个方向上传输<span class=" fw-cl "><span>，</span></span>它实际上是一种切换方向的单工通信<span class=" fw-cl "><span>；</span></span></li>
  <li style="">全双工数据通信允许数据同时在两个方向上传输<span class=" fw-cl "><span>，</span></span>因此<span class=" fw-cl "><span>，</span></span>全双工通信是两个单工通信方式的结合<span class=" fw-cl "><span>，</span></span>它要求发送设备和接收设备都有独立的接收和发送能力<span class=" fw-cl "><span>。</span></span></li>
</ul>
<h4>三次握手和四次挥手</h4>
<p>上面我们说到 TCP 是面向连接的<span class=" fw-cl "><span>，</span></span>那么这个连接过程就涉及到著名的三次握手和四次挥手了<span class=" fw-cl "><span>。</span></span>也许对于这些名词我们已经<span class="fw-op  "><span>「</span></span>听烂了<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>但是你是否有真正的掌握呢<span class=" fw-cl "><span>？</span></span></p>
<p>三次握手<span class=" fw-cl "><span>，</span></span>简单来说是指当建立一个 TCP 连接时<span class=" fw-cl "><span>，</span></span>整个建立过程需要客户端和服务端一共交互三个包<span class=" fw-cl "><span>，</span></span>三次握手的目的是连接服务器的指定端口<span class=" fw-cl "><span>，</span></span>建立 TCP 连接<span class=" fw-cl "><span>，</span></span>并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息<span class=" fw-cl "><span>。</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic1.zhimg.com/v2-75bd9df23ada8082fa999625b156d961.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:34.90878938640133% 0" data-src="https://pic1.zhimg.com/v2-75bd9df23ada8082fa999625b156d961.png">加载中...</span></figure>
<p>具体来说 <strong style="">第一次握手</strong></p>
<p>开始建立连接时<span class=" fw-cl "><span>，</span></span>客户端向服务器发出连接请求报文<span class=" fw-cl "><span>，</span></span>报文首部中的同部位 SYN = 1<span class=" fw-cl "><span>，</span></span>同时选择一个初始序列号 seq = x <span class=" fw-cl "><span>，</span></span>这时客户端进程进入了 SYN-SENT <span class="fw-op  "><span>（</span></span>同步已发送状态<span class=" fw-cl "><span>）</span></span>状态<span class=" fw-cl "><span>，</span></span>等待服务器确认<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">第二次握手</strong></p>
<p>服务器收到 syn 包后<span class=" fw-cl "><span>，</span></span>如果同意连接<span class=" fw-cl "><span>，</span></span>则发出确认报文<span class=" fw-cl "><span>；</span></span>确认报文 ACK = 1<span class=" fw-cl "><span>，</span></span>SYN = 1<span class=" fw-cl "><span>，</span></span>确认号是 ack = x + 1<span class=" fw-cl "><span>，</span></span>同时也要为自己初始化一个序列号 seq = y<span class=" fw-cl "><span>，</span></span>此时服务器进程进入了 SYN-RCVD<span class="fw-op  "><span>（</span></span>同步收到<span class=" fw-cl "><span>）</span></span>状态<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">第三次握手</strong></p>
<p>客户端收到服务器的 SYN + ACK 包<span class=" fw-cl "><span>，</span></span>要向服务器给出确认<span class=" fw-cl "><span>。</span></span>确认报文的 ACK = 1<span class=" fw-cl "><span>，</span></span>ack = y + 1<span class=" fw-cl "><span>，</span></span>自己的序列号 seq = x + 1<span class=" fw-cl "><span>。</span></span>此时<span class=" fw-cl "><span>，</span></span>TCP 连接建立<span class=" fw-cl "><span>，</span></span>客户端进入 ESTABLISHED <span class="fw-op  "><span>（</span></span>已建立连接<span class=" fw-cl "><span>）</span></span>状态<span class=" fw-cl "><span>。</span></span></p>
<p>四次挥手是指<span class=" fw-cl "><span>，</span></span>TCP 连接的终端需要客户端和服务端总共发送四个包<span class=" fw-cl "><span>，</span></span>客户端或者服务器端均可主动发起挥手动作<span class=" fw-cl "><span>。</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-6bce7f65f99bda43ade03ff64aafafcb.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:39.84375% 0" data-src="https://pic3.zhimg.com/v2-6bce7f65f99bda43ade03ff64aafafcb.png">加载中...</span></figure>
<p>具体来说<span class=" fw-cl "><span>，</span></span><strong style="">第一次挥手</strong></p>
<p>客户端进程发出连接释放报文<span class=" fw-cl "><span>，</span></span>并且停止发送数据<span class=" fw-cl "><span>。</span></span>释放数据报文首部 FIN = 1<span class=" fw-cl "><span>，</span></span>其序列号为 seq = u<span class="fw-op  "><span>（</span></span>等于前面已经传送过来的数据最后一个字节的序号加 1<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>此时<span class=" fw-cl "><span>，</span></span>客户端进入 FIN-WAIT-1<span class="fw-op  "><span>（</span></span>终止等待 1<span class=" fw-cl "><span>）</span></span>状态<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">第二次挥手</strong></p>
<p>服务器收到连接释放报文<span class=" fw-cl "><span>，</span></span>发出确认报文<span class=" fw-cl "><span>，</span></span>ACK = 1<span class=" fw-cl "><span>，</span></span>ack = u + 1<span class=" fw-cl "><span>，</span></span>并且带上自己的序列号 seq = v<span class="fw-op  "><span>（</span></span>客户端已经没有数据要发送了<span class=" fw-cl "><span>，</span></span>但是服务器若发送数据<span class=" fw-cl "><span>，</span></span>客户端依然要接受<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>此时<span class=" fw-cl "><span>，</span></span>服务端就进入了 CLOSE-WAIT<span class="fw-op  "><span>（</span></span>关闭等待<span class=" fw-cl "><span>）</span></span>状态<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">第三次挥手</strong></p>
<p>服务器将最后的数据发送完毕后<span class=" fw-cl "><span>，</span></span>就向客户端发送连接中断报文<span class=" fw-cl "><span>，</span></span>FIN = 1<span class=" fw-cl "><span>，</span></span>ack = u + 1<span class=" fw-cl "><span>，</span></span>由于在半关闭状态<span class=" fw-cl "><span>，</span></span>服务器很可能又发送了一些数据<span class=" fw-cl "><span>，</span></span>假定此时的序列号为 seq = w<span class=" fw-cl "><span>，</span></span>此时<span class=" fw-cl "><span>，</span></span>服务器就进入了 LAST-ACK<span class="fw-op  "><span>（</span></span>最后确认<span class=" fw-cl "><span>）</span></span>状态<span class=" fw-cl "><span>，</span></span>等待客户端的确认<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">第四次挥手</strong></p>
<p>客户端收到服务器的连接释放报文后<span class=" fw-cl "><span>，</span></span>必须发出确认<span class=" fw-cl "><span>，</span></span>ACK = 1<span class=" fw-cl "><span>，</span></span>ack = w + 1<span class=" fw-cl "><span>，</span></span>而自己的序列号是 seq = u + 1<span class=" fw-cl "><span>。</span></span>此时<span class=" fw-cl "><span>，</span></span>客户端就进入了 TIME-WAIT<span class="fw-op  "><span>（</span></span>时间等待<span class=" fw-cl "><span>）</span></span>状态<span class=" fw-cl "><span>。</span></span></p>
<p>服务器只要收到了客户端发出的确认<span class=" fw-cl "><span>，</span></span>立即进入 CLOSED 状态<span class=" fw-cl "><span>。</span></span>同样<span class=" fw-cl "><span>，</span></span>撤销 TCB 后<span class=" fw-cl "><span>，</span></span>就结束了这次的 TCP 连接<span class="fw-op  "><span>（</span></span>注意此时 TCP 连接还没有释放<span class=" fw-cl "><span>，</span></span>必须经过 2MSL<span class="fw-op  "><span>（</span></span>最长报文段寿命<span class=" fw-cl "><span>）</span></span>的时间后<span class=" fw-cl "><span>，</span></span>当客户端撤销相应的 TCB 后<span class=" fw-cl "><span>，</span></span>才进入 CLOSED 状态<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>服务器只要收到了客户端发出的确认<span class=" fw-cl "><span>，</span></span>立即进入 CLOSED 状态<span class=" fw-cl "><span>。</span></span>同样<span class=" fw-cl "><span>，</span></span>撤销 TCB 后<span class=" fw-cl "><span>，</span></span>就结束了这次的 TCP 连接<span class=" fw-cl "><span>。</span></span></p>
<p><strong style="">这些内容对应的面试考点<span class=" fw-cl "><span>：</span></span></strong></p>
<ul>
  <li style="">三次握手和四次挥手过程</li>
  <li style="">三次握手和四次挥手的必要性<span class=" fw-cl "><span>，</span></span>不做行不行<span class=" fw-cl "><span>？</span></span></li>
</ul>
<h4>HTTP 响应常见状态码</h4>
<p>HTTP 响应常见状态码这里只做一个速查总结<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">100-199<span class=" fw-cl "><span>：</span></span>表示成功接收请求, 要求客户端继续提交下一次请求才能完成整个处理过程<span class=" fw-cl "><span>，</span></span>常见的有 101<span class="fw-op  "><span>（</span></span>客户要求服务器转换 HTTP 协议版本<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>、</span></span>100<span class="fw-op  "><span>（</span></span>客户必须继续发出请求<span class=" fw-cl "><span>）</span></span></li>
  <li style="">200-299<span class=" fw-cl "><span>：</span></span>表示成果接收请求并已完成整个处理过程</li>
  <li style="">300-399<span class=" fw-cl "><span>：</span></span>需要客户进一步细化需求<span class=" fw-cl "><span>，</span></span>以进一步完成请求<span class=" fw-cl "><span>，</span></span>常用的有 301<span class="fw-op  "><span>（</span></span>永久重定向<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>、</span></span>302<span class="fw-op  "><span>（</span></span>临时重定向<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>、</span></span>304<span class="fw-op  "><span>（</span></span>缓存相关<span class=" fw-cl "><span>）</span></span></li>
  <li style="">400-499<span class=" fw-cl "><span>：</span></span>请求出错<span class=" fw-cl "><span>，</span></span>包含语法错误或者无法正确执行逻辑<span class=" fw-cl "><span>，</span></span>常用的有 404<span class="fw-op  "><span>（</span></span>无对应资源<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>、</span></span>401<span class="fw-op  "><span>（</span></span>权限问题<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>、</span></span>403 <span class="fw-op  "><span>（</span></span>服务器拒绝请求<span class=" fw-cl "><span>）</span></span></li>
  <li style="">500-599<span class=" fw-cl "><span>：</span></span>服务器端程序处理出现错误<span class=" fw-cl "><span>，</span></span>常见的有 502<span class="fw-op  "><span>（</span></span>错误网关<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>、</span></span>504<span class="fw-op  "><span>（</span></span>网关超时<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>、</span></span>505<span class="fw-op  "><span>（</span></span>HTTP 版本不受支持<span class=" fw-cl "><span>）</span></span></li>
</ul>
<p>列举更加具体的状态码说明<span class=" fw-cl "><span>，</span></span>出自<span class=" fw-cl "><span>：</span></span><a href="https://juejin.im/entry/586b5b7dac502e12d62b4f33" title="HTTP Status Code">HTTP Status Code</a></p>
<p><code>100 &nbsp;&nbsp;&nbsp;&nbsp;//继续 请求者应当继续提出请求<span class=" fw-cl "><span>。</span></span>服务器返回此代码表示已收到请求的第一部分<span class=" fw-cl "><span>，</span></span>正在等待其余部分<br>
101 &nbsp;&nbsp;&nbsp;&nbsp;//切换协议 &nbsp;请求者已要求服务器切换协议<span class=" fw-cl "><span>，</span></span>服务器已确认并准备切换<br>
<br>
200 &nbsp;&nbsp;&nbsp;&nbsp;//成功 &nbsp;服务器已经成功处理了请求<span class=" fw-cl "><span>，</span></span>通常<span class=" fw-cl "><span>，</span></span>这表示服务器提供了请求的网页<br>
201 &nbsp;&nbsp;&nbsp;&nbsp;//已创建 &nbsp;请求成功并且服务器创建了新的资源<br>
202 &nbsp;&nbsp;&nbsp;&nbsp;//已接受 &nbsp;服务器已接受请求<span class=" fw-cl "><span>，</span></span>但尚未处理<br>
203 &nbsp;&nbsp;&nbsp;&nbsp;//非授权信息 &nbsp;服务器已经成功处理了请求<span class=" fw-cl "><span>，</span></span>但返回的信息可能来自另一来源<br>
204 &nbsp;&nbsp;&nbsp;&nbsp;//无内容 &nbsp;服务器成功处理了请求<span class=" fw-cl "><span>，</span></span>但没有返回任何内容<br>
205 &nbsp;&nbsp;&nbsp;&nbsp;//重置内容 &nbsp;服务器成功处理了请求<span class=" fw-cl "><span>，</span></span>但没有返回任何内容<br>
206 &nbsp;&nbsp;&nbsp;&nbsp;//部分内容 &nbsp;服务器成功处理了部分 GET 请求<br>
<br>
300 &nbsp;&nbsp;&nbsp;&nbsp;//多种选择 &nbsp;针对请求<span class=" fw-cl "><span>，</span></span>服务器可执行多种操作<span class=" fw-cl "><span>。</span></span>服务器可根据请求者<span class="fw-op  "><span>（</span></span>user agent<span class=" fw-cl "><span>）</span></span>选择一项操作<span class=" fw-cl "><span>，</span></span>或提供操作列表供请求者选择<br>
301 &nbsp;&nbsp;&nbsp;&nbsp;//永久移动 &nbsp;请求的网页已永久移动到新位置<span class=" fw-cl "><span>。</span></span>服务器返回此响应<span class="fw-op  "><span>（</span></span>对 GET 或 HEAD 请求的响应<span class=" fw-cl "><span>）</span></span>时<span class=" fw-cl "><span>，</span></span>会自动将请求者转到新位置<br>
302 &nbsp;&nbsp;&nbsp;&nbsp;//临时移动 &nbsp;服务器目前从不同位置的网页响应请求<span class=" fw-cl "><span>，</span></span>但请求者应继续使用原有位置来进行以后的请求<br>
303 &nbsp;&nbsp;&nbsp;&nbsp;//查看其他位置 &nbsp;请求者应当对不同的位置使用单独的 GET 请求来检索响应时<span class=" fw-cl "><span>，</span></span>服务器返回此代码<br>
304 &nbsp;&nbsp;&nbsp;&nbsp;//未修改 &nbsp;自动上次请求后<span class=" fw-cl "><span>，</span></span>请求的网页未修改过<span class=" fw-cl "><span>。</span></span>服务器返回此响应<span class=" fw-cl "><span>，</span></span>不会返回网页的内容<br>
305 &nbsp;&nbsp;&nbsp;&nbsp;//使用代理 &nbsp;请求者只能使用代理访问请求的网页<span class=" fw-cl "><span>。</span></span>如果服务器返回此响应<span class=" fw-cl "><span>，</span></span>还表示请求者应使用代理<br>
307 &nbsp;&nbsp;&nbsp;&nbsp;//临时性重定向 &nbsp;服务器目前从不同位置的网页响应请求<span class=" fw-cl "><span>，</span></span>但请求者应继续使用原有的位置来进行以后的请求<br>
<br>
<br>
400 &nbsp;&nbsp;&nbsp;&nbsp;//错误请求 &nbsp;服务器不理解请求的语法<br>
401 &nbsp;&nbsp;&nbsp;&nbsp;//未授权 &nbsp;请求要求身份验证<span class=" fw-cl "><span>。</span></span>对于需要登录的网页<span class=" fw-cl "><span>，</span></span>服务器可能返回此响应<br>
403 &nbsp;&nbsp;&nbsp;&nbsp;//禁止 &nbsp;服务器拒绝请求<br>
404 &nbsp;&nbsp;&nbsp;&nbsp;//未找到 &nbsp;服务器找不到请求的网页<br>
405 &nbsp;&nbsp;&nbsp;&nbsp;//方法禁用 &nbsp;禁用请求中指定的方法<br>
406 &nbsp;&nbsp;&nbsp;&nbsp;//不接受 &nbsp;无法使用请求的内容特性响应请求的网页<br>
407 &nbsp;&nbsp;&nbsp;&nbsp;//需要代理授权 &nbsp;此状态码与 401<span class="fw-op  "><span>（</span></span>未授权<span class=" fw-cl "><span>）</span></span>类似<span class=" fw-cl "><span>，</span></span>但指定请求者应当授权使用代理<br>
408 &nbsp;&nbsp;&nbsp;&nbsp;//请求超时 &nbsp;服务器等候请求时发生超时<br>
409 &nbsp;&nbsp;&nbsp;&nbsp;//冲突 &nbsp;服务器在完成请求时发生冲突<span class=" fw-cl "><span>。</span></span>服务器必须在响应中包含有关冲突的信息<br>
410 &nbsp;&nbsp;&nbsp;&nbsp;//已删除 &nbsp;如果请求的资源已永久删除<span class=" fw-cl "><span>，</span></span>服务器就会返回此响应<br>
411 &nbsp;&nbsp;&nbsp;&nbsp;//需要有效长度 &nbsp;服务器不接受不含有效内容长度标头字段的请求<br>
412 &nbsp;&nbsp;&nbsp;&nbsp;//未满足前提条件 &nbsp;服务器未满足请求者在请求者设置的其中一个前提条件<br>
413 &nbsp;&nbsp;&nbsp;&nbsp;//请求实体过大 &nbsp;服务器无法处理请求<span class=" fw-cl "><span>，</span></span>因为请求实体过大<span class=" fw-cl "><span>，</span></span>超出了服务器的处理能力<br>
414 &nbsp;&nbsp;&nbsp;&nbsp;//请求的 URI 过长 &nbsp;请求的 URI<span class="fw-op  "><span>（</span></span>通常为网址<span class=" fw-cl "><span>）</span></span>过长<span class=" fw-cl "><span>，</span></span>服务器无法处理<br>
415 &nbsp;&nbsp;&nbsp;&nbsp;//不支持媒体类型 &nbsp;请求的格式不受请求页面的支持<br>
416 &nbsp;&nbsp;&nbsp;&nbsp;//请求范围不符合要求 &nbsp;如果页面无法提供请求的范围<span class=" fw-cl "><span>，</span></span>则服务器会返回此状态码<br>
417 &nbsp;&nbsp;&nbsp;&nbsp;//未满足期望值 &nbsp;服务器未满足<span class="fw-op  "><span>「</span></span>期望<span class=" fw-cl "><span>」</span></span>请求标头字段的要求<br>
<br>
500 &nbsp;&nbsp;&nbsp;&nbsp;//服务器内部错误 &nbsp;服务器遇到错误<span class=" fw-cl "><span>，</span></span>无法完成请求<br>
501 &nbsp;&nbsp;&nbsp;&nbsp;//尚未实施 &nbsp;服务器不具备完成请求的功能<span class=" fw-cl "><span>。</span></span>例如<span class=" fw-cl "><span>，</span></span>服务器无法识别请求方法时可能会返回此代码<br>
502 &nbsp;&nbsp;&nbsp;&nbsp;//错误网关 &nbsp;服务器作为网关或代理<span class=" fw-cl "><span>，</span></span>从上游服务器无法收到无效响应<br>
503 &nbsp;&nbsp;&nbsp;&nbsp;//服务器不可用 &nbsp;服务器目前无法使用<span class="fw-op  "><span>（</span></span>由于超载或者停机维护<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>通常<span class=" fw-cl "><span>，</span></span>这只是暂时状态<br>
504 &nbsp;&nbsp;&nbsp;&nbsp;//网关超时 &nbsp;服务器作为网关代理<span class=" fw-cl "><span>，</span></span>但是没有及时从上游服务器收到请求<br>
505 &nbsp;&nbsp;&nbsp;&nbsp;//HTTP 版本不受支持 &nbsp;服务器不支持请求中所用的 HTTP 协议版本</code></p>
<p><strong style="">这些内容对应的面试考点<span class=" fw-cl "><span>：</span></span></strong></p>
<ul>
  <li style="">状态码的熟悉程度</li>
  <li style="">缓存相关状态码</li>
  <li style="">Restful 相关内容</li>
</ul>
<h4>HTTP 请求方法</h4>
<p>常见的 HTTP 请求方法有以下几个<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li style="">GET 方法<span class=" fw-cl "><span>：</span></span>该方法发送请求来取得服务器上的资源<span class=" fw-cl "><span>，</span></span>一般来说 GET 方法应该只用于数据的读取<span class=" fw-cl "><span>，</span></span>而不应当用于会产生副作用的非幂等的操作中<span class=" fw-cl "><span>。</span></span></li>
  <li style="">POST 方法<span class=" fw-cl "><span>：</span></span>该方法向将指定资源的最新数据传送给服务器取代指定的资源的内容<span class=" fw-cl "><span>，</span></span>POST 方法是非幂等的方法<span class=" fw-cl "><span>，</span></span>因为这个请求可能会创建新的资源或 / 和修改现有资源<span class=" fw-cl "><span>。</span></span></li>
  <li style="">PUT 方法<span class=" fw-cl "><span>：</span></span>类似 POST 方法<span class=" fw-cl "><span>，</span></span>该方法指定了资源在服务器上的位置<span class=" fw-cl "><span>，</span></span>进行数据提交或数据更新</li>
  <li style="">PARTCH 方法<span class=" fw-cl "><span>：</span></span>该方法出现的较晚<span class=" fw-cl "><span>，</span></span>它在 2010 年的 RFC 5789 标准中被定义<span class=" fw-cl "><span>。</span></span>一般用于资源的部分更新<span class=" fw-cl "><span>，</span></span>而 PUT 一般用于资源的整体更新<span class=" fw-cl "><span>。</span></span>另外<span class=" fw-cl "><span>，</span></span>当资源不存在时<span class=" fw-cl "><span>，</span></span>PATCH 会创建一个新的资源<span class=" fw-cl "><span>，</span></span>而 PUT 只会对已在资源进行更新<span class=" fw-cl "><span>。</span></span></li>
  <li style="">HEAD 方法<span class=" fw-cl "><span>：</span></span>该方法只请求页面的首部<span class=" fw-cl "><span>，</span></span>也就是说服务端的返回不含内容部分<span class=" fw-cl "><span>。</span></span>这个方法<span class=" fw-cl "><span>，</span></span>允许我们可以不传输全部内容的情况下<span class=" fw-cl "><span>，</span></span>就可以获取服务器的响应头信息<span class=" fw-cl "><span>。</span></span>HEAD 方法常被用于客户端查看服务器的性能<span class=" fw-cl "><span>。</span></span></li>
  <li style="">DELETE 方法<span class=" fw-cl "><span>：</span></span>该方法删除服务器上的某资源或者数据<span class=" fw-cl "><span>。</span></span></li>
  <li style="">OPTIONS 方法<span class=" fw-cl "><span>：</span></span>该方法用于获取指定服务能够支持的方法<span class=" fw-cl "><span>。</span></span>当请求成功时<span class=" fw-cl "><span>，</span></span>客户端会得到相关头部信息<span class=" fw-cl "><span>，</span></span>指定了服务能够支持的方法<span class=" fw-cl "><span>，</span></span>比如<span class="fw-op  "><span>「</span></span>GET<span class=" fw-cl "><span>、</span></span>POST<span class=" fw-cl "><span>」</span></span>等<span class=" fw-cl "><span>。</span></span>JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时<span class=" fw-cl "><span>，</span></span>就是使用 OPTIONS 方法发送嗅探请求<span class=" fw-cl "><span>，</span></span>以判断是否有对指定资源的访问权限<span class=" fw-cl "><span>。</span></span></li>
  <li style="">TRACE 方法<span class=" fw-cl "><span>：</span></span>被用于激发一个远程的<span class=" fw-cl "><span>，</span></span>应用层的请求消息回路<span class=" fw-cl "><span>，</span></span>该方法主要用于 HTTP 请求的测试或诊断<span class=" fw-cl "><span>。</span></span></li>
  <li style="">CONNECT 方法<span class=" fw-cl "><span>：</span></span>HTTP/1.1 协议预留的<span class=" fw-cl "><span>，</span></span>能够将连接改为管道方式的代理服务器<span class=" fw-cl "><span>。</span></span>通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>我们再从 HTTP 方法的安全性和幂等性角度来进行总结<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">安全性是说<strong style="">多次调用不会产生副作用</strong><span class=" fw-cl "><span>，</span></span>换句话说<span class=" fw-cl "><span>，</span></span><strong style="">安全的方法不会修改资源状态<span class=" fw-cl "><span>；</span></span></strong></li>
  <li style="">幂等性<span class=" fw-cl "><span>，</span></span>是指该方法<strong style="">多次调用返回的效果<span class="fw-op  "><span>（</span></span>形式<span class=" fw-cl "><span>）</span></span>一致</strong><span class=" fw-cl "><span>，</span></span>客户端可以重复调用并且期望同样的结果<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p><br></p>
<figure class="central"><img data-src="https://pic2.zhimg.com/v2-0241bdaea9a6dc63b45576fe190ecb0d.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:42.26457399103139% 0" data-src="https://pic2.zhimg.com/v2-0241bdaea9a6dc63b45576fe190ecb0d.png">加载中...</span></figure>
<p><strong style="">这些内容对应的面试考点<span class=" fw-cl "><span>：</span></span></strong></p>
<ul>
  <li style="">GET/POST 区别</li>
  <li style="">OPTIONS 理解<span class=" fw-cl "><span>，</span></span>以及跨域相关内容</li>
  <li style="">Restful 相关内容</li>
</ul>
<h4>如何理解 HTTP 协议是无状态的</h4>
<p>综合以上内容<span class=" fw-cl "><span>，</span></span>我们来分析一个面试常考题目<span class=" fw-cl "><span>：</span></span>如何理解 HTTP 协议是无状态的<span class=" fw-cl "><span>？</span></span></p>
<p>我们之所以说 HTTP 协议是无状态的<span class=" fw-cl "><span>，</span></span>其实指的是客户端和服务器的通信<span class=" fw-cl "><span>，</span></span>每个请求之间是独立的<span class=" fw-cl "><span>，</span></span>指的是 HTTP 协议对于独立的请求是没有记忆能力的<span class=" fw-cl "><span>。</span></span></p>
<p>通俗点说<span class=" fw-cl "><span>，</span></span>我们的应用发送一个请求<span class=" fw-cl "><span>，</span></span>和下一次再打开该应用<span class=" fw-cl "><span>，</span></span>发送同一个请求<span class=" fw-cl "><span>，</span></span>这些请求之间没有任何联系<span class=" fw-cl "><span>。</span></span><strong style="">HTTP 是一个无状态的面向连接的协议</strong><span class=" fw-cl "><span>，</span></span>但是无状态不代表 HTTP 不能保持 TCP 连接<span class=" fw-cl "><span>，</span></span>更不能代表 TCP 不是面向连接的<span class=" fw-cl "><span>。</span></span></p>
<h4>其他概念</h4>
<p>这一讲不再做更多 HTTP 内容的介绍<span class=" fw-cl "><span>，</span></span>更多 HTTP 的知识会在<span class="fw-op  "><span>《</span></span>HTTP 的深思<span class=" fw-cl "><span>：</span></span>我从何而来<span class=" fw-cl "><span>，</span></span>去向何处<span class=" fw-cl "><span>》</span></span>中继续说明<span class=" fw-cl "><span>。</span></span>我们来看一些更多的概念<span class=" fw-cl "><span>。</span></span></p>
<h4>域名系统</h4>
<p>域名系统<span class="fw-op  "><span>（</span></span>Domain Name System<span class=" fw-cl "><span>，</span></span>DNS<span class=" fw-cl "><span>）</span></span>是因特网的一项核心服务<span class=" fw-cl "><span>，</span></span>它作为可以将域名和 IP 地址相互映射的一个分布式数据库<span class=" fw-cl "><span>，</span></span>能够使人更方便地访问互联网<span class=" fw-cl "><span>，</span></span>而不用去记住能够被机器直接读取的 IP 数串<span class=" fw-cl "><span>。</span></span></p>
<p>比如我们经常访问的网站<span class=" fw-cl "><span>，</span></span>其域名就相当于其门牌地址<span class=" fw-cl "><span>，</span></span>比如 IBM 公司的域名是 www.ibm.com<span class=" fw-cl "><span>；</span></span>Cisco 公司的域名是 www.cisco.com<span class=" fw-cl "><span>。</span></span>因此对每一个网站进行访问时<span class=" fw-cl "><span>，</span></span>都需要对域名和对应的 IP 地址进行映射<span class=" fw-cl "><span>，</span></span>具体过程<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">先过浏览器搜索自己的 DNS 缓存<span class="fw-op  "><span>（</span></span>可以使用 chrome://net-internals/#dns 来进行查看<span class=" fw-cl "><span>）</span></span></li>
  <li style="">上一步未找到对应缓存的 IP 地址时<span class=" fw-cl "><span>，</span></span>搜索操作系统中的 DNS 缓存</li>
  <li style="">上一步未找到对应缓存的 IP 地址时<span class=" fw-cl "><span>，</span></span>操作系统将域名发送至 LDNS<span class="fw-op  "><span>（</span></span>本地区域名服务器<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>LDNS 查询 自己的 DNS 缓存<span class="fw-op  "><span>（</span></span>一般查找成功率在 80% 左右<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>查找成功则返回结果<span class=" fw-cl "><span>，</span></span>失败则发起一个迭代 DNS 解析请求<span class=" fw-cl "><span>，</span></span>为什么说这是迭代的 DNS 解析请求呢<span class=" fw-cl "><span>？</span></span>这个过程
    <ul>
      <li style="">LDNS 向 Root Name Server<span class="fw-op  "><span>（</span></span>根域名服务器<span class=" fw-cl "><span>，</span></span>如 com<span class=" fw-cl "><span>、</span></span>net<span class=" fw-cl "><span>、</span></span>org 等解析顶级域名服务器的地址<span class=" fw-cl "><span>）</span></span>发起请求<span class=" fw-cl "><span>，</span></span>此处<span class=" fw-cl "><span>，</span></span>Root Name Server 返回 com 域的顶级域名服务器地址</li>
      <li style="">LDNS 向 com 域的顶级域名服务器发起请求<span class=" fw-cl "><span>，</span></span>返回 baidu.com 域名服务器地址</li>
      <li style="">LDNS 向 baidu.com 域名服务器发起请求<span class=" fw-cl "><span>，</span></span>得到 www.baidu.com 的 IP 地址 LDNS 将得到的 IP 地址返回给操作系统<span class=" fw-cl "><span>，</span></span>同时自己也将 IP 地址缓存起来</li>
    </ul>
  </li>
  <li style="">操作系统将 IP 地址返回给浏览器<span class=" fw-cl "><span>，</span></span>同时自己也将 IP 地址缓存起来</li>
</ul>
<p>DNS 解析整个过程<span class=" fw-cl "><span>，</span></span>分为<span class=" fw-cl "><span>：</span></span>递归查询过程和迭代查询过程<span class=" fw-cl "><span>。</span></span></p>
<p>读者可以通过<span class=" fw-cl "><span>：</span></span></p>
<p><code>cat /etc/resolv.conf</code></p>
<p>获取本机 DNS 配置<span class=" fw-cl "><span>，</span></span>我的内容为<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-b6221a907b3804196e3609373fc3c9ea.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:28.42741935483871% 0" data-src="https://pic3.zhimg.com/v2-b6221a907b3804196e3609373fc3c9ea.png">加载中...</span></figure>
<p>再通过<span class=" fw-cl "><span>：</span></span></p>
<p><code>dig +trace XXX.com</code></p>
<p>来查看完整的分级查询过程<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-7bf001beda3606e95ba295f954861b70.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:38.266129032258064% 0" data-src="https://pic4.zhimg.com/v2-7bf001beda3606e95ba295f954861b70.png">加载中...</span></figure>
<p><strong style="">这些内容对应的面试考点<span class=" fw-cl "><span>：</span></span></strong></p>
<ul>
  <li style="">域名系统相关工作方式</li>
  <li style="">顶级域名<span class=" fw-cl "><span>、</span></span>一级域名<span class=" fw-cl "><span>、</span></span>二级域名概念</li>
</ul>
<p>最后<span class=" fw-cl "><span>，</span></span>需要说明的是 DNS 使用无连接的 UDP 协议来进行查询<span class=" fw-cl "><span>，</span></span>这样的方式降低了开销<span class=" fw-cl "><span>，</span></span>也使得速度更快<span class=" fw-cl "><span>，</span></span>保证了高效的通信<span class=" fw-cl "><span>，</span></span>但是没有太考虑安全问题<span class=" fw-cl "><span>。</span></span>它使用目的端口为 53 的 UDP 明文进行通信<span class=" fw-cl "><span>，</span></span>这也带来了诸如 DNS 欺骗<span class=" fw-cl "><span>、</span></span>DNS Cache 污染<span class=" fw-cl "><span>、</span></span>DNS 放大攻击等问题<span class=" fw-cl "><span>，</span></span>一些<span class="fw-op  "><span>「</span></span>黑心<span class=" fw-cl "><span>」</span></span>运营商就可以利用这一点达到一些别用用心的目的<span class=" fw-cl "><span>。</span></span></p>
<p>针对于此<span class=" fw-cl "><span>，</span></span>DNSSec<span class="fw-op  "><span>（</span></span>Domain Name System Security Extensions<span class=" fw-cl "><span>，</span></span>也叫<span class="fw-op  "><span>「</span></span>DNS 安全扩展<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>）</span></span>机制便诞生了<span class=" fw-cl "><span>，</span></span>这个机制会让客户端对域名来源身份进行验证<span class=" fw-cl "><span>，</span></span>并且检查来自 DNS 域名服务器应答记录的完整性<span class=" fw-cl "><span>，</span></span>以及验证是否在传输过程中被篡改过<span class=" fw-cl "><span>。</span></span>总之域名系统的安全性话题已经不可忽视<span class=" fw-cl "><span>。</span></span></p>
<h4>跨域</h4>
<p>跨域其实是浏览器的行为<span class=" fw-cl "><span>，</span></span>狭义上说<span class=" fw-cl "><span>，</span></span>它指的是浏览器无法执行其他网站的脚本<span class=" fw-cl "><span>。</span></span>为什么无法执行呢<span class=" fw-cl "><span>？</span></span>这要由浏览器的同源策略说起<span class=" fw-cl "><span>，</span></span>简单来说<span class=" fw-cl "><span>，</span></span>跨域是浏览器对 JavaScript 施加的安全限制<span class=" fw-cl "><span>。</span></span></p>
<blockquote><br></blockquote>
<p>同源策略<span class="fw-op  "><span>（</span></span>Same Origin Policy<span class=" fw-cl "><span>）</span></span>是一种约定<span class=" fw-cl "><span>，</span></span>由 Netscape 公司 1995 年引入浏览器<span class=" fw-cl "><span>，</span></span>它是浏览器最核心也最基本的安全功能<span class=" fw-cl "><span>，</span></span>如果缺少了同源策略<span class=" fw-cl "><span>，</span></span>浏览器很容易受到 XSS<span class=" fw-cl "><span>、</span></span>CSFR 等攻击<span class=" fw-cl "><span>。</span></span></p>
<p>我们都知道<span class=" fw-cl "><span>，</span></span>所谓同源<span class=" fw-cl "><span>，</span></span>是指<span class="fw-op  "><span>「</span></span>协议<span class=" fw-cl "><span>、</span></span>域名<span class=" fw-cl "><span>、</span></span>端口<span class=" fw-cl "><span>」</span></span>这三要素都相同<span class=" fw-cl "><span>，</span></span>在非同源的情况下<span class=" fw-cl "><span>，</span></span>以下行为会收到限制<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">对 Cookie<span class=" fw-cl "><span>、</span></span>LocalStorage 和 IndexDB 的读取</li>
  <li style="">对 DOM 和 JS 对象的读取</li>
  <li style="">Ajax 请求的正常执行</li>
</ul>
<p>关于解决跨越方案的内容市面上的资料讲解较多<span class=" fw-cl "><span>，</span></span>我们这里不再赘述<span class=" fw-cl "><span>。</span></span></p>
<h5><strong style="">代理和网关</strong></h5>
<p>在 NodeJS <span class="fw-op  "><span>「</span></span>攻城略地<span class=" fw-cl "><span>」</span></span>的背景下<span class=" fw-cl "><span>，</span></span>前端开发者越来越多地接触到了代理和网关的概念<span class=" fw-cl "><span>。</span></span>代理简单来说<span class=" fw-cl "><span>，</span></span>是一种有转发功能的应用程序<span class=" fw-cl "><span>，</span></span>它扮演了位于两端之间<span class="fw-op  "><span>「</span></span>中间人<span class=" fw-cl "><span>」</span></span>的角色<span class=" fw-cl "><span>。</span></span>比如在我的一个项目中<span class=" fw-cl "><span>，</span></span>公司内部中台有基于 StatsD<span class="fw-op  "><span>（</span></span>StatsD 就是一个简单的网络守护进程<span class=" fw-cl "><span>，</span></span>基于 Node.js 平台<span class=" fw-cl "><span>，</span></span>通过 UDP 或者 TCP 方式侦听各种统计信息<span class=" fw-cl "><span>）</span></span>的数据收集和统计系统<span class=" fw-cl "><span>，</span></span>因为 StatsD 是基于 TCP/UDP 的<span class=" fw-cl "><span>，</span></span>因此为了在 C 端统计用户行为<span class=" fw-cl "><span>，</span></span>我设计了在 NodeJS 层的一个代理机制<span class=" fw-cl "><span>，</span></span>对 C 端上报数据进行简单的接受和分发<span class=" fw-cl "><span>。</span></span></p>
<p>网关是转发其他服务器通信数据的服务器<span class=" fw-cl "><span>，</span></span>当接收从客户端发送来的请求时<span class=" fw-cl "><span>，</span></span>它就像自己拥有资源的源服务器一样对请求进行处理<span class=" fw-cl "><span>，</span></span>其工作机制和代理类似<span class=" fw-cl "><span>，</span></span>但网关能力可能更加强大<span class=" fw-cl "><span>，</span></span>它不是提供一个单一服务<span class=" fw-cl "><span>，</span></span>而是能给通信链路提供平台化的服务<span class=" fw-cl "><span>，</span></span>比如鉴权等内容<span class=" fw-cl "><span>。</span></span></p>
<p>更多应用我们暂不展开<span class=" fw-cl "><span>，</span></span>本讲会把更多精力放在网络基础知识的学习上<span class=" fw-cl "><span>。</span></span>这里只需要读者明白<span class=" fw-cl "><span>，</span></span>前端 BFF 层<span class=" fw-cl "><span>，</span></span>或代理层<span class=" fw-cl "><span>，</span></span>越来越需要开发者对于网络基础知识的理解和运用<span class=" fw-cl "><span>。</span></span></p>
<h5>URI VS URL</h5>
<p>很多开发者并不理解 URI 和 URL 的区别<span class=" fw-cl "><span>，</span></span>从名称上来看<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">URL<span class=" fw-cl "><span>，</span></span>统一资源定位符</li>
  <li style="">URI<span class=" fw-cl "><span>，</span></span>统一资源标识符</li>
</ul>
<p>通俗来说<span class=" fw-cl "><span>，</span></span>URL 像是一个邮政编码<span class=" fw-cl "><span>，</span></span>URI 就是收件地址<span class=" fw-cl "><span>。</span></span>因此可知<span class=" fw-cl "><span>，</span></span>URL 的范围大于 URI<span class=" fw-cl "><span>。</span></span>我们以淘宝的例子来说<span class=" fw-cl "><span>，</span></span><a href="https://www.taobao.com/" title="https://www.taobao.com/">https://www.taobao.com/</a> 这个域名就是 URL<span class=" fw-cl "><span>，</span></span>而每个商品的地址就是一个 URI<span class=" fw-cl "><span>。</span></span></p>
<p>很多 Ajax 请求库的参数都设计成叫做 url<span class=" fw-cl "><span>，</span></span>表示请求地址<span class=" fw-cl "><span>。</span></span>但实际上<span class=" fw-cl "><span>，</span></span>更准确的表达是 URI<span class=" fw-cl "><span>。</span></span></p>
<h3>网络相关应用</h3>
<p>这部分我们来看一些网络知识的应用<span class=" fw-cl "><span>，</span></span>同时剖析一些案例<span class=" fw-cl "><span>。</span></span></p>
<h4>NodeJS 和 TCP</h4>
<p>在 NodeJS 中<span class=" fw-cl "><span>，</span></span>我们可以很轻松地实现一个基于 TCP 的数据通信过程<span class=" fw-cl "><span>，</span></span>主要依赖 net 模块<span class=" fw-cl "><span>：</span></span></p>
<p><code>let net = require('net')<br>
<br>
let server = net.createServer(socket =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log('客户端已经链接')<br>
 &nbsp;&nbsp;&nbsp;console.log(socket.address())<br>
})<br>
<br>
server.listen('8080', () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;/* 获取地址信息<span class=" fw-cl "><span>，</span></span>得到的是一个 json { address: '::', family: 'IPv6', port: 8000 } */<br>
 &nbsp;&nbsp;&nbsp;const address = server.address()<br>
<br>
 &nbsp;&nbsp;&nbsp;/* TCP 服务器监听的地址 */<br>
 &nbsp;&nbsp;&nbsp;console.log(`the port of server is ${address.port}`)<br>
<br>
 &nbsp;&nbsp;&nbsp;/* IPv6 还是 IPv4 */<br>
 &nbsp;&nbsp;&nbsp;console.log(`the family of server is ${address.family}`)<br>
})<br>
<br>
server.getConnections((err,count) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log(`已经链接 ${count} 个用户`)<br>
})<br>
<br>
server.maxConnections = 2</code></p>
<p>这样就使用 NodeJS 创建了一个简单的 TCP 服务器<span class=" fw-cl "><span>，</span></span>并设置了最大连接数<span class=" fw-cl "><span>，</span></span>监听客户端链接数量<span class=" fw-cl "><span>，</span></span>以及对事件的处理等<span class=" fw-cl "><span>。</span></span></p>
<p>也可以利用 socket.write 进行 TCP 服务器的数据发送<span class=" fw-cl "><span>：</span></span></p>
<p><code>var net = require("net")<br>
<br>
/* 创建 TCP 服务器 */<br>
let server = net.createServer(socket =&gt; {<br>
 &nbsp;&nbsp;&nbsp;var address = server.address()<br>
 &nbsp;&nbsp;&nbsp;var message = `the server address is ${JSON.stringify(address)}`<br>
<br>
 &nbsp;&nbsp;&nbsp;socket.write(message, () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let writeSize = socket.bytesWritten<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(`${message} has send, the size is ${writeSize}`)<br>
 &nbsp;&nbsp;&nbsp;})<br>
<br>
 &nbsp;&nbsp;&nbsp;socket.on('data', (data) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(data.toString())<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const readSize = socket.bytesRead<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(`the size of data is ${readSize}`)<br>
 &nbsp;&nbsp;&nbsp;})<br>
})<br>
<br>
server.listen(8000, () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log("Creat server on http://127.0.0.1:8000/")<br>
})</code></p>
<p>我们也可以用 NodeJS 来构建一个 TCP 客户端<span class=" fw-cl "><span>，</span></span>实现 TCP 客户端和 TCP 服务器的通信<span class=" fw-cl "><span>，</span></span>这里就不再展开了<span class=" fw-cl "><span>。</span></span></p>
<h4>NodeJS 和 UDP</h4>
<p>关于 NodeJS 实现 UDP 通信<span class=" fw-cl "><span>，</span></span>我们需要依靠 dgram 模块<span class=" fw-cl "><span>，</span></span>dgram 模块提供了 UDP 数据包 socket 的实现<span class=" fw-cl "><span>。</span></span>先看 UDP server 的创建<span class=" fw-cl "><span>，</span></span>创建 server.js 文件<span class=" fw-cl "><span>：</span></span></p>
<p><code>const dgram = require('dgram')<br>
<br>
// 创建 UDP server<br>
let udpServer = dgram.createSocket('udp4')<br>
// 绑定端口<br>
udpServer.bind(5678)<br>
<br>
// 监听端口<br>
udpServer.on('listening', () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log('udp server linstening 5678.')<br>
})<br>
<br>
//接收消息<br>
udpServer.on('message', (message, rinfo) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;const messageStr = message.toString()<br>
 &nbsp;&nbsp;&nbsp;udpServer.send(messageStr.toString(), 0, messageStr.length, rinfo.port, rinfo.address)<br>
 &nbsp;&nbsp;&nbsp;console.log(`udp server received data: ${messageStr} from ${rinfo.address}:${rinfo.port}`)<br>
})<br>
<br>
//错误处理<br>
udpServer.on('error', err =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log('some error on udp server.')<br>
 &nbsp;&nbsp;&nbsp;udpServer.close()<br>
})</code></p>
<p>创建 UDP Client<span class=" fw-cl "><span>，</span></span>创建 client.js<span class=" fw-cl "><span>：</span></span></p>
<p><code>const dgram = require('dgram')<br>
let udpClient = dgram.createSocket('udp4')<br>
<br>
udpClient.on('close', () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log('udp client closed.')<br>
})<br>
<br>
// 错误处理<br>
udpClient.on('error', () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log('some error on udp client.')<br>
})<br>
<br>
// 接收消息<br>
udpClient.on('message', (message, rinfo) =&gt; {<br>
 &nbsp;&nbsp;&nbsp;console.log(`receive message from ${rinfo.address}: ${rinfo.port}: ${message}`)<br>
})<br>
<br>
// 定时向服务器发送消息<br>
setInterval(() =&gt; {<br>
 &nbsp;&nbsp;&nbsp;const sendStr = 'hello.'<br>
 &nbsp;&nbsp;&nbsp;const sendStrLen = sendStr.length<br>
 &nbsp;&nbsp;&nbsp;udpClient.send(sendStr, 0, sendStrLen, 5678, '172.30.20.10')<br>
}, 3000)</code></p>
<p>在上述代码中<span class=" fw-cl "><span>，</span></span>读者可以在 UDP Client 结尾处配置好自己的 IP 地址<span class=" fw-cl "><span>，</span></span>并启动<span class=" fw-cl "><span>：</span></span></p>
<p><code>node server.js<br>
node client.js</code></p>
<p>观察 NodeJS 应用状况<span class=" fw-cl "><span>。</span></span></p>
<h4>短网址功能实现</h4>
<p>常用微博或者关注运营需求的读者应该知道短网址功能<span class=" fw-cl "><span>：</span></span></p>
<p><br></p>
<figure class="central"><img data-src="https://pic2.zhimg.com/v2-deda34815ebdd9bc6212b5da9199fee9.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:21.370967741935484% 0" data-src="https://pic2.zhimg.com/v2-deda34815ebdd9bc6212b5da9199fee9.png">加载中...</span></figure>
<p>简单来说<span class=" fw-cl "><span>，</span></span>短网址工具可以将一长串 URL 地址转换成简短的<span class=" fw-cl "><span>、</span></span>可访问的短链接形式<span class=" fw-cl "><span>。</span></span>自微博盛行以来<span class=" fw-cl "><span>，</span></span>在微博字数有限的特色下<span class=" fw-cl "><span>，</span></span>短链接盛行于微博网站<span class=" fw-cl "><span>，</span></span>以节省微博字数<span class=" fw-cl "><span>，</span></span>给博主发布更多文字的空间<span class=" fw-cl "><span>。</span></span></p>
<p>那么一个短网址生成平台该怎么设计呢<span class=" fw-cl "><span>？</span></span>其实原理很简单<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">用户输入完整网址<span class=" fw-cl "><span>，</span></span>服务端接收到完整网址之后<span class=" fw-cl "><span>，</span></span>根据算法生成一个短码<span class=" fw-cl "><span>，</span></span>维护完整网址和短码的映射关系<span class=" fw-cl "><span>，</span></span>并将短码完善成短网址<span class=" fw-cl "><span>，</span></span>返回给客户端<span class=" fw-cl "><span>；</span></span></li>
  <li style="">任意客户端访问短网址<span class=" fw-cl "><span>，</span></span>服务端根据完整网址和短码的映射关系<span class=" fw-cl "><span>，</span></span>重定向到对应的页面<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>我们看到了熟悉的三个字<span class=" fw-cl "><span>：</span></span>重定向<span class=" fw-cl "><span>，</span></span>请读者思考这里的重定向应该对应哪个 HTTP 状态码呢<span class=" fw-cl "><span>？</span></span></p>
<p>我们应该在 302 和 301 中进行选择<span class=" fw-cl "><span>：</span></span>从语义上看<span class=" fw-cl "><span>，</span></span>短网址对应完整网址的映射关系和跳转关系不会发生变化<span class=" fw-cl "><span>，</span></span>应该是 301 永久重定向才对<span class=" fw-cl "><span>。</span></span>但是更多的短网址生成平台却采用了 302<span class=" fw-cl "><span>，</span></span>这是为什么呢<span class=" fw-cl "><span>？</span></span></p>
<p>引自知乎网友的回答<span class=" fw-cl "><span>，</span></span><a href="https://www.zhihu.com/question/20103344/answer/573638467" title="原文链接">原文链接</a><span class=" fw-cl "><span>。</span></span></p>
<blockquote><br></blockquote>
<p>如果用了 301<span class=" fw-cl "><span>，</span></span>Google<span class=" fw-cl "><span>、</span></span>百度等搜索引擎<span class=" fw-cl "><span>，</span></span>搜索的时候会直接展示真实地址<span class=" fw-cl "><span>，</span></span>那我们就无法统计到短地址被点击的次数了<span class=" fw-cl "><span>，</span></span>也无法收集用户的 Cookie<span class=" fw-cl "><span>、</span></span>User Agent 等信息<span class=" fw-cl "><span>，</span></span>这些信息可以用来做很多有意思的大数据分析<span class=" fw-cl "><span>，</span></span>也是短网址服务商的主要盈利来源<span class=" fw-cl "><span>。</span></span></p>
<p>完整的设计我们可以借助 MySQL 和 Redis 实现完整网址和短码之间的映射关系<span class=" fw-cl "><span>。</span></span>生成短码的算法主要可以考虑以下几种<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">自增 id<span class=" fw-cl "><span>，</span></span>然后将 id 值转换为 62 进制的字符串<span class=" fw-cl "><span>，</span></span>为了解决短码长度不固定的问题<span class=" fw-cl "><span>，</span></span>可以指定数字开始递增<span class=" fw-cl "><span>。</span></span>同时为了解决短码有序的安全隐患<span class=" fw-cl "><span>，</span></span>可以结合 md5 进行混淆<span class=" fw-cl "><span>。</span></span>一种实现为<span class=" fw-cl "><span>：</span></span></li>
</ul>
<p><code>const string10to62 = number =&gt; {<br>
 &nbsp;&nbsp;&nbsp;const chars = '0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ'<br>
<br>
 &nbsp;&nbsp;&nbsp;const charsArr = chars.split('')<br>
 &nbsp;&nbsp;&nbsp;const radix = chars.length<br>
 &nbsp;&nbsp;&nbsp;let qutient = +number<br>
 &nbsp;&nbsp;&nbsp;let arr = []<br>
<br>
 &nbsp;&nbsp;&nbsp;do {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let mod = qutient % radix<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qutient = (qutient - mod) / radix<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arr.unshift(charsArr[mod])<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;while(qutient)<br>
<br>
 &nbsp;&nbsp;&nbsp;return arr.join('')<br>
}</code></p>
<ul>
  <li style="">哈希算法<span class=" fw-cl "><span>，</span></span>直接输入任意长度的数据<span class=" fw-cl "><span>，</span></span>输出固定长度的数据<span class=" fw-cl "><span>，</span></span>这种算法比较典型<span class=" fw-cl "><span>，</span></span>不再过多介绍</li>
  <li style="">随机数<span class=" fw-cl "><span>：</span></span>从 62 个字符串中随机取出固定长度的短码组合<span class=" fw-cl "><span>，</span></span>然后去数据库中查询该短码是否已存在<span class=" fw-cl "><span>。</span></span>如果已存在<span class=" fw-cl "><span>，</span></span>就继续循环该方法重新获取短码<span class=" fw-cl "><span>，</span></span>否则就直接返回<span class=" fw-cl "><span>。</span></span>这种方法最为简单<span class=" fw-cl "><span>，</span></span>但是得到碰撞的概率相对较大<span class=" fw-cl "><span>，</span></span>一种实现为<span class=" fw-cl "><span>：</span></span></li>
</ul>
<p><code>const generateShortLink = () =&gt; {<br>
 &nbsp;&nbsp;&nbsp;let str = ''<br>
 &nbsp;&nbsp;&nbsp;const arr = [<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',<br>
 &nbsp;&nbsp;&nbsp;]<br>
<br>
 &nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; 6; i++) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const pos = Math.round(Math.random() * (arr.length - 1))<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str += arr[pos]<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return str<br>
}<br>
<br>
async getShortLink() {<br>
 &nbsp;&nbsp;&nbsp;const shortLink = this.generateShortLink()<br>
<br>
 &nbsp;&nbsp;&nbsp;const searchResult = await this.searchByLinkInMySQL(shortLink)<br>
<br>
 &nbsp;&nbsp;&nbsp;if (searchResult &amp;&amp; searchResult.length &gt; 0) {<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.getShortLink();<br>
 &nbsp;&nbsp;&nbsp;}<br>
 &nbsp;&nbsp;&nbsp;return shortLink<br>
}</code></p>
<p>这一部分应用的分析<span class=" fw-cl "><span>，</span></span>参考了社区 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fliucong1%2FshortLink" title="shortLink">shortLink</a> 的实现和分析内容<span class=" fw-cl "><span>。</span></span>读者可进行进一步研究<span class=" fw-cl "><span>。</span></span></p>
<h4>扫码登录实现</h4>
<p>另外一个我们要介绍的实现是扫码登录<span class=" fw-cl "><span>，</span></span>现在授权第三方的扫码登录越来越流行<span class=" fw-cl "><span>。</span></span>比如我们可以通过微信实现在第三方应用的登录<span class=" fw-cl "><span>、</span></span>注册账号等<span class=" fw-cl "><span>，</span></span>这种共用账号体系的能力究竟是如何实现的呢<span class=" fw-cl "><span>？</span></span></p>
<p>其实原理同样并不复杂<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">首先打开 PC 端页面<span class=" fw-cl "><span>，</span></span>PC 端页面生成一个二维码<span class=" fw-cl "><span>，</span></span>这个二维码带有服务端下发的一个唯一 id<span class=" fw-cl "><span>：</span></span>uuid</li>
  <li style="">接着<span class=" fw-cl "><span>，</span></span>手机在微信账号中进行扫码<span class=" fw-cl "><span>，</span></span>发送请求<span class=" fw-cl "><span>，</span></span>请求包含了上面提到的 uuid 和当前用户的账号信息</li>
  <li style="">与此同时<span class=" fw-cl "><span>，</span></span>PC 端不断轮询服务器<span class="fw-op  "><span>（</span></span>或者通过 websocket<span class=" fw-cl "><span>，</span></span>服务端主动 push 信息<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>获取扫码登录的状态</li>
  <li style="">服务端返回扫码状态</li>
</ul>
<p>针对手机扫码后服务端的返回情况<span class=" fw-cl "><span>，</span></span>我们进行梳理<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">PC 端在轮询时<span class=" fw-cl "><span>，</span></span>如果扫码超时<span class="fw-op  "><span>（</span></span>手机没有授权登录或者就没扫码<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>服务端会阻塞一个时限<span class="fw-op  "><span>（</span></span>比如 30s<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>30s 内无响应<span class=" fw-cl "><span>，</span></span>服务端返回状态码 408<span class=" fw-cl "><span>，</span></span>得到返回后<span class=" fw-cl "><span>，</span></span>前端继续轮询</li>
  <li style="">大约 5 分钟内仍然没有扫码响应<span class=" fw-cl "><span>，</span></span>则二维码失效<span class=" fw-cl "><span>，</span></span>这时候服务端返回 400</li>
  <li style="">如果手机端扫码成功<span class=" fw-cl "><span>，</span></span>服务端返回 201 同时并返回用户信息<span class=" fw-cl "><span>，</span></span>并等待用户点击<span class="fw-op  "><span>「</span></span>确认授权登录<span class=" fw-cl "><span>」</span></span></li>
  <li style="">用户<span class="fw-op  "><span>「</span></span>确认授权登录<span class=" fw-cl "><span>」</span></span>之后<span class=" fw-cl "><span>，</span></span>服务端返回 200 同时返回一个 token<span class=" fw-cl "><span>；</span></span>PC 端在拿到下响应后<span class=" fw-cl "><span>，</span></span>重定向到目标页面<span class=" fw-cl "><span>，</span></span>同时停止轮询</li>
</ul>
<p>关键理解点<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">扫码登录一共涉及到三端<span class=" fw-cl "><span>：</span></span>服务端<span class=" fw-cl "><span>、</span></span>PC 端和手机扫码端</li>
  <li style="">PC 端通过轮询<span class=" fw-cl "><span>，</span></span>不断向服务端获取用户扫码登录的状态</li>
  <li style="">服务端阻塞 PC 端请求<span class=" fw-cl "><span>，</span></span>这样可以减少 PC 端轮询的次数<span class=" fw-cl "><span>，</span></span>优化轮询过程</li>
  <li style="">服务端根据手机扫码状态<span class=" fw-cl "><span>，</span></span>返回 408<span class=" fw-cl "><span>、</span></span>400<span class=" fw-cl "><span>、</span></span>201<span class=" fw-cl "><span>、</span></span>200 等状态码</li>
</ul>
<h4>断点续传原理</h4>
<p>对于大文件的传输/下载<span class=" fw-cl "><span>，</span></span>我们常常采用断点续传原理<span class=" fw-cl "><span>。</span></span>想象一下在使用迅雷<span class=" fw-cl "><span>、</span></span>网盘上传文件内容时<span class=" fw-cl "><span>，</span></span>如果网络条件出现问题<span class=" fw-cl "><span>，</span></span>我们仍然可以稍后继续进行上传/下载而不至于丢失之前的上传/下载进度<span class=" fw-cl "><span>。</span></span>这种断点续传的能力究竟是如何实现的呢<span class=" fw-cl "><span>？</span></span></p>
<p>实现断点续传<span class=" fw-cl "><span>，</span></span>需要依靠 HTTP1.1 协议<span class="fw-op  "><span>（</span></span>RFC2616<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>该协议版本开始支持获取文件的部分内容<span class=" fw-cl "><span>，</span></span>这为并行下载以及断点续传提供了技术支持<span class=" fw-cl "><span>。</span></span></p>
<p>在前端发送请求时<span class=" fw-cl "><span>，</span></span>需要在 Header 里加入 Range 参数<span class=" fw-cl "><span>，</span></span>同时服务器端响应时返回带有 Content-Range 的 Header<span class=" fw-cl "><span>，</span></span>也就是说 Range 和 Content-Range 是一对对应的 Header 头<span class=" fw-cl "><span>。</span></span></p>
<p>比如<span class=" fw-cl "><span>：</span></span></p>
<p><code>Range: bytes=500-999</code></p>
<p>就表示上传第 500-999 字节范围的内容<span class=" fw-cl "><span>，</span></span>而浏览器在发出带 Range 的请求后<span class=" fw-cl "><span>，</span></span>服务器会在 Content-Range 头部返回当前接受的范围和文件总大小<span class=" fw-cl "><span>，</span></span>比如<span class=" fw-cl "><span>：</span></span></p>
<p><code>Content-Range: bytes 0-499/22400</code></p>
<p>就指当前发送数据的范围是 0-499<span class=" fw-cl "><span>，</span></span>22400 则是文件的总 size<span class=" fw-cl "><span>。</span></span></p>
<p>我们来看一个例子<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li style="">浏览器下载一个 1024K 的文件<span class=" fw-cl "><span>，</span></span>当前已经下载了 512K</li>
  <li style="">这时候不幸网络故障<span class=" fw-cl "><span>，</span></span>稍后浏览器请求续传<span class=" fw-cl "><span>，</span></span>这时候带有 Range:bytes=512000 的 Header 头<span class=" fw-cl "><span>，</span></span>表明本次需要续传的片段</li>
  <li style="">服务端接收到断点续传的请求<span class=" fw-cl "><span>，</span></span>从文件的 512K 位置开始传输<span class=" fw-cl "><span>，</span></span>并返回 Header 头<span class=" fw-cl "><span>：</span></span> Content-Range:bytes 512000-/1024000<span class=" fw-cl "><span>，</span></span>注意这时候的 HTTP status code 是 206<span class=" fw-cl "><span>，</span></span>而非 200<span class=" fw-cl "><span>，</span></span>206 表示<span class=" fw-cl "><span>：</span></span>206 Partial Content<span class="fw-op  "><span>（</span></span>使用断点续传方式<span class=" fw-cl "><span>）</span></span></li>
</ul>
<p>请读者思考一个问题<span class=" fw-cl "><span>，</span></span>如果在网络故障期间<span class=" fw-cl "><span>，</span></span>服务器端文件发生了变化<span class=" fw-cl "><span>，</span></span>导致 512K 部分并不能对上之前的内容<span class=" fw-cl "><span>，</span></span>这个怎么办呢<span class=" fw-cl "><span>？</span></span></p>
<p>这时候就需要一个标识文件唯一性的标识符<span class=" fw-cl "><span>。</span></span>RFC2616 中规定可以使用 Last-Modified 顾名思义<span class=" fw-cl "><span>，</span></span>这样就可以标识文件的最后修改时间<span class=" fw-cl "><span>，</span></span>浏览器就可判断出续传文件时是否已经发生过改动<span class=" fw-cl "><span>。</span></span>这种方式并不惟一<span class=" fw-cl "><span>，</span></span>也可以通过名为 Etag 的 Header<span class=" fw-cl "><span>，</span></span>直接表文件的唯一标记<span class="fw-op  "><span>（</span></span>类似文件的 MD5 值<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>。</span></span>浏览器端请求时申明 If-None-Match 或者 If-Modified-Since 字段<span class=" fw-cl "><span>，</span></span>帮助服务端判别文件变化<span class=" fw-cl "><span>，</span></span>同时浏览器也可以采用 If-Range Header<span class=" fw-cl "><span>，</span></span>该头部包含 ETag 头或者是 Last-Modfied 信息<span class=" fw-cl "><span>，</span></span>同样可以帮助服务端进行内容校验<span class=" fw-cl "><span>。</span></span>这时候<span class=" fw-cl "><span>，</span></span>服务端在校验一致时返回 206 的续传回应校验不通过时<span class=" fw-cl "><span>，</span></span>服务端则返回 200 回应<span class=" fw-cl "><span>，</span></span>回应的内容为新的文件的全部数据<span class=" fw-cl "><span>。</span></span></p>
<h3>总结</h3>
<p>本讲我们以面试为切入点<span class=" fw-cl "><span>，</span></span>总结了网络基础知识的多个方面<span class=" fw-cl "><span>。</span></span>其中一些知识比较基础<span class=" fw-cl "><span>，</span></span>但根据我观察<span class=" fw-cl "><span>，</span></span>很多面试者都会在这些基础内容上<span class="fw-op  "><span>「</span></span>折腰<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>网络知识是一个系统性的知识体系<span class=" fw-cl "><span>，</span></span>还需要每一个开发者认真学习<span class=" fw-cl "><span>。</span></span>也许你有体会<span class=" fw-cl "><span>：</span></span><span class="fw-op  fw--collapsed"><span>「</span></span>在大学里学习网络知识时<span class=" fw-cl "><span>，</span></span>很多概念很难真正理解<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>，</span></span>而工作后有一定实战经验了<span class=" fw-cl "><span>，</span></span>但是<span class="fw-op  "><span>「</span></span>很多网络内容又缺少了理论的支持<span class=" fw-cl fw--collapsed"><span>」</span></span><span class=" fw-cl "><span>。</span></span>因此关于网络的学习<span class=" fw-cl "><span>，</span></span>我认为一定要理论结合实践<span class=" fw-cl "><span>。</span></span>这些计算机基础内容<span class=" fw-cl "><span>，</span></span>是一个开发者真正进阶的基本功<span class=" fw-cl "><span>。</span></span></p><p><span style="display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);">备案号:YXX11ZejEvYHkjx0PzibJlp</span></p>
</body>
</html>