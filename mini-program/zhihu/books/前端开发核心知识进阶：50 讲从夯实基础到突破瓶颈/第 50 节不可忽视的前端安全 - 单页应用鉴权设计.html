<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>第 50 节不可忽视的前端安全 - 单页应用鉴权设计</h1>
  <p>安全是计算机科学永远无法忽视的话题<span class=" fw-cl "><span>。</span></span>随着互联网的发展<span class=" fw-cl "><span>，</span></span>安全问题越来越突出<span class=" fw-cl "><span>，</span></span>也越来越重要<span class=" fw-cl "><span>：</span></span>它是一个程序可用性<span class=" fw-cl "><span>、</span></span>健壮性的基础<span class=" fw-cl "><span>。</span></span>这个话题可大可小<span class=" fw-cl "><span>，</span></span>大到系统的设计<span class=" fw-cl "><span>，</span></span>小到一行代码的写法<span class=" fw-cl "><span>，</span></span>都可能影响系统的安全<span class=" fw-cl "><span>。</span></span></p>
<p>毫不例外<span class=" fw-cl "><span>，</span></span>安全与前端开发的结合也持续走热<span class=" fw-cl "><span>。</span></span>不管是经验丰富的程序员<span class=" fw-cl "><span>，</span></span>还是尚在打基础的学生<span class=" fw-cl "><span>，</span></span>也许都对 HTTPS<span class=" fw-cl "><span>、</span></span>XSS<span class=" fw-cl "><span>、</span></span>CSRF 等前端相关的安全问题不陌生<span class=" fw-cl "><span>。</span></span>然而<span class=" fw-cl "><span>，</span></span>这其中每一个主题都可以非常深入<span class=" fw-cl "><span>，</span></span>都能系统地做一节课<span class=" fw-cl "><span>。</span></span>但是<span class=" fw-cl "><span>，</span></span>我认为面面俱到<span class=" fw-cl "><span>、</span></span>走马观花地梳理这些内容<span class=" fw-cl "><span>，</span></span>讲解这些概念价值不大<span class=" fw-cl "><span>。</span></span>毕竟<span class=" fw-cl "><span>，</span></span>这方面知识都已经比较成熟<span class=" fw-cl "><span>，</span></span>社区上资料很多<span class=" fw-cl "><span>。</span></span></p>
<p>本讲我想从一个大部分产品都要涉及的登录鉴权入手<span class=" fw-cl "><span>，</span></span>结合单页面应用<span class=" fw-cl "><span>，</span></span>从这个角度<span class=" fw-cl "><span>，</span></span>管中窥豹<span class=" fw-cl "><span>，</span></span>尽可能多地涉及一些常见的安全知识<span class=" fw-cl "><span>，</span></span>帮助大家了解前端安全<span class=" fw-cl "><span>。</span></span></p>
<p>接下来<span class=" fw-cl "><span>，</span></span>让我们从应用场景入手<span class=" fw-cl "><span>，</span></span>从前后端交互切入<span class=" fw-cl "><span>，</span></span>以单页面应用为基础<span class=" fw-cl "><span>，</span></span>呈现<span class="fw-op  "><span>「</span></span>鉴权<span class=" fw-cl "><span>」</span></span>这个安全领域重要话题的全貌<span class=" fw-cl "><span>，</span></span>并尽力覆盖到 XSS 和 CSRF 等攻击手段以及最佳实践<span class=" fw-cl "><span>。</span></span></p>
<p>关于这个主题的知识点如下<span class=" fw-cl "><span>：</span></span></p>
<p><br>
</p>
<figure class="central"><img data-src="https://pic4.zhimg.com/v2-106fe24c5d07424759762dbaa89a95ed.webp" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:38.27272727272727% 0" data-src="https://pic4.zhimg.com/v2-106fe24c5d07424759762dbaa89a95ed.webp">加载中...</span><figcaption>图片</figcaption></figure>
<h3>单页应用鉴权简介</h3>
<p>首先<span class=" fw-cl "><span>，</span></span>我们要分清单页应用鉴权与传统鉴权方式有所不同<span class=" fw-cl "><span>：</span></span></p>
<p><br>
</p>
<p>单页应用采用前后端分离的设计方式<span class=" fw-cl "><span>，</span></span>路由由前端管理<span class=" fw-cl "><span>，</span></span>前后端遵循一定规范<span class="fw-op  "><span>（</span></span>如 REST<span class=" fw-cl "><span>、</span></span>GraphQL<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>通过 AJAX 进行通信<span class=" fw-cl "><span>。</span></span>在这种情况下<span class=" fw-cl "><span>，</span></span>用户对页面请求时<span class=" fw-cl "><span>，</span></span>后端经常无法获取用户身份信息<span class=" fw-cl "><span>，</span></span>更无法确定返回的数据<span class=" fw-cl "><span>。</span></span></p>
<p>同时一次鉴权完毕后<span class=" fw-cl "><span>，</span></span>如何在单页应用的体验当中<span class=" fw-cl "><span>，</span></span>保持这个鉴权状态也值得思考<span class=" fw-cl "><span>。</span></span>一般来说<span class=" fw-cl "><span>，</span></span>单页应用鉴权采用下面的步骤实现<span class=" fw-cl "><span>。</span></span></p>
<ul>
  <li>Step 1<span class=" fw-cl "><span>：</span></span>前端根据用户交互<span class=" fw-cl "><span>，</span></span>发送数据请求之前<span class=" fw-cl "><span>，</span></span>需要准备用户信息<span class=" fw-cl "><span>，</span></span>同数据请求一起发给后端处理<span class=" fw-cl "><span>。</span></span></li>
  <li>Step 2-1<span class=" fw-cl "><span>：</span></span>后端按照约定好的规则<span class=" fw-cl "><span>，</span></span>根据请求中带有的用户身份信息<span class=" fw-cl "><span>，</span></span>进行验证<span class=" fw-cl "><span>。</span></span>如果验证不通过<span class=" fw-cl "><span>，</span></span>返回 403 或者 401 相关状态码或其他状态<span class=" fw-cl "><span>，</span></span>以表示鉴权失败<span class=" fw-cl "><span>。</span></span></li>
  <li>Step 2-2<span class=" fw-cl "><span>：</span></span>如果鉴权成功<span class=" fw-cl "><span>，</span></span>后端返回相关数据<span class=" fw-cl "><span>。</span></span></li>
  <li>Step 3<span class=" fw-cl "><span>：</span></span>前端根据数据渲染视图<span class=" fw-cl "><span>。</span></span></li>
</ul>
<p>基本结构非常简单清晰<span class=" fw-cl "><span>：</span></span></p>
<p><br>
</p>
<figure class="central"><img data-src="https://pic3.zhimg.com/v2-fbd76ae8a902961c02820352bb6995ef.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:30% 0" data-src="https://pic3.zhimg.com/v2-fbd76ae8a902961c02820352bb6995ef.png">加载中...</span><figcaption>图片</figcaption></figure>
<p>在这个结构背后<span class=" fw-cl "><span>，</span></span>隐藏的技术方案和安全细节非常值得我们思考<span class=" fw-cl "><span>，</span></span>请继续阅读<span class=" fw-cl "><span>，</span></span>我们将剖析几个重要概念和安全实践<span class=" fw-cl "><span>。</span></span></p>
<h4>HTTPS</h4>
<p>鉴权过程中<span class=" fw-cl "><span>，</span></span>如果使用 HTTP 协议来传输敏感数据<span class="fw-op  "><span>（</span></span>用户昵称<span class=" fw-cl "><span>、</span></span>用户密码<span class=" fw-cl "><span>、</span></span>token……<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>，</span></span>那么很容易被中间人拦截获取<span class=" fw-cl "><span>。</span></span>现代通信中<span class=" fw-cl "><span>，</span></span>我们都使用 HTTPS 协议来对传输内容进行加密<span class=" fw-cl "><span>。</span></span>关于 HTTPS 的应用及其原理<span class=" fw-cl "><span>，</span></span>又是一个超级话题<span class=" fw-cl "><span>。</span></span>这里由于内容的限制<span class=" fw-cl "><span>，</span></span>不过多展开<span class=" fw-cl "><span>，</span></span>给大家分享一下我收藏的关于 HTTPS 好的文章<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li><a href="https://mp.weixin.qq.com/s/--KxUNzmBdKtOPBbovWCaA">https 连接的前几毫秒发生了什么</a></li>
  <li><a href="https://juejin.im/post/5c441073e51d455226654d60">完全图解 HTTPS</a></li>
  <li><a href="https://juejin.im/post/5b5f1289e51d4519601aeeda">更安全的 Web 通信 HTTPS</a></li>
  <li><a href="https://www.infoq.cn/article/a-cartoon-intro-to-dns-over-https">图解基于 HTTPS 的 DNS</a></li>
  <li><a href="https://juejin.im/post/5b0274ac6fb9a07aaa118f49?utm_medium=fe&amp;utm_source=weixinqun">看图学 HTTPS</a></li>
  <li><a href="https://juejin.im/post/5af3e002f265da0b7c074ada">http 与 https 的区别我真的知道吗</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/22142170">深入揭秘 HTTPS 安全问题&amp;连接建立全过程</a></li>
  <li><a href="http://support.upyun.com/hc/kb/article/1031843/">HTTPS 系列干货<span class="fw-op  "><span>（</span></span>一<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>：</span></span>HTTPS 原理详解</a></li>
  <li><a href="http://support.upyun.com/hc/kb/article/1031843/https://juejin.im/post/58a8f3295c497d005fbd58b1">HTTPS 为什么更安全<span class=" fw-cl "><span>，</span></span>先看这些</a></li>
</ul>
<h4>不要使用 URL query 传递敏感数据</h4>
<p>URL query 会通过服务端日志<span class=" fw-cl "><span>、</span></span>浏览器日志<span class=" fw-cl "><span>、</span></span>浏览器历史记录查到<span class=" fw-cl "><span>。</span></span>不要使用 URL query 传递敏感数据<span class=" fw-cl "><span>，</span></span>这当然是最基本的准则之一<span class=" fw-cl "><span>。</span></span>如果敏感数据在 URL query 中<span class=" fw-cl "><span>，</span></span>这就给了恶意用户轻松获取数据的机会<span class=" fw-cl "><span>。</span></span>同时<span class=" fw-cl "><span>，</span></span>URL query 的长度也有限制<span class=" fw-cl "><span>，</span></span>这也是其传递数据的弊端之一<span class=" fw-cl "><span>。</span></span></p>
<h4>防止暴力攻击的手段</h4>
<p>攻击者可以通过暴力手段<span class=" fw-cl "><span>，</span></span>尝试攻破用户的密码等信息<span class=" fw-cl "><span>。</span></span>因此后端服务要时刻注意加入频率限制<span class=" fw-cl "><span>，</span></span>限制一个用户短时间尝试密码的次数<span class=" fw-cl "><span>；</span></span>也可以限制可疑用户<span class="fw-op  "><span>（</span></span>比如触发了过多服务端错误用户<span class=" fw-cl "><span>）</span></span>的访问<span class=" fw-cl "><span>。</span></span>另外<span class=" fw-cl "><span>，</span></span>需要注意的是不要给任何人暴露服务端的技术细节信息<span class=" fw-cl "><span>，</span></span>比如要记得关闭 X-Powered-By<span class="fw-op  "><span>（</span></span>服务器响应头隐藏<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>；</span></span>Node 端在使用 express.js 的情况下<span class=" fw-cl "><span>，</span></span>强烈建议使用 <a href="https://expressjs.com/en/advanced/best-practice-security.html#use-helmet">Helmetjs</a><span class=" fw-cl "><span>。</span></span>&nbsp;</p>
<p>Helmet 帮助 Node.js 开发者通过设置合理的 HTTP header<span class=" fw-cl "><span>，</span></span>预防一些常见的 Web 漏洞<span class=" fw-cl "><span>，</span></span>比如上面提到的关闭 X-Powered-By<span class=" fw-cl "><span>。</span></span>实际上它就是一组灵活的中间件函数<span class=" fw-cl "><span>，</span></span>增强以下 HTTP header 的安全性<span class=" fw-cl "><span>：</span></span></p>
<ul>
  <li>Content-Security-Policy 响应头<span class=" fw-cl "><span>，</span></span>它可以设置应用是否可以引用某些来源内容<span class=" fw-cl "><span>，</span></span>进而防止 XSS</li>
  <li>关闭 X-Powered-By 响应头<span class=" fw-cl "><span>，</span></span>以避免暴露服务端信息</li>
  <li>增加 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning">Public Key Pinning</a> 响应头<span class=" fw-cl "><span>，</span></span>预防中间人伪造证书</li>
  <li>设置 Strict-Transport-Security 响应头<span class=" fw-cl "><span>，</span></span>这样浏览器只能通过 HTTPS 访问当前资源&nbsp;</li>
  <li>为 IE8+ 设置 X-Download-Options 响应头<span class=" fw-cl "><span>，</span></span>目前只有 IE8+ 支持这个 header<span class=" fw-cl "><span>，</span></span>用来预防下载内容的安全隐患</li>
  <li>设置 Cache-Control 和 Pragma header 以关闭浏览器端缓存</li>
  <li>设置 X-Content-Type-Options 响应头<span class=" fw-cl "><span>，</span></span>以禁用浏览器内容嗅探</li>
  <li>设置 X-Frame-Options 响应头<span class=" fw-cl "><span>，</span></span>以预防 <a href="https://www.owasp.org/index.php/Clickjacking">clickjacking</a><span class=" fw-cl "><span>，</span></span>这个响应头给浏览器指示是否允许在 &nbsp;或者 <code></code> 标签中渲染某个页面</li> &nbsp;&nbsp;<li style="">设置 X-XSS-Protection<span style="opacity:0"> </span>响应头<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>当检测到跨站脚本攻击<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>XSS<span class=" fw-cl "><span><span class=" fw-cl "><span>）</span></span></span></span>时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>浏览器停止加载页面</li> </ul> <p>它的使用非常简单<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><code>const express = require('express')<br> const helmet = require('helmet')<br> <br> const app = express()<br> <br> app.use(helmet())</code></p> <p>其源码是典型的 express 中间件写法<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>它依次加载相关中间件集<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>比如它将引用 X-Powered-By 中间件<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>这个中间件的源码非常简单<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><code>module.exports = function hidePoweredBy (options) {<br> &nbsp;<span style="opacity:0"> </span>var setTo = (options || {}).setTo<br> <br> &nbsp;<span style="opacity:0"> </span>if (setTo) {<br> &nbsp;<span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span>return function hidePoweredBy (req, res, next) {<br> &nbsp;<span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span>res.setHeader('X-Powered-By', setTo)<br> &nbsp;<span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span>next()<br> &nbsp;<span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span>}<br> &nbsp;<span style="opacity:0"> </span>} else {<br> &nbsp;<span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span>return function hidePoweredBy (req, res, next) {<br> &nbsp;<span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span>res.removeHeader('X-Powered-By')<br> &nbsp;<span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span>next()<br> &nbsp;<span style="opacity:0"> </span><span style="opacity:0"> </span><span style="opacity:0"> </span>}<br> &nbsp;<span style="opacity:0"> </span>}<br> }</code></p> <p>通过 setHeader 和 removeHeader 方法<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>完成对 X-Powered-By 响应头的添加和删除<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <h4>升级依赖保证安全</h4> <p>现如今我们的应用<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>大部分脚本都来自第三方依赖<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>第三方库出现安全隐患的新闻已经屡见不鲜<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>除了从源头把控依赖的引入外<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>适时合理地更新 npm 包<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>是值得倡导的做法<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>npm 便在 6.0 后有相关命令如下<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><code># npm 6.0 新增<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>扫描所有依赖<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>列出依赖中有安全隐患的包<br> npm audit<br> # npm 6.0 新增<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>扫描所有依赖<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>并把不安全的依赖包升级到可兼容的版本<br> npm audit fix</code></p> <h3>单页应用鉴权实战</h3> <p>言归正传<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>我们来看一下实现单页应用鉴权的两种主要手段<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style="">JWT</li> &nbsp;&nbsp;<li style="">Authentication cookie</li> </ul> <p><strong style="">这两种方式不尽相同<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>我们将逐一分析<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>并尝试合并这两种方案的优点<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>将它们结合为第三种方式<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></strong></p> <h4>采用 JWT 实现鉴权</h4> <p>在鉴权过程中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>为了验证用户的身份<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>需要浏览器向服务器端提供一个验证信息<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>我们称为 token<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>这个 token 通常由 JSON 数据格式组成<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>通过 hash 散列算法生成一个字符串<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>称为 JSON Web Token<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>JSON 表示令牌的原始类型为 JSON 格式<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>Web 表示在互联网中进行传播<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>Token 表示令牌<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>简称 JWT<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>任何 token 持有者都可以无差别地用它来访问相关的资源<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>我们可以在 HTTP Authorization header 中找到 token<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>其实就是一个字符串值<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>这个字符串用来表示用户的身份信息<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>进行身份认证或者从服务器获取合法资源<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>当然这个 token 往往是被加密的<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>那么这个 token 具体是如何生成的呢<span class=" fw-cl "><span><span class=" fw-cl "><span>？</span></span></span></span></p> <p>我们先从 JWT 说起<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>一个 JWT 包含以下 3 个部分<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style="">header<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>消息头<span class=" fw-cl "><span><span class=" fw-cl "><span>）</span></span></span></span></li> &nbsp;&nbsp;<li style="">payload<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>消息体<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>储存用户 id<span class=" fw-cl "><span><span class=" fw-cl "><span>、</span></span></span></span>用户角色等<span class=" fw-cl "><span><span class=" fw-cl "><span>）</span></span></span></span> + 过期时间<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>可选<span class=" fw-cl "><span><span class=" fw-cl "><span>）</span></span></span></span></li> &nbsp;&nbsp;<li style="">signature<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>签名<span class=" fw-cl "><span><span class=" fw-cl "><span>）</span></span></span></span></li> </ul> <p>我们说过<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>JWT 就是 JSON 格式的数据<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>JWT 的前两个部分就是 JSON 数据<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>第三部分 signature 是基于前两部分 header 和 payload 生成的签名<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>前两部分分别通过 Base64URL 算法生成两组字符串<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>再和 signature 结合<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>三部分通过 . 号分割<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>就是最终的 token<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>更多这方面的信息<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>大家可以参考<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style=""><a href="https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec" title="5 Easy Steps to Understanding JSON Web Tokens (JWT)">5 Easy Steps to Understanding JSON Web Tokens (JWT)</a></li> &nbsp;&nbsp;<li style=""><a href="https://www.jianshu.com/p/8f7009456abc" title="Bearer Token">Bearer Token</a></li> &nbsp;&nbsp;<li style=""><a href="https://www.cnblogs.com/XiongMaoMengNan/p/6785155.html" title="OAuth 2.0: Bearer Token Usage">OAuth 2.0: Bearer Token Usage</a></li> </ul> <p>正常来讲<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>当客户端在提交用户名/密码<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>或者其他方式<span class=" fw-cl "><span><span class=" fw-cl "><span>）</span></span></span></span>通过认证后<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>会获得 JWT 的 token<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>接着通过 JavaScript 脚本<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>对于所有数据请求都在其 HTTP header 中加上这个 JWT 的 token<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>服务端接到请求之后<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>验证 token 的 signature 是否等同于 payload<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>进而得知 payload 字段是否被中间人更改<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>细心的读者可能会发现<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>我们提到<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>「</span></span></span></span>通过 JavaScript 脚本<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>对于所有数据请求<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>都在 HTTP header 中加上这个 token<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>」</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>这就涉及<strong style="">客户端如何存储和维护 JWT</strong> 的问题了<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>存储 JWT<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>我们可以考虑<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style="">内存存储</li> &nbsp;&nbsp;<li style="">local/session cookie</li> &nbsp;&nbsp;<li style="">local/session storage……</li> </ul> <p>这几种方式<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>我并不建议开发者将 token 存储在 local storage 当中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>因为<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style="">当用户关掉浏览器后<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>JWT 仍然会被存储在 local storage 中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>即便 JWT 过期<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>可能一直被存储<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>除非手动更新或清理<span class=" fw-cl "><span><span class=" fw-cl "><span>）</span></span></span></span></li> &nbsp;&nbsp;<li style="">任何 JavaScript 都能轻而易举地获得 local storage 的内容</li> &nbsp;&nbsp;<li style="">无法被 web worker 使用</li> </ul> <p>但在实际项目中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>笔者也在 local storage 中存储过 JWT<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>这需要我们分清利弊<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>结合实际场景选择方案<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>如果吃透概念<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>就能减少 bug 的出现<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>具体存储方案可以灵活一些<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>更好的选择之一是将 JWT 存储在 session cookie 中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>auth0 有一篇很好的文章<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>感兴趣的读者可以参考<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span><a href="https://auth0.com/docs/security/store-tokens" title="Where to Store Tokens">Where to Store Tokens</a><span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <h4>JWT 隐患</h4> <p>JWT 实现鉴权也存在的隐患<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>上面我们也简要提到了<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>隐患主要来自 <a href="https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29" title="XSS">XSS</a><span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>攻击者可以主动注入恶意脚本或者使用用户输入<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>通过 JavaScript 代码来偷取 token<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>接下来便能通过 token 冒充受害用户<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>比如<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>一个博客留言系统<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>用户可以在其留言内容中加入以下脚本<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><code><img src="x" onerror="javascript:alert('XSS')"></code></p> <p>一般的防御手段是采用 HTML 转义来控制过滤用户输入<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>为了防止 XSS 攻击<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>常常需要将用户输入的特殊字符进行转义<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <h3>采用 Authentication cookie 实现鉴权</h3> <p>cookie 是含有有效期和相关 domain<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>存储在浏览器中的键值对组合<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>可以由 JavaScript 创建<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><code>document.cookie = <span class="fw-op &nbsp;"><span><span class="fw-op  "><span>『</span></span></span></span>my_cookie_name=my_cookie_value<span class=" fw-cl "><span><span class=" fw-cl "><span>』</span></span></span></span></code></p> <p>也可以由服务端通过 response header 创建<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><code>Set-Cookie: my_cookie_name=my_cookie_value</code></p> <p>浏览器会自动在每个请求当中加入相关 domain 下的 cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><code>GET https://www.example.com/api/users<br> Cookie: my_cookie_name=my_cookie_value</code></p> <p>cookie 一般分为两种<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" title="出处">出处</a><span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <blockquote><br></blockquote> <ul> &nbsp;&nbsp;<li style="">Session cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>这种 cookie 会随着用户关闭浏览器而被清除<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>不会被标记任何过期时间 Expires 或者最大时限 Max-Age<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> &nbsp;&nbsp;<li style="">Permanent cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>与 session cookie 相反<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>会在用户关闭浏览器之后被浏览器持久化存储<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> </ul> <p>同时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>服务端可以对 cookie 进行一些关键配置<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>以保障 cookie 的使用安全<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>诸如<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style="">HttpOnly cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>浏览器端 JavaScript 没有读 cookie 权限<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> &nbsp;&nbsp;<li style="">Secure cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>传输链路只有在特定安全通道<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>通常指 HTTPS<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>请求才会自动加入相关 cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> &nbsp;&nbsp;<li style="">SameSite cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>在跨域情况下<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>相关 cookie 无法被请求携带<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>这里主要是为了防止 CSRF 攻击<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> </ul> <p>一个经典场景就是使用 cookie 存储一个 session ID<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>session ID 由服务端管理<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>进行创建和计时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>以便在必要的时候清除<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>通过验证 cookie 和 session ID<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>服务端便能标记一个用户的访问信息<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>这种情况就是我们说的 stateful<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>而本节课的主角 JWT 是 stateless 的<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>因为它不需要服务端维护 session ID<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>是无状态的<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>更加利于横向扩展<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <h4>Authentication cookie 隐患</h4> <p>采用 Authentication cookie 实现单页应用鉴权的安全隐患主要有两种<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style=""><br></li> </ul> <p><a href="https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29" title="XSS">XSS</a>　如果没有使用 httpOnly 选项<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>那么攻击者可能会通过注入恶意脚本<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>任意读取用户 cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>而 cookie 直接存储了用户的身份认证信息<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>这当然是非常可怕的<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style=""><br></li> </ul> <p><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF" title="CSRF">CSRF</a>) 是常见的针对 cookie 展开进攻的手段<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>我们知道跨域访问技术<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>CORS<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>跨域资源共享<span class=" fw-cl "><span><span class=" fw-cl "><span>）</span></span></span></span>的同源策略能保证不同源的客户端脚本在没有明确授权的情况下<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>无法读写对方资源<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>同源策略只是针对浏览器侧的编程脚本语言<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>如果我们对另一个恶意服务器发送 AJAX 请求<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>同源策略会有所限制<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>但是如果请求直接通过 HTML form 发送<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>那么同源策略毫无办法<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p><code></code></p><form action="http://someotherserver.com"><p></p> <p>另一个利用 CSRF 实施攻击的场景为<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>假如受害者在网页中登录了 Facebook<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>同时又打开了 bad.com<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>bad.com 属于攻击者的网站<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>这个网站中有这样的代码<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><code><img src="https://facebook.com/postComment?userId=dupont_123&amp;comment=I_VE_BEEN_HACKED></code></p> <p>如此一来<span class=" fw-cl="" "=""><span><span class=" fw-cl "><span>，</span></span></span>攻击者网站的代码请求了 Facebook 发送个人状态的接口<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span><a href="https://facebook.com/postComment?%EF%BC%89%EF%BC%8C%E8%AF%A5%E5%8F%97%E5%AE%B3%E8%80%85%E4%BC%9A%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E5%9C%B0%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E7%8A%B6%E6%80%81%EF%BC%8C%E5%86%85%E5%AE%B9%E4%B8%BA" title="https://facebook.com/postComment?<span class=" fw-cl="" fw--collapsed"=""><span>）</span><span class=" fw-cl "><span>，</span></span>该受害者会莫名其妙地发送一个状态<span class=" fw-cl "><span>，</span></span>内容为"&gt;https://facebook.com/postComment?<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>该受害者会莫名其妙地发送一个状态<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>内容为</a> "I_VE_BEEN_HACKED"<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></code></p><code> <p><br></p> <p><strong style="">总结</strong>　为了防御 XSS 攻击<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>需要开发者设置 <code>httpOnly</code> 选项<span class=" fw-cl "><span><span class=" fw-cl "><span>；</span></span></span></span>为了防御 XSRF<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>需要开发者设置 <code>SameSite</code> 选项<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>需要注意<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>并不是所有浏览器都支持 <a href="https://caniuse.com/#feat=same-site-cookie-attribute" title="SameSite">SameSite</a><span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p><strong style="">此外<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>一些其他防御手段有<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></strong></p> <ul> &nbsp;&nbsp;<li style="">Short session timeout<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>设置 session 过期时间<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>比如银行网站往往需要每 10 分钟或者更短时间就重新登录<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> &nbsp;&nbsp;<li style="">关键操作需要用户重新进行鉴权认证<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> &nbsp;&nbsp;<li style="">Double submitted cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>当用户浏览一个站点时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>服务端生成一个伪随机数 pseudorandom value<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>并将其设置为 cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>且不设置 httpOnly 标识<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>这样 JavaScript 就能够访问这个 pseudorandom value<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>并要求在提交每个表单时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>一并将这个 pseudorandom value 作为 form value 提交上来<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>同时在 cookie 中也要提交 value<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>服务端便可以对比 form value 中的 pseudorandom value 和 cookie value 是否一致<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>以此来认证用户的安全身份<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> </ul> <p>Double submitted cookie 之所以能有效防范攻击<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>是因为同源策略致使攻击者无法读取来自攻击目标服务端的 cookie 值<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>更无法修改攻击网站的 cookie value<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>即便攻击者可以从 form 中提交任何 form value<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>但是无法通过服务端对 form value 中的 pseudorandom value 和 cookie value 的一致性进行验证<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <h3>混合 JWT 和 cookie 进行鉴权</h3> <p>设想我们要实现这样一个鉴权系统<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style="">尽可能抵御 XSS 和 CSRF</li> &nbsp;&nbsp;<li style="">做到 stateless</li> </ul> <p>考虑到安全性能<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>JWT 方案的主要问题在于攻击者存在直接读取 JWT 信息的可能<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span><strong style="">如果我们将 JWT 和 cookie 方案结合呢</strong><span class=" fw-cl "><span><span class=" fw-cl "><span>？</span></span></span></span>即将 JWT 部分敏感信息放入 cookie 当中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>这样一来<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>便可以结合前文两种方式的优点<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>如图<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>我们再总结一下存在的三种交互可能<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>第一种是经典 JWT 方式<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><br></p> <figure class="central"><img data-src="https://pic2.zhimg.com/v2-6149a37d2f5a831738d30f2df49ba2c9.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:27.575% 0" data-src="https://pic2.zhimg.com/v2-6149a37d2f5a831738d30f2df49ba2c9.png">加载中...</span></figure> <p>这种情况下<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>前后端使用 JWT 进行鉴权交互<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>前端通过 JavaScript 操作 JWT 信息完成请求准备<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>第二种方式<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>将 JWT 信息在 session cookie 中维护<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><br></p> <figure class="central"><img data-src="https://pic1.zhimg.com/v2-077aca5e067090d6ae685af062d0a2f9.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:26.8% 0" data-src="https://pic1.zhimg.com/v2-077aca5e067090d6ae685af062d0a2f9.png">加载中...</span></figure> <p>在这种情况下<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>JWT 信息全部存储在 cookie 中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span> 并设置 cookie 的 httpOnly<span class=" fw-cl "><span><span class=" fw-cl "><span>、</span></span></span></span>SameSite<span class=" fw-cl "><span><span class=" fw-cl "><span>、</span></span></span></span>Secure 属性<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>前端无法读取 JWT 信息<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>但每次请求都会由浏览器带上必要的 JWT 数据<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>作为 cookie<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>同时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>由于采用 session cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>也不存在 JWT 信息过期的情况<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>用户关闭页面之后不会将 JWT 信息持久化存储<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>下次再打开页面时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>会重新进行鉴权流程<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>第一种方式有一定的安全隐患<span class=" fw-cl "><span><span class=" fw-cl "><span>；</span></span></span></span>第二种方式我们将 JWT 所有信息存储在 session cookie 当中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>优点明显<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>但是无法做到持久化存储<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>在某种程度上也会带来不便<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>那么我们权衡之后进行了变通<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>结合前面两种方式产生了第三种方式<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><br></p> <figure class="central"><img data-src="https://pic4.zhimg.com/v2-12ff3eadecd3f7dd0cb000d8a264d73b.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:27.400000000000002% 0" data-src="https://pic4.zhimg.com/v2-12ff3eadecd3f7dd0cb000d8a264d73b.png">加载中...</span></figure> <p>这样<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>JWT 的 signature 部分维护在设置了 httpOnly 的 cookie 中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>这意味着 JavaScript 无法读取完整的 JWT 信息<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>同时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>cookie 会在每次请求中被携带<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span> 并由服务端返回后在浏览器中进行存储<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>这样 JWT 信息在每次请求时都可以被更新<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>JWT 过期时间也会被自动加入<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>这篇文章<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span><a href="https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3" title="Getting Token Authentication Right in a Stateless Single Page Application">Getting Token Authentication Right in a Stateless Single Page Application</a> 就很好地对上述方式进行了总结<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>为了实现最大限度的安全保障<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>我们也可以考虑结合前文介绍的 Double submitted cookie 以及<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>「</span></span></span></span>关键操作需要用户重新进行鉴权认证<span class=" fw-cl "><span><span class=" fw-cl "><span>」</span></span></span></span>的处理<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>例如<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>我们认为用户更改邮箱地址<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>是一个关键操作<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>那么<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>在发生这个操作时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>即便用户已经登录<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>系统还是要求用户重新填写用户密码<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>以确认修改<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>后端在收到修改请求后<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>产生一个随机 number<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>经过加密运算<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>作为 permanent cookie 返回给前端<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>JavaScript 需要读取这个值<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>并将这个随机 number 作为表单 form value 的一项<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>它需要随新的邮箱地址一起提交<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>服务端对这个随机 form value 进行验证<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>验证方式是对比表单中的 form value 和 cookie 当中的随机 number 是否一致<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>这样便更大限度地防御了 CSRF 攻击<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>流程如下<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><br></p> <figure class="central"><img data-src="https://pic4.zhimg.com/v2-53e1a875af23fc161f0bccd60949173d.png" alt="图片" class="richText-img-source"><span class="processImgLazyload-placeholder-e5egJ richText-img-placeholder" style="padding:31.674999999999997% 0" data-src="https://pic4.zhimg.com/v2-53e1a875af23fc161f0bccd60949173d.png">加载中...</span></figure> <p>我们总结一下流程<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style="">Step 1<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>单页应用检查 cookie 中是否存在 JWT payload<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>如果存在<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>表示用户已经成功进行鉴权<span class=" fw-cl "><span><span class=" fw-cl "><span>；</span></span></span></span>反之<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>重定向到类似 /login 的登录页面<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> &nbsp;&nbsp;<li style="">Step2<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>用户在未授权的情况下<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>在登录页面 /login 将用户名和密码提交给服务端<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>服务端返回信息中设置 authentication cookie<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>cookie 中含有 JWT 信息<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></li> </ul> <p>第二步的具体操作方法可以采用上述第二种和第三种方式<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>或者增强 CSRF 防御的其他手段<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <h3>总结</h3> <p>我们再来总结一下单页应用进行鉴权的关键问题<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>token 最初由服务端下发<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>前端在请求时需要携带<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>这样一来<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style=""><br></li> </ul> <p>如果前端将 JWT 存储在 localStorage 或者 sessionStorage 当中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>由于 localStorage 或者 sessionStorage 都可以被 JavaScript 访问<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>如果攻击者能够读取 localStorage 或者 sessionStorage<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>那么就能轻易获取 token<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>很容易进行 XSS 攻击<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <ul> &nbsp;&nbsp;<li style=""><br></li> </ul> <p>如果将 JWT 存储在 cookie 当中<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>我们就可以指定 cookie httpOnly 属性<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>来防止被 JavaScript 读取<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>也可以指定 secure 属性<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>来保证 JWT 信息只在 HTTPS 下被携带<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>但是这样容易遭到 CSRF 攻击<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>因此就出现了我们的增强方式<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>本节我们通过分析和设计单页应用鉴权方案<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>熟悉了 JWT 和传统 cookie-session<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>我们在介绍一些安全方面最佳实践的同时<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>覆盖了一些常见的攻击手段<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>XSS 和 CSRF 等<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>前端安全是一个庞大且复杂的课题<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>本节只是通过一个比较重要的话题带大家切入<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>要想全面熟悉前端安全<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>完全可以开一门新课了<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span>虽然我的课程志不在此<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>不过下面我会根据相关安全话题<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>将我收藏的文章分享给大家<span class=" fw-cl "><span><span class=" fw-cl "><span>。</span></span></span></span></p> <p>课程代码仓库<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span></p> <p><a href="https://github.com/HOUCe/lucas-gitchat-courses%3C/a%3E" title="https://github.com/HOUCe/lucas-gitchat-courses</a>">https://github.com/HOUCe/lucas-gitchat-courses</a></p> <h3>彩蛋分享</h3> <h4>HTTPS 相关</h4> <ul> &nbsp;&nbsp;<li style=""><a href="https://mp.weixin.qq.com/s/--KxUNzmBdKtOPBbovWCaA" title="https 连接的前几毫秒发生了什么">https 连接的前几毫秒发生了什么</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5c441073e51d455226654d60" title="完全图解 HTTPS">完全图解 HTTPS</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5b5f1289e51d4519601aeeda" title="更安全的 Web 通信 HTTPS">更安全的 Web 通信 HTTPS</a></li> &nbsp;&nbsp;<li style=""><a href="https://www.infoq.cn/article/a-cartoon-intro-to-dns-over-https" title="图解基于 HTTPS 的 DNS">图解基于 HTTPS 的 DNS</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5b0274ac6fb9a07aaa118f49?utm_medium=fe&amp;utm_source=weixinqun" title="看图学 HTTPS">看图学 HTTPS</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5af3e002f265da0b7c074ada" title="http 与 https 的区别我真的知道吗">http 与 https 的区别我真的知道吗</a></li> &nbsp;&nbsp;<li style=""><a href="https://zhuanlan.zhihu.com/p/22142170" title="深入揭秘 HTTPS 安全问题&amp;连接建立全过程">深入揭秘 HTTPS 安全问题&amp;连接建立全过程</a></li> &nbsp;&nbsp;<li style=""><a href="http://support.upyun.com/hc/kb/article/1031843/" title="HTTPS 系列干货<span class=" fw-op="" "=""><span>（</span>一<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>：</span></span>HTTPS 原理详解"&gt;HTTPS 系列干货<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>一<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>HTTPS 原理详解</a></li> &nbsp;&nbsp;<li style=""><a href="http://support.upyun.com/hc/kb/article/1031843/https://juejin.im/post/58a8f3295c497d005fbd58b1" title="HTTPS 为什么更安全<span class=" fw-cl="" "=""><span>，</span>先看这些"&gt;HTTPS 为什么更安全<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>先看这些</a></li> </ul> <h4>攻防</h4> <ul> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/entry/58481d33128fe100579cb8c5" title="Web 前端攻防<span class=" fw-cl="" "=""><span>，</span>一不小心就中招了"&gt;Web 前端攻防<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>一不小心就中招了</a></li> &nbsp;&nbsp;<li style=""><a href="https://segmentfault.com/a/1190000006672214" title="聊一聊 WEB 前端安全那些事儿">聊一聊 WEB 前端安全那些事儿</a></li> &nbsp;&nbsp;<li style=""><a href="https://zoumiaojiang.com/article/common-web-security/" title="常见 Web 安全攻防总结">常见 Web 安全攻防总结</a></li> &nbsp;&nbsp;<li style=""><a href="http://www.guofengxian.com/2018/01/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E6%8C%87%E5%8D%97/" title="前端安全防御指南">前端安全防御指南</a></li> &nbsp;&nbsp;<li style=""><a href="http://netsecurity.51cto.com/art/201407/446775.htm" title="对于 XSS 和 CSRF 你究竟了解多少">对于 XSS 和 CSRF 你究竟了解多少</a></li> &nbsp;&nbsp;<li style=""><a href="https://mp.weixin.qq.com/s/c_QTdLu6vsYcIiuPRZyjyA" title="浅析前端安全之 XSS">浅析前端安全之 XSS</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/entry/5b461d866fb9a04fb745c256" title="懂这些<span class=" fw-cl="" "=""><span>，</span>你将能构建更安全的 Web 应用"&gt;懂这些<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>你将能构建更安全的 Web 应用</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/entry/5b4b56fd5188251b1a7b2ac1" title="浅说 XSS 和 CSRF">浅说 XSS 和 CSRF</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5b7bdfa1f265da437174ae0d" title="快速找出网站中可能存在的 XSS 漏洞实践">快速找出网站中可能存在的 XSS 漏洞实践</a></li> &nbsp;&nbsp;<li style=""><a href="https://mp.weixin.qq.com/s/kWxnYcCTLAQp5CGFrw30mQ" title="前端安全系列之一<span class=" fw-cl="" "=""><span>：</span>如何防止 XSS 攻击<span class=" fw-cl "><span>？</span></span>"&gt;前端安全系列之一<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>如何防止 XSS 攻击<span class=" fw-cl "><span><span class=" fw-cl "><span>？</span></span></span></span></a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5bc009996fb9a05d0a055192" title="前端安全系列之二<span class=" fw-cl="" "=""><span>：</span>如何防止 CSRF 攻击<span class=" fw-cl "><span>？</span></span>"&gt;前端安全系列之二<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>如何防止 CSRF 攻击<span class=" fw-cl "><span><span class=" fw-cl "><span>？</span></span></span></span></a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5bf214e151882579cf011c2a" title="Web 安全漏洞之 XSS 攻击">Web 安全漏洞之 XSS 攻击</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5c137f37f265da6133567735" title="前端技术演进<span class=" fw-op="" "=""><span>（</span>三<span class=" fw-cl fw--collapsed"><span>）</span></span><span class=" fw-cl "><span>：</span></span>前端安全"&gt;前端技术演进<span class="fw-op &nbsp;"><span><span class="fw-op  "><span>（</span></span></span></span>三<span class=" fw-cl fw--collapsed"><span><span class=" fw-cl "><span>）</span></span></span></span><span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>前端安全</a></li> &nbsp;&nbsp;<li style=""><a href="https://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/" title="Preventing CSRF and XSRF Attacks">Preventing CSRF and XSRF Attacks</a></li> </ul> <h4>同源策略和跨域理论相关</h4> <ul> &nbsp;&nbsp;<li style=""><a href="http://blog.w2fzu.com/2018/03/10/2018-04-02-same-origin/" title="跨域与同源策略探究">跨域与同源策略探究</a></li> &nbsp;&nbsp;<li style=""><a href="https://www.cnblogs.com/yincheng/p/cross-domain.html" title="同源策略和跨域请求研究">同源策略和跨域请求研究</a></li> &nbsp;&nbsp;<li style=""><a href="https://segmentfault.com/q/1010000011535675/a-1020000011537760" title="为什么提交表单不受同源政策限制">为什么提交表单不受同源政策限制</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5ab21717518825611a405da3" title="跨域资源共享 CORS 一些知识点">跨域资源共享 CORS 一些知识点</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/entry/5b82b5e56fb9a01a02311b27" title="Content Security Policy (CSP) 介绍">Content Security Policy (CSP) 介绍</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5b7e826ee51d4538b35c04e8" title="30 分钟理解 CORB 是什么">30 分钟理解 CORB 是什么</a></li> &nbsp;&nbsp;<li style=""><a href="https://mp.weixin.qq.com/s/T5gM7M9WsRMSxXzZPDagcA" title="不要再问我跨域的问题了">不要再问我跨域的问题了</a></li> </ul> <h4>鉴权</h4> <ul> &nbsp;&nbsp;<li style=""><a href="https://www.jianshu.com/p/af8360b83a9f" title="讲真<span class=" fw-cl="" "=""><span>，</span>别再使用 JWT 了<span class=" fw-cl "><span>！</span></span>"&gt;讲真<span class=" fw-cl "><span><span class=" fw-cl "><span>，</span></span></span></span>别再使用 JWT 了<span class=" fw-cl "><span><span class=" fw-cl "><span>！</span></span></span></span></a></li> &nbsp;&nbsp;<li style=""><a href="https://blog.csdn.net/hxg117/article/details/76954606" title="JWT Token 存储在 Cookie 还是 Web Storage">JWT Token 存储在 Cookie 还是 Web Storage</a></li> &nbsp;&nbsp;<li style=""><a href="https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3" title="Getting Token Authentication Right in a Stateless Single Page Application">Getting Token Authentication Right in a Stateless Single Page Application</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/entry/58a298f4128fe100582bf5c1" title="登录那些事儿">登录那些事儿</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/entry/58a3d6f561ff4b006c875ee1" title="登录工程<span class=" fw-cl="" "=""><span>：</span>现代 Web 应用的典型身份验证需求"&gt;登录工程<span class=" fw-cl "><span><span class=" fw-cl "><span>：</span></span></span></span>现代 Web 应用的典型身份验证需求</a></li> &nbsp;&nbsp;<li style=""><a href="https://blog.csdn.net/wang839305939/article/details/78713124" title="前后端常见的几种鉴权方式">前后端常见的几种鉴权方式</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5b73c71fe51d45666016655a" title="前端关于单点登录的知识">前端关于单点登录的知识</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5af5711e5188254267261e3b" title="如何加密传输和存储用户密码">如何加密传输和存储用户密码</a></li> &nbsp;&nbsp;<li style=""><a href="https://mp.weixin.qq.com/s/G_Grk8YTlu9-0WDZP85xAg" title="Web 登录其实没那么简单">Web 登录其实没那么简单</a></li> </ul> <h4>CDN 劫持和其他安全问题</h4> <ul> &nbsp;&nbsp;<li style=""><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227961&amp;idx=1&amp;sn=d4eb72b910281a18fc35581e0e39096f&amp;chksm=bd495ebd8a3ed7ab2dcc8d6bbfdd6f336f5b80a301cd3e7f92f56bdd3c95c749d9d6fd77282f&amp;mpshare=1&amp;scene=1&amp;srcid=0310vrk1VnUROjJY9XZ51Hoc" title="危险的 target=" _blank"="" 与="" <span="" class="fw-op  "><span>「</span>opener<span class=" fw-cl "><span>」</span></span>"&gt;危险的 target="_blank" 与 <span class="fw-op &nbsp;"><span><span class="fw-op  "><span>「</span></span></span></span>opener<span class=" fw-cl "><span><span class=" fw-cl "><span>」</span></span></span></span></a></li> &nbsp;&nbsp;<li style=""><a href="https://zhuanlan.zhihu.com/p/40682772" title="浅谈流量劫持与防治">浅谈流量劫持与防治</a></li> &nbsp;&nbsp;<li style=""><a href="https://security.tencent.com/index.php/blog/msg/126" title="短网址安全浅谈">短网址安全浅谈</a></li> &nbsp;&nbsp;<li style=""><a href="https://juejin.im/post/5c355a816fb9a049a42f3ac8" title="使用 SRI 解决 CDN 劫持">使用 SRI 解决 CDN 劫持</a></li> &nbsp;&nbsp;<li style=""><a href="https://mp.weixin.qq.com/s/gVLXJO0IXol4q_ademXMWg" title="了解下 DDoS 攻击方式">了解下 DDoS 攻击方式</a></li> &nbsp;&nbsp;<li style=""><a href="https://mp.weixin.qq.com/s/govRdwkNTEBJ1NJ1ipA40w?add=add" title="主流浏览器图片反防盗链方法总结">主流浏览器图片反防盗链方法总结</a></li> </ul></code>
<p><span style="display:block;font-size: 13px;opacity:0.5;transform:translateY(-20px);">备案号:YXX1JD320nQF1vKmB9FAalv</span></p></form>
</body>
</html>